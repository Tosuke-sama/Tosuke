<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>用logisim实现4位先行进位</title>
    <url>/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/</url>
    <content><![CDATA[<h3 id="实验目的：">实验目的：</h3>
<p>掌握快速加法器中先行进位的原理，能利用相关知识设计4位先行进位电路，并利用设计的4位先行进位电路构造4位快速加法器，能分析对应电路的时间延迟。</p>
<h3 id="实验结果：">实验结果：</h3>
<img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/图片9.png" style="zoom:80%;">
<h3 id="实验过程及结果分析：">实验过程及结果分析：</h3>
<p>由于串行加法器在每一位的加法时需要等待下一位的进位后才能进行加减，这就导致了时间的大量浪费，如果我们能够提前知道进位（先行进位）的话，这样的话后位的加减不用等着前位的进位，时间将会大大缩短。</p>
<p>所以，有规定为：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/%E5%9B%BE%E7%89%876.png" alt></p>
<p>所以，一位加法的所有进位形态分为进位取消、进位传播、进位产生，在这里我们只关心进位传播与进位产生，列出全加器的运算公式：</p>
<p>$$<br>
Si=ai⊕bi⊕ci;<br>
Ci+1=ai*bi+（ai⊕bi）*ci<br>
$$</p>
<p>这是每一位的结果，根据我们刚才的分类pi（进位传播项）=ai⊕bi、gi（进位产生项）=ai*bi我们可以得到全加器的公式变形：</p>
<p>$$<br>
Si=pi⊕ci;<br>
Ci+1=gi+pi*ci<br>
$$</p>
<p>这就是我们每一位求出来的值，pi、gi都只与ai与bi有关，故我们只需要求出ci即可，但是ci又与上一位ci有关系，我们将所有ci的运算公式列出：</p>
<img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/图片7.png" style="zoom:80%;">
<p>而我们将ci依次带入后一位得：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/%E5%9B%BE%E7%89%878.png" alt></p>
<p>所以现在所有值都只与ai、bi、c0有关了，我们就可以通过ai、bi和c0直接算出每一位的值而不再需要等待进位了。</p>
<p>将p1，g1，c0表示出来:</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/%E5%9B%BE%E7%89%8710.png" alt></p>
<p>用电路表示超前进位即为：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/%E5%9B%BE%E7%89%879.png" alt></p>
<blockquote>
<p>有问题请通过旁边的对话窗口联系京介喔。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
        <category>硬件设计</category>
      </categories>
      <tags>
        <tag>logisim</tag>
      </tags>
  </entry>
  <entry>
    <title>4位快速加法器的设计</title>
    <url>/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="4位快速加法器的设计">4位快速加法器的设计</h2>
<h3 id="实验目的：">实验目的：</h3>
<p>掌握快速加法器中先行进位的原理，能利用相关知识设计4位先行进位电路，并利用设计的4位先行进位电路构造4位快速加法器，能分析对应电路的时间延迟。</p>
<h3 id="实验结果：">实验结果：</h3>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8711.png" alt></p>
<h3 id="实验结果分析：">实验结果分析：</h3>
<p>因为我们已经完成了的4位先行进位，（什么？你没什么印象？<a href="https://tosuke.gitee.io/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/">点我马上传送</a>现在我们可以来来实现4位快速加法器，没错，其实4位快速加法器就是根据我们第三个实验的原理而来，实验三所写的4位先行进位现在在4位快速加法器里是重要的中心电路。</p>
<p>第一步先准备一下我们需要的输入输出：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8712.png" alt></p>
<p>然后对应好我们之前的4位先行进位的电路封装：</p>
<img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/图片13.png" style="zoom:80%;">
<img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/图片14.png" style="zoom:80%;">
<p>确认好我们的电路封装后，那我们先来输入我们的P1、P2等Pi输入，因为</p>
<pre><code>                          **Pi=ai⊕bi  Gi=ai*bi**
</code></pre>
<p>所以我们将xi、yi连上异或门连上电路封装的pi输入，将xi、yi连上与门连上电路封装的gi输入，最后不要忘了连上C0的输入：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8715.png" alt></p>
<p>那我们输入就算完成了，现在来看看电路封装的输出部分，我们电路的电路的输出分别是Ci和p*、g*成组先进函数，又因为我们推出的运算公式中：</p>
<p>​														Si=Pi⊕Ci</p>
<p>所以我们需要将封装电路输出的Ci与Pi连上异或门再输出给Si，由于在上一步已经制造了Pi，所以连接如图：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8716.png" alt></p>
<p>最后连接上代表最高位进位的C4与p*、g*成组先进函数，电路图就链接好了。</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8717.png" alt></p>
<blockquote>
<p>有问题请通过旁边的对话窗口联系京介喔。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
        <category>硬件设计</category>
      </categories>
      <tags>
        <tag>logisim</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS入门小识</title>
    <url>/2022/01/18/CSS%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/</url>
    <content><![CDATA[<blockquote>
<p>更新时间：2022.1.27，css内容的学习需要富有艺术性。。缓慢更新中。。</p>
</blockquote>
<h1>2、选择器</h1>
<h2 id="1、标签选择器">1、标签选择器</h2>
<h2 id="2、类选择器">2、类选择器</h2>
<h2 id="3、id选择器">3、id选择器</h2>
<h1>3、层次选择器</h1>
<h2 id="3-1后代选择器">3.1后代选择器</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">body p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-子选择器">3.2 子选择器</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">body&gt;p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3相邻兄弟选择器">3.3相邻兄弟选择器</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.class + p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4通用兄弟选择器-向下">3.4通用兄弟选择器(向下)</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.class + p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>字体样式</h1>
<h1>文本样式</h1>
<h2 id="1、颜色">1、颜色</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">color：</span><br></pre></td></tr></table></figure>
<h2 id="2、文本对齐的方式">2、文本对齐的方式</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text-align:</span><br></pre></td></tr></table></figure>
<h2 id="3、首行缩进">3、首行缩进</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text-indent:2em(em为一个字)</span><br></pre></td></tr></table></figure>
<h2 id="4、行高">4、行高</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">line-height:(设为容器一样的高度)</span><br></pre></td></tr></table></figure>
<h2 id="5、装饰">5、装饰</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">text-decoration:underline/line-through/overline(上划线、中、下)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">img,span&#123;</span><br><span class="line">vertical-align:middle(img/span居中对齐两个标签)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>超链接去下划线。</p>
<h1>超链接伪类</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.hover&#123;</span><br><span class="line"></span><br><span class="line">&#125;鼠标悬浮效果</span><br><span class="line">a.active&#123;</span><br><span class="line">激活，点击未放开</span><br><span class="line">&#125;</span><br><span class="line">cursor: url(&#x27;img/hammer.ico&#x27;),auto;</span><br><span class="line">鼠标效果</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text-shadow: 阴影颜色 偏移 偏移 模糊</span><br></pre></td></tr></table></figure>
<h1>列表样式</h1>
<p>list-style:<br>
none去掉原点<br>
circle空心圆<br>
decimal数字<br>
square正方形</p>
<h1>边框</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">border: 1px solid red</span><br></pre></td></tr></table></figure>
<h1>背景图片</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">background-repeat：repeat-x/repeat-y/no repeat</span><br><span class="line">背景重复方式</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/18/CSS%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/image-20220119111404781.png" alt="image-20220119111404781"></p>
<h1>渐变</h1>
<p><img src="/2022/01/18/CSS%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/image-20220119112059881.png" alt="image-20220119112059881"></p>
<h1>盒子模型</h1>
<h2 id="什么是盒子模型">什么是盒子模型</h2>
<p><img src="/2022/01/18/CSS%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/image-20220119112515546.png" alt="image-20220119112515546"></p>
<h2 id="边框">边框</h2>
<p>margin+border+padding</p>
<h1>浮动</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h1~h6 p div  列表</span><br></pre></td></tr></table></figure>
<p>行内元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">span img strong。。</span><br></pre></td></tr></table></figure>
<h2 id="display">display</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display:block(行内变块内)</span><br><span class="line">display:inline-block(行内变块内)是块且可以内联</span><br><span class="line">inline（行内）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端入门</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML入门</title>
    <url>/2022/01/11/HTML%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1>初识HTML</h1>
<p>HTML全称hyper Text marker language（超文本标记语言），使web时代更具有稳定性，是多个厂商共同认定的互联网标准。</p>
<h2 id="HTML5的优势">HTML5的优势</h2>
<h3 id="世界知名浏览器厂商对HTML-5的支持">世界知名浏览器厂商对HTML 5的支持</h3>
<p>微软<br>
Google<br>
苹果<br>
Opera<br>
Mozilla</p>
<h3 id="市场的需求">市场的需求</h3>
<h3 id="跨平台">跨平台</h3>
<h2 id="W3C–万维网联盟">W3C–万维网联盟</h2>
<p>W3C<br>
World Wide Web Consortium (万维网联盟)<br>
成立于1994年，Web技术领域最权威和具影响力的国际中立性技术标准机<br>
<a href="http://www.w3.org/">http://www.w3.org/</a><br>
<a href="http://www.chinaw3c.org/">http://www.chinaw3c.org/</a><br>
W3C标准包括<br>
1、结构化标准语言(HTML、 XML)<br>
2、表现标准语言(CSS)<br>
3、行为标准(DOM、ECMAScript )</p>
<h1>HTML的结构</h1>
<p>主要由head（头部）、body（主体）构成：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112133518702.png" alt="image-20220112133518702" style="zoom:80%;">
<p>HTML名为标签语言，意味着每个语句都是一个标签，而标签是一个标签组，像</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>与<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样，必须成对出现（单独呈现的标签加‘/’来关闭元素，例如<hr>；），前一个叫<strong>开放标签</strong>后一个叫<strong>闭合标签</strong>，中间就是我们所编写的内容，开放标签里还可以添加一些参数。</p>
<p>在head标签里有一些网页基本信息</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">DOCTYPE声明：文档声明，使用什么规范。</span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>标签<span class="comment">&lt;!-- 网页的名字--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span>&gt;</span>标签<span class="comment">&lt;!-- meta一般用来做seo，即关键字描述--&gt;</span></span><br><span class="line"> 注：<span class="comment">&lt;!-- ***--&gt;</span>为HTML的注释写法，***即为想要写的内容。</span><br></pre></td></tr></table></figure>
<h1>网页基本标签</h1>
<h2 id="标题标签">标题标签</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;一级标题&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;二级标题&lt;/h2&gt;</span><br><span class="line">&lt;h3&gt;三级标题&lt;/h3&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;h1&gt;&lt;h1/&gt;</code>这样的结构就是我们的标题标签，h几就代表第几级标签，对于划分网页的结构用处很大，实际效果如下：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112135742592.png" alt="image-20220112135742592" style="zoom:80%;">
<h2 id="段落标签">段落标签</h2>
<p>假设我们直接在body标签里这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">暴雨如期而至。雨珠打翻了枯叶，搅混了池塘，空中弥漫着泥土的气息，池塘里的鱼群惊慌失措，仿佛因为看不清前途命运而焦躁不安。</span><br><span class="line"></span><br><span class="line">叶瑾介当时也是在这种时候到达新泽的。</span><br><span class="line"></span><br><span class="line">虽说新泽阴雨连绵，很少能够见到阳光，但对于参加过高考的叶瑾介来说，这注定会是他通往梦想的地方。</span><br><span class="line"></span><br><span class="line">“新泽没有夏天”</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>虽然我们编写的时候事注意了空格和换行的，当时在网页中的显示效果却是这样：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112140243572.png" alt="image-20220112140243572"></p>
<p>也就是全部一字排开，并没有识别到我们的换行。这是因为HTML并不能直接识别到我们的回车换行分段，需要使用<code>&lt;p&gt;&lt;/p&gt;</code>来进行分段规范，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    暴雨如期而至。雨珠打翻了枯叶，搅混了池塘，空中弥漫着泥土的气息，池塘里的鱼群惊慌失措，仿佛因为看不清前途命运而焦躁不安。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line">    叶瑾介当时也是在这种时候到达新泽的。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">    虽说新泽阴雨连绵，很少能够见到阳光，但对于参加过高考的叶瑾介来说，这注定会是他通往梦想的地方。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt;“新泽没有夏天”&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>诺，这样分好段的话，就是这个样子了：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112154049136.png" alt="image-20220112154049136"></p>
<h2 id="换行标签">换行标签</h2>
<p>换行与分段的效果很像，换行是在你想要换行的地方加入<code>&lt;br/&gt;</code>,不过换行的行间距要小于分段的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">暴雨如期而至。雨珠打翻了枯叶，搅混了池塘，空中弥漫着泥土的气息，池塘里的鱼群惊慌失措，仿佛因为看不清前途命运而焦躁不安。<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">叶瑾介当时也是在这种时候到达新泽的。<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">虽说新泽阴雨连绵，很少能够见到阳光，但对于参加过高考的叶瑾介来说，这注定会是他通往梦想的地方。<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">“新泽没有夏天”<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>对比效果如下：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112154636593.png" alt="image-20220112154636593"></p>
<h2 id="水平线标签">水平线标签</h2>
<p>水平线标签<code>&lt;hr/&gt;</code>就是分割文章的水平线，效果如下：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112154840335.png" alt="image-20220112154840335"></p>
<h2 id="字体样式标签">字体样式标签</h2>
<p>字体样式标签分为粗体、斜体与特殊符号</p>
<p>粗体与斜体分别用<code>&lt;strong&gt;</code>与<code>&lt;/em&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">粗体：<span class="tag">&lt;<span class="name">strong</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">斜体: <span class="tag">&lt;<span class="name">em</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>具体效果为：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112155953378.png" alt="image-20220112155953378"></p>
<h2 id="注释和特殊符号">注释和特殊符号</h2>
<p>注释已经说过了，特殊字符包括我们的代码、&lt;(这个尖括号)、空格等。</p>
<p>空格：</p>
<p>标签为&amp;nbsp，像我们自己手动打出来的空格HTML是不会认的，需要在需要空格的地方添加这个标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span> 换行</span><br><span class="line"><span class="symbol">&amp;gt;</span>大于符号</span><br><span class="line"><span class="symbol">&amp;lt;</span>小于符号</span><br><span class="line"><span class="symbol">&amp;copy;</span>版权所有</span><br></pre></td></tr></table></figure>
<p>其他标签都是由&amp;+标识符+;组成的。</p>
<h1>图像标签</h1>
<p>常见的图像格式有：jpg、gif、png、bmp（位图）等等。</p>
<p>图像标签为<code>&lt;img/&gt;</code>标签，标签内可以编写格式，它的格式为：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112162359069.png" alt="image-20220112162359069"></p>
<p>src为图片路径，分为绝对路径贺相对路径，绝对路径是文件在具体磁盘分区的位置。</p>
<p>相对分区的格式一般要先使用…/进入上级标签，然后进入相应的文件夹选择相应的图片.</p>
<p>例如：我的图片已经放在了与HTML文件同级的img文件夹下、</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220114230853528.png" alt="image-20220114230853528" style="zoom:50%;">
<p>所以引用的相对地址就是…/img/1.jpg。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../img/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;春川魔姬&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>引用成功！：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220114231106834.png" alt="image-20220114231106834" style="zoom:50%;">
<p>至于img后的alt属性是指在图由于各种原因没加载出来时，所显示的图片名称，例如如果我把img文件夹的图片删除时，加载出来的就是这样的：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220114231508890.png" alt="image-20220114231508890" style="zoom: 67%;">
<p>另外图片标签还有title属性，就是当鼠标悬停时所显示的文字。width以及height属性，用于控制图片大小，但我们一般用CSS来完成这些工作，所以这里就请大家自己去试试吧。</p>
<h1>链接标签</h1>
<p>链接标签就是网页中点击可以跳转的文字或者图片，这种标签在网页中非常常见，所以非常重要。</p>
<p>链接标签的基本格式为：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220114232411036.png" alt="image-20220114232411036"></p>
<p>a就是a标签，href属性表示想要跳转的路径（有很多分类实现不同的功能），target为新建窗口位置（一般来说就是在当前页面打开还是新建窗口），在标签里面的就是我们想要点击的东西，可以是图片也可以是文字。</p>
<h2 id="页面链接">页面链接</h2>
<p>我先建一个新页面（也就是另一个HTML文件）：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220114234016738.png" alt="image-20220114234016738" style="zoom:50%;">
<p>然后在之前的页面中编写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;测试页面.html&quot;</span>&gt;</span>点我跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样在网页中就会有一个跳转标签：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220114234222167.png" alt="image-20220114234222167" style="zoom:80%;">
<p>点击便实现了跳转。</p>
<h2 id="网址链接">网址链接</h2>
<p>href链接路径中也可以直接填写网站链接，像是“<code>https://www.baidu.com</code>”,这样的话点击标签就直接跳转到了百度。</p>
<h2 id="锚链接">锚链接</h2>
<p>我更想叫他飞雷神链接（即基本原理为“设置标签”+“点击跳转到指定标签”）。</p>
<p>设置锚标签的语句是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;top&quot;</span>&gt;</span>顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span>（可不添加文字）</span><br></pre></td></tr></table></figure>
<p>跳转锚标签的语句是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#top&quot;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span>（也就是href属性中写#加上锚标签的名字）</span><br></pre></td></tr></table></figure>
<h2 id="功能性链接">功能性链接</h2>
<p>这种链接用于实现某一功能，比如点击联系我啊这类的，举个例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:1848228664@qq.com&quot;</span>&gt;</span>点击联系京介<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就会自动调用软件，向我发送邮件咯。</p>
<h1>行内元素与块元素</h1>
<p>这个单独成块的元素以及以行为单位的元素，这个在CSS中比较重要，这里稍作了解即可。</p>
<h1>列表标签</h1>
<p>列表标签就是辅助使得文章更加条理清晰的展示，也就是类似于文章分点这种功能。</p>
<h2 id="有序列表（order-list）">有序列表（order list）</h2>
<p>格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;ol&gt;  &lt;/ol&gt;</code>标签指的就是有序标签，在其中用<code>&lt;li&gt;   &lt;/li&gt;</code>进行分条。</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220115141301222.png" alt="image-20220115141301222" style="zoom:67%;">
<h2 id="无序标签（unorder-list）">无序标签（unorder list）</h2>
<p>格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>格式与有序标签相似，只是英文缩写不同而已。</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220115141721006.png" alt="image-20220115141721006" style="zoom:67%;">
<p>无序标签一般用于导航栏，书签之类的。</p>
<h2 id="自定义列表（defintion-list）">自定义列表（defintion list）</h2>
<p>格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>顺序<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>分类<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>python<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>c/c++<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>自定义标签指的是标签有列表分类，即可以用<code>&lt;dt&gt;&lt;/dt&gt;</code>对其下内容归纳一个类名。</p>
<p>一般用于网页底部的公司介绍等。</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220115142520683.png" alt="image-20220115142520683" style="zoom:80%;">
<h1>表格标签</h1>
<p>制作我们在网页中常见的网格</p>
<p>格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1px&quot;</span>&gt;</span> border属性是用于给表格加上裱框。</span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>1-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>1-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>1-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>先用table标签制作表格，在里面用tr标签代表行，在tr标签里用td标签代表每一列并添加内容。</p>
<p>在表格里我们经常会使用合并行或者合并项的操作，在td列标签添加属性colspan并添加合并多少列的参数就可以实现合并列，同理，在td列标签添加属性rowspan即可合并行。</p>
<p>表格也在css中占据重要位置，故HTML表格仅作了解。</p>
<h1>媒体标签</h1>
<p>例如视频元素：</p>
<p>格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>大家应该也都知道了src就是所谓的资源路径了，只需要把视频的地址放进去就行了，由于我没有比较适合拿来公开演示的视频，那么就请大家自己实验了，后面的controls与autoplay属性是实现添加视频控件和自动播放功能。</p>
<p>音频元素也是一样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以添加controls与autoplay等属性。</p>
<h1>页面结构分析</h1>
<table>
<thead>
<tr>
<th>元素名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>header</td>
<td>标题头部区域的内容(用于页面或页面中的-块区域)</td>
</tr>
<tr>
<td>footer</td>
<td>标记脚部区域的内容(用于整个页面或页面的一块区域)</td>
</tr>
<tr>
<td>section</td>
<td>Web页面中的一块独立区域</td>
</tr>
<tr>
<td>article</td>
<td>独立的文章内容</td>
</tr>
<tr>
<td>aside</td>
<td>相关内容或应用(常用于侧边栏)</td>
</tr>
<tr>
<td>nav</td>
<td>导航类辅助内容</td>
</tr>
</tbody>
</table>
<p>用这些标签去给网页内容分类，能够使得网站布局条理清晰。</p>
<h1>iframe内联框架</h1>
<p>即在网站中嵌入一个其他网站，比如在网站里嵌入其他网站的视频，功能等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">name</span>=<span class="string">&quot;框架&quot;</span> <span class="attr">width</span>=<span class="string">&quot;800px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1000px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>iframe内联框架本质上是构建一个内容框架，你可以在里面打开任何一个你想要打开的资源内容，如同上句所写，这时候你的网页将会有一个width=“800px” height=&quot;1000px&quot;的框架，里面打开的是src中的百度。</p>
<p>iframe内联框架也可以不需要src路径，在之间的链接标签中的target属性便可以指向框架的名字，这样的话跳转的内容将会在框架中呈现。</p>
<h1>表单语法</h1>
<p>我们在平时上网时，经常会注册或者登陆一些账号，比如这个界面：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220115223427076.png" alt="image-20220115223427076"></p>
<p>这些与我们提交的信息相关的叫做表单</p>
<p>了解一下表单的基本语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;我的第一个HTML.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        名字<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span><span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>表单标签是form，在form中构建你想要的表单元素，在form下的属性method决定了表单请求的方式，简单来说：get:不安全，但是效率高，而post正好相反。</p>
<p>最后的效果就如同所示，关于具体的表单请求可以在检查中的network中察看。</p>
<h2 id="文本框">文本框</h2>
<p>表单中重要的是input标签，虽然它的字面含义让人很容易想到输入框，但它的功能远不止这么简单，决定它的用途的是input标签里的type属性，举例为：</p>
<ol>
<li>text：普通文本输入框</li>
<li>password：密码输入框（输入的文字不可见）</li>
<li>submit：提交按钮</li>
<li>reset：重置按钮</li>
<li>radio：单选（同一组使用相同name进行约束，checked默认选择）</li>
<li>checkbox：多选框 （同一组有效）</li>
<li>button：按钮</li>
<li>……</li>
</ol>
<p>另外input标签还有其他属性，name用来命名，value设定初始值，maclength设定最大字符数，size设定文本框的长度。</p>
<h2 id="下拉框与文本域">下拉框与文本域</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zhi&quot;</span>&gt;</span>zhong<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zh&quot;</span> <span class="attr">selected</span>&gt;</span>mei<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zi&quot;</span>&gt;</span>ouoi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>select为下拉框标签，里面用option标签写每一个选项，option标签里的属性selected是默认选中的意思。</p>
<p>文本域为一串文本输入框：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;文本域&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>文件域可以上传文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;btn1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面那个上传按钮纯属装饰。</p>
<h2 id="输入验证">输入验证</h2>
<p>有邮件验证：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时输入的如果不是邮箱地址就会这样：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220115232631278.png" alt="image-20220115232631278" style="zoom:67%;">
<p>url验证：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;url&quot;</span><span class="attr">name</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>数字验证：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span><span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">min</span>=<span class="string">&quot;1&quot;</span><span class="attr">step</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="滑块">滑块</h2>
<p>把数字抽象为滑块来展示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>音量：</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span><span class="attr">name</span>=<span class="string">&quot;la&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span><span class="attr">min</span>=<span class="string">&quot;0&quot;</span><span class="attr">step</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220115233049179.png" alt="image-20220115233049179"></p>
<h2 id="搜索框">搜索框</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span><span class="attr">name</span>=<span class="string">&quot;search&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="表单的应用">表单的应用</h2>
<h3 id="只读（readonly）与禁用（disable）">只读（readonly）与禁用（disable）</h3>
<p>让输入框内容无法更改，在input标签中加入readonly属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">名字<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">readonly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>让选项框无法选择，在input标签中加入disable属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zhi&quot;</span> <span class="attr">disabled</span>&gt;</span>zhong<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zh&quot;</span> <span class="attr">selected</span>&gt;</span>mei<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zi&quot;</span>&gt;</span>ouoi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时在下拉框中已无法选择zhong。</p>
<h3 id="隐藏（hidden）">隐藏（hidden）</h3>
<p>使得某些元素隐藏，达到默认值的效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>密码<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span><span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">hidden</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样便会隐藏密码框，使用默认值123546。</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220116003850604.png" alt="image-20220116003850604" style="zoom:67%;">
<h3 id="点击文字进行输入">点击文字进行输入</h3>
<p>这是label标签的作用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;mark&quot;</span>&gt;</span>点我试试看<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将姓名输入框的id改为mark</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">名字<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mark&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样点击label就会进入姓名的输入了。</p>
<h1>表单的初级验证</h1>
<p>placeholder属性：输入框的灰色提示语句。</p>
<p>required属性：操作不能为空。</p>
<p>pattern属性：要求为正则表达式。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端入门</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE的部分要点</title>
    <url>/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/</url>
    <content><![CDATA[<h1>scanner</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">scanner.hasnextline()  <span class="comment">//判断是否还有输入</span></span><br></pre></td></tr></table></figure>
<p>next（）与nextLine（）的区别；</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208161159615.png" alt="image-20211208161159615"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sacanner.nextLine(); <span class="comment">//可以接受空白，以回车为结束。</span></span><br><span class="line">scanner.close();   <span class="comment">//关闭scanner</span></span><br></pre></td></tr></table></figure>
<h1>增强for循环</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x:数组名)&#123;</span><br><span class="line">  system.out.println(x);</span><br><span class="line">  <span class="comment">//遍历数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>给main函数传递参数</h1>
<p>找到包的路径下，在命令行中进行编译，运行。</p>
<h1>可变参数</h1>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208164227825.png" alt="image-20211208164227825"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>... i)</span></span>&#123;</span><br><span class="line"> system.out.println(i[]);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//此时i为可变参数，可输入多个值,i也就可能成为一个数组。</span></span><br></pre></td></tr></table></figure>
<h1>递归</h1>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208164910624.png" alt="image-20211208164910624"></p>
<h1>继承和多态</h1>
<p>静态方法是类的方法，非静态的方法是对象的方法。</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208211748858.png" alt="image-20211208211748858"></p>
<p>我们的person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我开动了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>student类继承person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">student</span> <span class="keyword">extends</span> <span class="title">person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生的事怎么能叫吃呢？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我要学习了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>text类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">texi1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        student  s1=<span class="keyword">new</span> student();</span><br><span class="line">        person s2=<span class="keyword">new</span> student();</span><br><span class="line">s1.eat();</span><br><span class="line">s2.eat();</span><br><span class="line">s1.learn();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208215628894.png" alt="image-20211208215628894"></p>
<h2 id="多态（只针对方法）：">多态（只针对方法）：</h2>
<p>同一方法可以根据发送对象的不同采取多种不同的行为方式，一个对象的实际类型是知道的，但指向对象的引用类型有很多，比如父类的引用指向了子类的对象。</p>
<p>执行方法先看类里面的静态方法（静态方法属于类的，不属于对象），再看对象实际类型对应的方法。</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208214431807.png" alt="image-20211208214431807"></p>
<h1>instanceof与类型转换</h1>
<p>instanceof会判断两个类的继承关系，兄弟关系则会报错。</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209175621741.png" alt="image-20211209175621741"></p>
<p><em>底类转高类不需要强制转换。</em></p>
<p><em>高类转底类需要进行强制转换</em></p>
<p>子类转换为父类可能会丢失一些方法（子类te’you）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object s1 = <span class="keyword">new</span> student(); </span><br><span class="line"><span class="comment">//底类转高类不需要强制转换</span></span><br><span class="line">person s2 = (student) s1;          <span class="comment">//高类转底类需要进行强制转换</span></span><br><span class="line">s2.eat();</span><br><span class="line">student s3 = (student) s2;</span><br><span class="line">s3.eat();</span><br><span class="line">s3.learn();</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209182350137.png" alt="image-20211209182350137"></p>
<blockquote>
<p>这里插入一个我突然看到的，对于对象和实例区别的一个例子：</p>
<p>父母口中的女朋友（对象），怀里搂着的她（实例）。</p>
<p>（精辟无敌）</p>
</blockquote>
<h1>抽象类与接口</h1>
<h2 id="抽象类">抽象类</h2>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209182856546.png" alt="image-20211209182856546"></p>
<blockquote>
<p>抽象类：给予类约束，让其他人帮我们实现。继承了抽象类的类必须重写抽象类所有的抽象方法（除非自己也是抽象类）。我们一般把他们叫做资本家与被压榨的苦力。</p>
</blockquote>
<p>生成一个抽象类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 资本家 </span>&#123;</span><br><span class="line">    <span class="comment">//来帮我写个方法,我只给需求，我就不写了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">ganfan</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以及一个苦力：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 被压榨的苦力 <span class="keyword">extends</span> 资本家 </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ganfan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我为老板冲锋陷阵！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        被压榨的苦力 苦力<span class="number">1</span> = <span class="keyword">new</span> 被压榨的苦力();</span><br><span class="line">        苦力<span class="number">1.</span>ganfan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209184432977.png" alt="image-20211209184432977"></p>
<h2 id="接口">接口</h2>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209184503107.png" alt="image-20211209184503107"></p>
<p>接口全是抽象方法还有静态常量，只有由别人实现。即接口全是要求，资本家自愧不如。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">service</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有对象皆抽象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> speed)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">get</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> age=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个类实现两个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">serviceimpl</span> <span class="keyword">implements</span> <span class="title">service</span>,<span class="title">get</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lost</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用接口实现多继承,接口不能被实例化~接口中没有构造方法。</p>
<h1>内部类</h1>
<h2 id="成员内部类">成员内部类</h2>
<p>定义一个内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外面的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">in</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是里面的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个内部对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        text t1 = <span class="keyword">new</span> text();</span><br><span class="line">        text.in in1 = t1.<span class="function">new <span class="title">in</span><span class="params">()</span></span>;</span><br><span class="line">        t1.out();</span><br><span class="line">        in1.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209190853396.png" alt="image-20211209190853396"></p>
<p><strong>内部类可以操纵外部类的私有属性，这是它的特点（毕竟是亲生的）。</strong></p>
<h2 id="静态内部类">静态内部类</h2>
<p>也就是定义内部类时加上static，需要时注意的是，如果内部类被静态化，那么这个静态内部类也许就不能访问外部类的私有属性了（静态内部类相当于预加载），除非该私有属性也是静态的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外面的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">in</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是里面的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="局部内部类">局部内部类</h2>
<p>在方法里定义的类（类如局部变量）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">in</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是里面的&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外面的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类">匿名内部类</h2>
<p>new出来直接用，没有名字初始类，不用将实例保存到类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        id=<span class="keyword">new</span> Scanner().nextInt();</span><br><span class="line">        <span class="comment">//没有创建scanner类.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>异常机制</h1>
<h2 id="异常">异常</h2>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209193513675.png" alt="image-20211209193513675"></p>
<p><strong>异常也是一种对象</strong></p>
<p>当遇到异常或者是错误时，Java会抛出异常对象，可以对其进行捕获处理（尤其是异常）。</p>
<h2 id="异常处理">异常处理</h2>
<h3 id="五个关键字">五个关键字</h3>
<p>try:尝试捕获异常的监控区。</p>
<p>catch：捕获异常（括号里为想要捕获的异常类型）。</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211210195637949.png" alt="image-20211210195637949"></p>
<p>finally：无论执不执行最后都要走的（一般用于善后工作）。</p>
<p>throw：主动抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException();</span><br></pre></td></tr></table></figure>
<p>throws：方法调用时抛出，</p>
<p>写个报错程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(b/a);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;有问题&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;<span class="comment">//善后处理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ctrl+alt+t可以快速构造代码块框架，包括try|catch语句。</p>
</blockquote>
<p>输出：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211210201559270.png" alt="image-20211210201559270"></p>
<h2 id="自定义异常">自定义异常</h2>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211210202529797.png" alt="image-20211210202529797"></p>
<p>比如数字大于10，我们设计的异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myexception</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> detali;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Myexception</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.detali=a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Myexception&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;detali=&quot;</span> + detali +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="number">11</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Myexception e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> Myexception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Myexception(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;正常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211210203653004.png" alt="image-20211210203653004"></p>
<h1>结束</h1>
<p>JavaSE大体部分就到此结束！</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-Dom</title>
    <url>/2022/01/27/JavaScript-Dom/</url>
    <content><![CDATA[<h1>HTML DOM (文档对象模型)</h1>
<p>当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素。</p>
<p>HTML DOM 树的结构示意图（图片来自菜鸟编程）：</p>
<p><img src="/2022/01/27/JavaScript-Dom/image-20220127233523498.png" alt="image-20220127233523498"></p>
<p>通过js对dom的掌控，使得这些对象模型可以被动态的展示出来（类似于商品列表，一刷新一换）。</p>
<h1>查找 HTML 元素</h1>
<p>通过 JavaScript操作 HTML 元素需要先通过某种方式进行查找从而进行选择。</p>
<p>有三种方法来做这件事：</p>
<ul>
<li>通过 id 找到 HTML 元素</li>
<li>通过标签名找到 HTML 元素</li>
<li>通过类名找到 HTML 元素</li>
</ul>
<h2 id="通过-id-找到-HTML-元素">通过 id 找到 HTML 元素</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="built_in">document</span>.getElementById(<span class="string">&quot;id名&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="通过标签名找到-HTML-元素">通过标签名找到 HTML 元素</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="built_in">document</span>.getElementById(<span class="string">&quot;main&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> y=x.getElementsByTagName(<span class="string">&quot;p&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>本例查找 id=“main” 的元素，然后查找 id=“main” 元素中的所有 <code>&lt;p&gt;</code> 元素</p>
<h2 id="通过类名找到-HTML-元素">通过类名找到 HTML 元素</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;intro&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1>改变 HTML 输出流</h1>
<p>document.write() 可用于直接向 HTML 输出流写内容。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.write(<span class="built_in">Date</span>());<span class="comment">//该语句会直接向HTML输出流xie</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：绝对不要在文档(DOM)加载完成之后使用 document.write()。这会覆盖该文档。</strong></p>
</blockquote>
<h1>改变 HTML 内容</h1>
<p>document.getElementById(<em>id</em>).innerHTML=<em>新的改变</em></p>
<p>使用这个函数可以使得HTML元素的内容发生改变</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.getElementById(<span class="string">&quot;p1&quot;</span>).innerHTML=<span class="string">&quot;新文本!&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>这里改变了<code>&lt;p1&gt;</code>的内容。</p>
<h1>改变 HTML 属性</h1>
<p>document.getElementById(<em>id</em>).<em>attribute=新属性值</em></p>
<p>使用此函数改变HTML标签的属性。</p>
<p>例如改变图片的路径：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;smiley.gif&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.getElementById(<span class="string">&quot;image&quot;</span>).src=<span class="string">&quot;landscape.jpg&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1>改变 HTML 样式</h1>
<p>document.getElementById(<em>id</em>).style.<em>property</em>=<em>新样式</em></p>
<p>使用此函数改变HTML标签的样式。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.getElementById(<span class="string">&quot;p2&quot;</span>).style.color=<span class="string">&quot;blue&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.getElementById(<span class="string">&quot;p2&quot;</span>).style.fontFamily=<span class="string">&quot;Arial&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.getElementById(<span class="string">&quot;p2&quot;</span>).style.fontSize=<span class="string">&quot;larger&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>666<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1>使用事件</h1>
<p>HTML DOM 允许我们通过触发事件来执行代码，使 JavaScript 有能力对 HTML 事件做出反应。</p>
<p>比如以下事件：</p>
<ul>
<li>元素被点击。</li>
<li>页面加载完成。</li>
<li>输入框被修改。</li>
<li>当网页已加载时</li>
<li>当图像已加载时</li>
<li>当鼠标移动到元素上时</li>
<li>当输入字段被改变时</li>
<li>当提交 HTML 表单时</li>
<li>当用户触发按键时</li>
<li>……</li>
</ul>
<p>例如点击事件（onclick）调用一个js函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="function"><span class="keyword">function</span> <span class="title">changetext</span>(<span class="params">id</span>)</span></span></span></span><br><span class="line"><span class="function"><span class="javascript"><span class="xml"></span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    id.innerHTML=<span class="string">&quot;Ooops!&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onclick</span>=<span class="string">&quot;changetext(this)&quot;</span>&gt;</span>点击我!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>changetext将会在标题被点击时运行。</p>
<p><strong>onload 和 onunload 事件</strong></p>
<p>onload 和 onunload 事件会在用户进入或离开页面时被触发。</p>
<p>onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。</p>
<p>onload 和 onunload 事件可用于处理 cookie。</p>
<p><strong>onchange 事件</strong></p>
<p>onchange 事件常结合对输入字段的验证来使用，在字段被改变时调用。</p>
<p><strong>onmouseover 和 onmouseout 事件</strong></p>
<p>onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。</p>
<p><strong>onmousedown、onmouseup 以及 onclick 事件</strong></p>
<p>onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。首先当点击鼠标按钮时，会触发 onmousedown 事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件。</p>
<h1>EventListener（事件监听）</h1>
<p>用于捕获事件，当某事件触发后执行某函数。</p>
<p><em>element</em>.addEventListener(<em>event, function, useCapture</em>);</p>
<p>第一个参数是事件的类型 (如 “click” 或 “mousedown”).</p>
<p>第二个参数是事件触发后调用的函数。</p>
<p>第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。</p>
<blockquote>
<p>注意:不要使用 “on” 前缀。 例如，使用 “click” ,而不是使用 “onclick”。</p>
</blockquote>
<p>addEventListener() 方法允许向同一个元素添加多个事件，且不会覆盖已存在的事件</p>
<h2 id="关于传递参数">关于传递参数</h2>
<p>当传递参数值时，使用&quot;匿名函数&quot;调用带参数的函数，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; myFunction(p1, p2); &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="事件冒泡与事件捕获">事件冒泡与事件捕获</h2>
<p>事件传递有两种方式：冒泡与捕获。</p>
<p>事件传递定义了元素事件触发的顺序。 如果你将 </p><p> 元素插入到 <div> 元素中，用户点击 <p> 元素, 哪个元素的 “click” 事件先被触发呢？</p>
<p>在 <em>冒泡</em> 中，内部元素的事件会先被触发，然后再触发外部元素，即： </p><p> 元素的点击事件先触发，然后会触发 <div> 元素的点击事件。</div></p>
<p>在 <em>捕获</em> 中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即： <div> 元素的点击事件先触发 ，然后再触发 <p> 元素的点击事件。</p>
<p>addEventListener() 方法可以指定 “useCapture” 参数来设置传递类型：</p>
<h2 id="removeEventListener-方法">removeEventListener() 方法</h2>
<p>removeEventListener() 方法移除由 addEventListener() 方法添加的事件句柄。</p>
<h1>DOM 元素 (节点)</h1>
<p><strong>要创建新的 HTML 元素 (节点)需要先创建一个元素，然后在已存在的元素中添加它。</strong></p>
<p>以下代码是用于创建 </p><p> 元素:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> para = <span class="built_in">document</span>.createElement(<span class="string">&quot;p&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>为 </p><p> 元素创建一个新的文本节点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;这是一个新的段落。&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>将文本节点添加到 </p><p> 元素中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">para.appendChild(node);<span class="comment">//insertBefore() 方法可以将新元素添加到开始位置。</span></span><br></pre></td></tr></table></figure>
<p>最后，在一个已存在的元素中添加 p 元素。</p>
<p>查找已存在的元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>添加到已存在的元素中:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.appendChild(para);<span class="comment">////insertBefore() 方法可以将新元素添加到开始位置。</span></span><br></pre></td></tr></table></figure>
<h2 id="移除已存在的元素">移除已存在的元素</h2>
<p>在父元素中使用node.remove() 方法，parent.removeChild(child);。</p>
<h2 id="替换-HTML-元素">替换 HTML 元素</h2>
<p>我们可以使用 replaceChild() 方法来替换 HTML DOM 中的元素。</p>
<h1>HTMLCollection 对象</h1>
<p>getElementsByTagName() 方法返回 <code>HTMLCollection</code> 对象。</p>
<p>HTMLCollection 对象类似包含 HTML 元素的一个数组。</p>
<p>例如访问所以p元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">y = x[<span class="number">1</span>];<span class="comment">//用类似与数组的方式访问</span></span><br></pre></td></tr></table></figure>
<p>HTMLCollection 对象的 length 属性定义了集合中元素的数量。</p>
<h1>DOM 节点列表</h1>
<p><strong>NodeList</strong> 对象是一个从文档中获取的节点列表 (集合) 。</p>
<p>NodeList 对象类似HTMLCollection 对象。</p>
<p>一些旧版本浏览器中的方法（如：<strong>getElementsByClassName()</strong>）返回的是 NodeList 对象，而不是 HTMLCollection 对象。</p>
<p>所有浏览器的 <strong>childNodes</strong> 属性返回的是 NodeList 对象。</p>
<p>大部分浏览器的 <strong>querySelectorAll()</strong> 返回 NodeList 对象。</p>
<p>同样是访问所有p元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myNodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">y = myNodeList[<span class="number">1</span>];<span class="comment">//同样通过下标访问</span></span><br></pre></td></tr></table></figure>
<h2 id="NodeList-对象-length-属性">NodeList 对象 length 属性</h2>
<p>NodeList 对象 length 属性定义了节点列表中元素的数量。</p>
<h2 id="HTMLCollection-与-NodeList-的区别">HTMLCollection 与 NodeList 的区别</h2>
<p>HTMLCollection是 HTML 元素的集合。</p>
<p>NodeList 是一个文档节点的集合。</p>
<p>NodeList 与 HTMLCollection 有很多类似的地方。</p>
<p>NodeList 与 HTMLCollection 都与数组对象有点类似，可以使用索引 (0, 1, 2, 3, 4, …) 来获取元素。</p>
<p>NodeList 与 HTMLCollection 都有 length 属性。</p>
<p>HTMLCollection 元素可以通过 name，id 或索引来获取。</p>
<p>NodeList 只能通过索引来获取。</p>
<p>只有 NodeList 对象有包含属性节点和文本节点。</p>
<blockquote>
<p><strong>节点列表不是一个数组！</strong></p>
<p>节点列表看起来可能是一个数组，但其实不是。</p>
<p>你可以像数组一样，使用索引来获取元素。</p>
<p>节点列表无法使用数组的方法： valueOf(), pop(), push(), 或 join() 。</p>
</blockquote>
</div></p></div></p>]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端入门</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript入门小识</title>
    <url>/2022/01/20/JavaScript%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/</url>
    <content><![CDATA[<h1>什么是JavaScript？</h1>
<p>JavaScript 是互联网上最流行的脚本语言，这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。</p>
<h1>引入JavaScript</h1>
<h3 id="1-内部引入">1.内部引入</h3>
<h3 id="script-标签"><code>&lt;script&gt;</code> 标签</h3>
<p>如需在 HTML 页面中插入 JavaScript，请使用 <code>&lt;script&gt;</code> 标签。</p>
<p><code>&lt;script&gt;</code>和 <code>&lt;/script&gt;</code>会告诉 JavaScript 在何处开始和结束，之间的代码行包含了 JavaScript:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">alert(<span class="string">&quot;我的第一个 JavaScript&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-外部引入">2.外部引入</h3>
<p>也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。</p>
<p>外部 JavaScript 文件的文件扩展名是 .js。</p>
<p>如需使用外部文件，请在  <code>&lt;script&gt;</code>标签的 “src” 属性中设置该 .js 文件，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;myScript.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="基本语法入门">基本语法入门</h2>
<h2 id="数据类型">数据类型</h2>
<p><strong>变量名不能用数字开头</strong></p>
<p>number：数字（不区分大小写）</p>
<p>字符串：‘abc’、“ann”</p>
<p>布尔值：true，false</p>
<p>逻辑运算:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&amp;&amp;  于</span><br><span class="line">|| 或</span><br><span class="line">！ 非</span><br></pre></td></tr></table></figure>
<p>比较运算符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">=</span><br><span class="line">== 等于（类型不算）</span><br><span class="line">=== 绝对等于（类型）</span><br></pre></td></tr></table></figure>
<p>在js中一般使用“===”</p>
<p><strong>注意</strong>：NaN（not a number）与所有值都不相等（包括自己）只能使用isNaN(NaN)来判断是否未NaN</p>
<p>null和undefind：未定义</p>
<p>数组：什么都装，不需要类型相同。尽量使用中括号表示数组</p>
<p>类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person&#123;</span><br><span class="line">name：“十大”,</span><br><span class="line"><span class="attr">age</span>: <span class="string">&#x27;10&#x27;</span></span><br><span class="line"><span class="attr">tag</span>: [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象成员用逗号隔开，最后一位不需要逗号。</p>
<p>用“.”来访问对象成员</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.name</span><br><span class="line">&gt;<span class="string">&quot;十大&quot;</span></span><br><span class="line">person.age</span><br><span class="line">&gt;<span class="number">10</span></span><br></pre></td></tr></table></figure>
<h2 id="严格检查模式">严格检查模式</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br></pre></td></tr></table></figure>
<h1>数据类型</h1>
<p>在 JavaScript 中有 6 种不同的数据类型：</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>object</li>
<li>function</li>
<li>symbol</li>
</ul>
<p>3 种对象类型：</p>
<ul>
<li>Object</li>
<li>Date</li>
<li>Array</li>
</ul>
<p>2 个不包含任何值的数据类型：</p>
<ul>
<li>null</li>
<li>undefined</li>
</ul>
<p><strong>你可以使用 typeof 操作符来查看 JavaScript 变量的数据类型。</strong></p>
<h2 id="constructor-属性">constructor 属性</h2>
<p><strong>constructor</strong> 属性返回所有 JavaScript 变量的构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;John&quot;</span>.constructor                 <span class="comment">// 返回函数 String()  &#123; [native code] &#125;</span></span><br><span class="line">(<span class="number">3.14</span>).constructor                 <span class="comment">// 返回函数 Number()  &#123; [native code] &#125;</span></span><br><span class="line"><span class="literal">false</span>.constructor                  <span class="comment">// 返回函数 Boolean() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="1、字符串">1、字符串</h2>
<p>1、正常的字符串使用单引号或者双引号包围</p>
<p>2、注意转义字符\</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">\<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<p>3、多行字符串编写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">`hello</span></span><br><span class="line"><span class="string">sad</span></span><br><span class="line"><span class="string">happy</span></span><br><span class="line"><span class="string">das`</span></span><br></pre></td></tr></table></figure>
<p>4、模板字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name=<span class="string">&quot;Tosuke&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> msg =<span class="string">`你好呀,<span class="subst">$&#123;name&#125;</span>;</span></span><br></pre></td></tr></table></figure>
<p>5、字符串的长度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.length</span><br></pre></td></tr></table></figure>
<p>6、字符串的可变性，不可变性</p>
<p><img src="/2022/01/20/JavaScript%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/image-20220120144032536.png" alt="image-20220120144032536"></p>
<p>7、大小写转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意，此为方法</span></span><br><span class="line">student.toUpperCase()</span><br><span class="line">student.toLowerCase()</span><br></pre></td></tr></table></figure>
<p>8、student.indexOf(‘t’)</p>
<p>9、substring</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">student.substring(<span class="number">1</span>)<span class="comment">//从第一个字符串截取到最后一个</span></span><br><span class="line">student.substring(<span class="number">1</span>,<span class="number">3</span>)<span class="comment">//[1,3)</span></span><br></pre></td></tr></table></figure>
<h2 id="2、数组">2、数组</h2>
<p>array可以包含任意类型的数据类型</p>
<p>1、长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr.length</span><br></pre></td></tr></table></figure>
<p>可以对长度数据进行修改，数组相应大小就会改变。（小心数据丢失！）</p>
<p>2、indexOf，通过元素获得下标索引</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.indexof(<span class="number">2</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>3、slice()</p>
<h2 id="JavaScript-类型转换">JavaScript 类型转换</h2>
<p>JavaScript 变量可以转换为新变量或其他数据类型：</p>
<ul>
<li>通过使用 JavaScript 函数</li>
<li>通过 JavaScript 自身自动转换</li>
</ul>
<h3 id="将数字转换为字符串">将数字转换为字符串</h3>
<p>全局方法 <strong>String()</strong> 可以将数字转换为字符串。</p>
<p>该方法可用于任何类型的数字，字母，变量，表达式（Number 方法 <strong>toString()</strong> 也是有同样的效果。）：</p>
<h1>JavaScript 正则表达式</h1>
<p>正则表达式是由一个字符序列形成的搜索模式。</p>
<p>当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。</p>
<p>正则表达式可以是一个简单的字符，或一个更复杂的模式。</p>
<p>正则表达式可用于所有文本搜索和文本替换的操作。</p>
<p><img src="/2022/01/20/JavaScript%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/image-20220127162021505.png" alt="image-20220127162021505"></p>
<h2 id="使用-test">使用 test()</h2>
<p>test() 方法是一个正则表达式方法。</p>
<p>test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。</p>
<table>
<thead>
<tr>
<th>[abc]</th>
<th>查找方括号之间的任何字符。</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0-9]</td>
<td>查找任何从 0 至 9 的数字。</td>
</tr>
<tr>
<td>(x|y)</td>
<td>查找任何以 | 分隔的选项。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">元字符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\d</td>
<td style="text-align:center">查找数字。</td>
</tr>
<tr>
<td style="text-align:left">\s</td>
<td style="text-align:center">查找空白字符。</td>
</tr>
<tr>
<td style="text-align:left">\b</td>
<td style="text-align:center">匹配单词边界。</td>
</tr>
<tr>
<td style="text-align:left">\uxxxx</td>
<td style="text-align:center">查找以十六进制数 xxxx 规定的 Unicode 字符。</td>
</tr>
</tbody>
</table>
<h2 id="使用-exec">使用 exec()</h2>
<p>exec() 方法是一个正则表达式方法。</p>
<p>exec() 方法用于检索字符串中的正则表达式的匹配。</p>
<p>该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p>
<h1>JavaScript 错误 - throw、try 和 catch</h1>
<hr>
<p><strong>try</strong> 语句测试代码块的错误。</p>
<p><strong>catch</strong> 语句处理错误。</p>
<p><strong>throw</strong> 语句创建自定义错误。</p>
<p><strong>finally</strong> 语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行。</p>
<p>该部分与Java依然极其相似：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...    <span class="comment">//异常的抛出</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    ...    <span class="comment">//异常的捕获与处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...    <span class="comment">//结束处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>JavaScript 调试</h1>
<p>我们浏览器启用调试工具一般是按下 F12 键，并在调试菜单中选择 “Console” 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="设置断点">设置断点</h2>
<p>在调试窗口中，你可以设置 JavaScript 代码的断点。</p>
<p>在每个断点上，都会停止执行 JavaScript 代码，以便于我们检查 JavaScript 变量的值。</p>
<p>在检查完毕后，可以重新执行代码（如播放按钮）。</p>
<h1>JavaScript 声明提升</h1>
<p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。</p>
<p>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p>
<p>意思是尽管设置变量时没有在这行代码之前声明它，而是在后面才声明时也是可以使用的（声明自动提升），不过大家还是得遵守先声明再使用的原则。</p>
<h1>JavaScript 严格模式(use strict)</h1>
<p>使用 “use strict” 指令<br>
“use strict” 指令在 JavaScript 1.8.5 (ECMAScript5) 中新增。</p>
<p>它不是一条语句，但是是一个字面量表达式，在 JavaScript 旧版本中会被忽略。</p>
<p>“use strict” 的目的是指定代码在严格条件下执行。</p>
<p>严格模式下你不能使用未声明的变量。</p>
<h2 id="表单验证">表单验证</h2>
<p>HTML 表单验证可以通过 JavaScript 来完成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TableTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x=<span class="built_in">document</span>.forms[<span class="string">&quot;myform&quot;</span>][<span class="string">&quot;fname&quot;</span>].value;</span><br><span class="line">  <span class="keyword">if</span>(x==<span class="literal">null</span>||x==<span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      alert(<span class="string">&quot;需要输入名字。&quot;</span>)；</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form name=<span class="string">&quot;myForm&quot;</span> action=<span class="string">&quot;demo_form.php&quot;</span> onsubmit=<span class="string">&quot;return validateForm()&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">名字: <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fname&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1>JavaScript this 关键字</h1>
<p>面向对象语言中 this 表示当前对象的一个引用。</p>
<p>但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。</p>
<ul>
<li>在方法中，this 表示该方法所属的对象。</li>
<li>如果单独使用，this 表示全局对象。</li>
<li>在函数中，this 表示全局对象。</li>
<li>在函数中，在严格模式下，this 是未定义的(undefined)。</li>
<li>在事件中，this 表示接收事件的元素。</li>
<li>类似 call() 和 apply() 方法可以将 this 引用到任何对象</li>
</ul>
<h1>JavaScript let 和 const</h1>
<h3 id="ECMAScript-2015-ECMAScript-6">ECMAScript 2015(ECMAScript 6)</h3>
<p>ES2015(ES6) 新增加了两个重要的 JavaScript 关键字: <strong>let</strong> 和 <strong>const</strong>。</p>
<p>let 声明的变量只在 let 命令所在的代码块内有效。</p>
<p>const 声明一个只读的常量，一旦声明，常量的值就不能改变。</p>
<p>在 ES6 之前，JavaScript 只有两种作用域： <strong>全局变量</strong> 与 <strong>函数内的局部变量</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">let 定义的代码只在这里生效。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>JavaScript JSON</h1>
<ul>
<li>JSON 英文全称 <strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation</li>
<li>JSON 是一种轻量级的数据交换格式</li>
<li>JSON是独立的语言</li>
<li>JSON 易于理解</li>
</ul>
<h2 id="JSON-语法规则">JSON 语法规则</h2>
<ul>
<li>数据为 键/值 对。</li>
<li>数据由逗号分隔。</li>
<li>大括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<h2 id="JSON-数据-一个名称对应一个值">JSON 数据 - 一个名称对应一个值</h2>
<p>JSON 数据格式为 键/值 对，就像 JavaScript 对象属性。</p>
<p>键/值对包括字段名称（在双引号中），后面一个冒号，然后是值：</p>
<p>“name”:“Runoob”</p>
<hr>
<h2 id="JSON-对象">JSON 对象</h2>
<p>JSON 对象保存在大括号内。</p>
<p>就像在 JavaScript 中, 对象可以保存多个 键/值 对：</p>
<p>{“name”:“Runoob”, “url”:“<a href="http://www.runoob.com">www.runoob.com</a>”}</p>
<hr>
<h2 id="JSON-数组">JSON 数组</h2>
<p>JSON 数组保存在中括号内。</p>
<p>就像在 JavaScript 中, 数组可以包含对象：</p>
<p>“sites”:[    {“name”:“Runoob”, “url”:“<a href="http://www.runoob.com">www.runoob.com</a>”},     {“name”:“Google”, “url”:“<a href="http://www.google.com">www.google.com</a>”},    {“name”:“Taobao”, “url”:“<a href="http://www.taobao.com">www.taobao.com</a>”} ]JSON 数据 - 一个名称对应一个值</p>
<p>JSON 数据格式为 键/值 对，就像 JavaScript 对象属性。</p>
<p>键/值对包括字段名称（在双引号中），后面一个冒号，然后是值：</p>
<p>“name”:“Runoob”</p>
<p>JSON 语法规则<br>
数据为 键/值 对。<br>
数据由逗号分隔。<br>
大括号保存对象<br>
方括号保存数组</p>
<hr>
<h2 id="JSON-对象-2">JSON 对象</h2>
<p>JSON 对象保存在大括号内。</p>
<p>就像在 JavaScript 中, 对象可以保存多个 键/值 对：</p>
<p>{“name”:“Runoob”, “url”:“<a href="http://www.runoob.com">www.runoob.com</a>”}</p>
<hr>
<h2 id="重要函数">重要函数</h2>
<p>用于转换json字符串与js对象</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/js/javascript-json-parse.html">JSON.parse()</a></td>
<td style="text-align:left">用于将一个 JSON 字符串转换为 JavaScript 对象。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/js/javascript-json-stringify.html">JSON.stringify()</a></td>
<td style="text-align:left">用于将 JavaScript 值转换为 JSON 字符串。</td>
</tr>
</tbody>
</table>
<h1>异步编程</h1>
<p>在前端编程中（甚至后端有时也是这样），我们在处理一些简短、快速的操作时，例如计算 1 + 1 的结果，往往在主线程中就可以完成。主线程作为一个线程，不能够同时接受多方面的请求。所以，当一个事件没有结束时，界面将无法处理其他请求。</p>
<p>现在有一个按钮，如果我们设置它的 onclick 事件为一个死循环，那么当这个按钮按下，整个网页将失去响应。</p>
<p>为了避免这种情况的发生，我们常常用子线程来完成一些可能消耗时间足够长以至于被用户察觉的事情，比如读取一个大文件或者发出一个网络请求。因为子线程独立于主线程，所以即使出现阻塞也不会影响主线程的运行。但是子线程有一个局限：一旦发射了以后就会与主线程失去同步，我们无法确定它的结束，如果结束之后需要处理一些事情，比如处理来自服务器的信息，我们是无法将它合并到主线程中去的。</p>
<p>为了解决这个问题，JavaScript 中的异步操作函数往往通过回调函数来实现异步任务的结果处理。</p>
<blockquote>
<p>值得一提的是，js里的同步与异步的概念是与我们现实生活中的同异步恰恰相反的。</p>
</blockquote>
<h2 id="回调函数">回调函数</h2>
<p>回调函数就是一个函数，它是在我们启动一个异步任务的时候就告诉它：等你完成了这个任务之后要干什么。这样一来主线程几乎不用关心异步任务的状态了，他自己会善始善终。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML=<span class="string">&quot;RUNOOB!&quot;</span>;</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>这是一个延时函数，将会在3000毫秒后执行。</p>
<h2 id="Promise">Promise</h2>
<p>Promise 是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;First&quot;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, <span class="number">4000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Third&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码实现了分三次输出字符串，第一次间隔 1 秒，第二次间隔 4 秒，第三次间隔 3 秒，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Run&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//这段程序会直接输出Run</span></span><br></pre></td></tr></table></figure>
<p>Promise 构造函数只有一个函数作为参数，叫做起始函数，起始函数有两个参数resolve 和 reject，其中调用 resolve 代表一切正常，reject 是出现异常时所调用的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) reject(<span class="string">&quot;Divide zero&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> resolve(a / b);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a / b = &quot;</span> + value);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;).finally(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;End&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段程序执行结果是:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a / b = <span class="number">0</span></span><br><span class="line">End</span><br></pre></td></tr></table></figure>
<hr>
<p>resolve() 中可以放置一个参数用于向下一个 then 传递一个值，then 中的函数也可以返回一个值传递给 then。但是，如果 then 中返回的是一个 Promise 对象，那么下一个 then 将相当于对这个返回的 Promise 进行操作，这一点从刚才的计时器的例子中可以看出来。</p>
<p>reject() 参数中一般会传递一个异常给之后的 catch 函数用于处理异常。</p>
<p>但是请注意以下两点：</p>
<ul>
<li>resolve 和 reject 的作用域只有起始函数，不包括 then 以及其他序列；</li>
<li>resolve 和 reject 并不能够使起始函数停止运行，别忘了 return。</li>
</ul>
<h3 id="Promise-函数">Promise 函数</h3>
<p>上述的 “计时器” 程序看上去比函数瀑布还要长，所以我们可以将它的核心部分写成一个 Promise 函数：</p>
<p>封装promise函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">delay, message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(message);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就可以放心大胆的实现程序功能了：</p>
<p>使用函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">print(<span class="number">1000</span>, <span class="string">&quot;First&quot;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> print(<span class="number">4000</span>, <span class="string">&quot;Second&quot;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    print(<span class="number">3000</span>, <span class="string">&quot;Third&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><em>这种返回值为一个 Promise 对象的函数称作 Promise 函数，它常常用于开发基于异步操作的库。</em></p>
<blockquote>
<p>下面是一些常见问题及解答的收录：</p>
<p><strong>Q: then、catch 和 finally 序列能否顺序颠倒？</strong></p>
<p>A: 可以，效果完全一样。但不建议这样做，最好按 then-catch-finally 的顺序编写程序。</p>
<p><strong>Q: 除了 then 块以外，其它两种块能否多次使用？</strong></p>
<p>A: 可以，finally 与 then 一样会按顺序执行，但是 catch 块只会执行第一个，除非 catch 块里有异常。所以最好只安排一个 catch 和 finally 块。</p>
<p><strong>Q: then 块如何中断？</strong></p>
<p>A: then 块默认会向下顺序执行，return 是不能中断的，可以通过 throw 来跳转至 catch 实现中断。</p>
<p><strong>Q: 什么时候适合用 Promise 而不是传统回调函数？</strong></p>
<p>A: 当需要多次顺序执行异步操作的时候，例如，如果想通过异步方法先后检测用户名和密码，需要先异步检测用户名，然后再异步检测密码的情况下就很适合 Promise。</p>
<p><strong>Q: Promise 是一种将异步转换为同步的方法吗？</strong></p>
<p>A: 完全不是。Promise 只不过是一种更良好的编程风格。</p>
<p><strong>Q: 什么时候我们需要再写一个 then 而不是在当前的 then 接着编程？</strong></p>
<p>A: 当你又需要调用一个异步任务的时候。</p>
</blockquote>
<h2 id="异步函数（async-function）">异步函数（async function）</h2>
<p>在之前的promise函数中，我们可以把接下来调用promise函数的过程变得更加简洁：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> print(<span class="number">1000</span>, <span class="string">&quot;First&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> print(<span class="number">4000</span>, <span class="string">&quot;Second&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> print(<span class="number">3000</span>, <span class="string">&quot;Third&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">asyncFunc();</span><br></pre></td></tr></table></figure>
<p>异步函数 async function 中可以使用 await 指令，await 指令后必须跟着一个 Promise，异步函数会在这个 Promise 运行中暂停，直到其运行结束再继续运行。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/2021/12/21/Java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1>泛型的概念</h1>
<h1>泛型的好处</h1>
<h2 id="类型安全">类型安全</h2>
<h2 id="消除强制转换类型">消除强制转换类型</h2>
<h1>泛型的作用</h1>
<h2 id="编译期间检查">编译期间检查</h2>
<h1>泛型类</h1>
<p><img src="/2021/12/21/Java%E6%B3%9B%E5%9E%8B/image-20211221125349265.png" alt="image-20211221125349265"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2021/10/26/hello-world/</url>
    <content><![CDATA[<p>你好，我的同志，这是我的第一篇博客，显而易见的是我正在学习中，所以页面会非常粗糙，还请见谅！</p>
<h2 id="起源">起源</h2>
<h3 id="一开始">一开始</h3>
<p>建立博客的缘由是因为几位朋友都有了属于他们自己的博客，这让我很感兴趣。</p>
<p>第一步</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="后来嘛">后来嘛</h3>
<p>上网找教程，最后选择了hexo+gitee（码云）的方式部署博客，期间遇到了很多问题，后来大部分都慢慢解决了，但还是有一些现在还没<br>
解决的问题。<br>
比如说：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git@gitee.com: Permission denied (publickey)</span><br></pre></td></tr></table></figure>
<p>配置的ssh明明完美无缺，可通讯还是不行，我猜测是因为我windows用户名是中文的原因，还得再试试。</p>
<h3 id="而现在">而现在</h3>
<p>我之前有一个团队网站，为了测试我把它放在这里。</p>
<p>More info: <a href="http://tocode.e.cn.vc/2">Tocode团队</a></p>
<h3 id="在未来">在未来</h3>
<p>我会继续努力的，总之感谢大家了！</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>感想</category>
      </categories>
      <tags>
        <tag>关于</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的I/O流</title>
    <url>/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/</url>
    <content><![CDATA[<h1>I/O框架</h1>
<h2 id="流的概念">流的概念</h2>
<p>流是内存与存储设备之间传输数据的通道，如果你学习过计算机组成原理或者是操作系统的话，那么你一定知道运行的程序是在内存中的，但程序需要的数据和程序想要写出的数据都保存在我们储存设备（比如磁盘）里的，所以这时候就需要一个进去和一个出来的通道，而这便是流的概念了。</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211215201600633.png" alt="image-20211215201600633"></p>
<h2 id="流的分类">流的分类</h2>
<p><strong>1、按方向分（主要）：</strong></p>
<p>· 输入流：存储设备-&gt;内存（input）</p>
<p>· 输出流：内存-&gt;存储设备（output）</p>
<p><strong>2、按单位分：</strong></p>
<p>· 字节流：以字节为单位，可以读写所有数据。</p>
<p>· 字符流：以字符为单位，只能读写文本数据。</p>
<p><strong>3、按功能分：</strong></p>
<p>· 节点流：具有实际传输数据的读写功能。</p>
<p>· 过滤流：在节点流的基础上增强功能。</p>
<h1>字节流</h1>
<p>字节流的父类（抽象类），我们来看看这些抽象类的一些方法：</p>
<p><strong>inputStream（输入字节流）</strong>：</p>
<p>1、public int read(){}</p>
<p>2、public int read(byte[] b){}</p>
<p>3、public int read(byte[] b,int off,int len){}</p>
<p><strong>OutputStream(输出字节流)：</strong></p>
<p>1、public void write(int n){}</p>
<p>2、public void write(byte[] b){}</p>
<p>3、public void write(byte[] b,int off,int len){}</p>
<h2 id="文件字节流">文件字节流</h2>
<p>文件字节流用于java程序与我们的电脑文件的数据交换。</p>
<p><strong>FileinputStream：</strong></p>
<p>1、public int read(read[] b)//从流中读取多个字节，将读到的内容存入b数组，返回实际读到的字节数；如果达到文件的尾部，则返回-1。</p>
<p><strong>FileOutputStream:</strong></p>
<p>1、public void write(byte[] b)//一次写多个字节，将b数组中所有的字节写入输出流。</p>
<h3 id="文件字节输入流">文件字节输入流</h3>
<p>下面我们来看看简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">       <span class="comment">//创建输入流并指定路径</span></span><br><span class="line">        FileInputStream fs = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;g:\\IOtest.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//尝试读取</span></span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">while</span> ((data=fs.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(data);</span><br><span class="line">        &#125;</span><br><span class="line">        fs.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创造文件g:\IOtest.txt以及输入内容：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219134520046.png" alt="image-20211219134520046"></p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219134601184.png" alt="image-20211219134601184"></p>
<p>输出：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219134629750.png" alt="image-20211219134629750"></p>
<p>这里需要注意的是：</p>
<p>1、我们使用的构造方法中的参数name代表的是我们电脑中文件的路径，所以得保证该路径有这个文件，不然就会报错。</p>
<p>2、采用的读取方法是read（），即每次只读取单个字节，所以我们需要循环输出语句while，并且由于结束条件是——“如果达到文件的尾部，则返回-1。”所以我们的data类型为int类型，这也导致了输出为所对应的ascii码值，但要是想解决也很好办，只需要输出时强制转换类型就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println((<span class="keyword">char</span>)data);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219134849648.png" alt="image-20211219134849648"></p>
<p>我们也可以一次读入多个字节，也就是使用byte数组来进行储存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">       <span class="comment">//创建输入流并指定路径</span></span><br><span class="line">        FileInputStream fs = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;g:\\IOtest.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//尝试读取</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>];</span><br><span class="line">       fs.read(buf);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        fs.read(buf);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        fs.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219135625281.png" alt="image-20211219135625281"></p>
<p>这里值得注意的是，每次调用read方法时，读入多少数据是由数组的大小决定的，会每次接着读取，直到最后数据不够。</p>
<h3 id="文件字节输出流">文件字节输出流</h3>
<p>我们依旧来写个例子吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">out</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileOutputStream fs = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;g:\\IOtest.txt&quot;</span>，<span class="keyword">true</span>);<span class="comment">//创建输出流对象,此处有一个重构，即第二个参数为true时，写入将接着前面的内容，不会重写覆盖。</span></span><br><span class="line">        fs.write(<span class="number">97</span>);</span><br><span class="line">        fs.write(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//本质上依然是转换成ascii码。</span></span><br><span class="line">        fs.write(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我把之前的文件已经清空。</p>
<p>输出：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219141244327.png" alt="image-20211219141244327"></p>
<p>看看文件内容：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219141325188.png" alt="image-20211219141325188"></p>
<p>当然，这种输入方式效率过于低下，我们依然可以采用数组的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">out</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileOutputStream fs = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;g:\\IOtest.txt&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        String sr=<span class="string">&quot;我是京介，请多指教！&quot;</span>;</span><br><span class="line">        fs.write(sr.getBytes());<span class="comment">//利用string转换为byte数组的方法；</span></span><br><span class="line">        fs.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219152607765.png" alt="image-20211219152607765"></p>
<p>看看文件：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219152635237.png" alt="image-20211219152635237"></p>
<p>大功告成！</p>
<h2 id="字节流复制">字节流复制</h2>
<p>输入流与输出流的配合，创造一个输入与输出，然后读一个写一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileLockInterruptionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fuzi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">        FileInputStream f1 = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;g:\\1.jpg&quot;</span>);</span><br><span class="line">        FileOutputStream f2 = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;g:\\2.jpg&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">while</span> ((count=f1.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            f2.write(count);</span><br><span class="line">        &#125;<span class="comment">//一边读一边写</span></span><br><span class="line">        f1.close();</span><br><span class="line">        f2.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;复制完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前的文件：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219153900302.png" alt="image-20211219153900302"></p>
<p>输出：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219153916320.png" alt="image-20211219153916320"></p>
<p>之后的文件夹：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219153949402.png" alt="image-20211219153949402"></p>
<p>这样我们就成功的复制了一张图片啦！</p>
<h2 id="字节缓冲流">字节缓冲流</h2>
<p>BufferedInputStream以及BufferedOutputStream为字节缓冲流，他们自己就已经拥有一个缓冲区，他们的作用是为其他的输入输出流套上一层缓冲的壳子，因为其他字节流（例如文件字节流）是内存与外存直接数据交流，所以效率很低，这时我们就可以用字节缓冲流来增进效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">huan</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileInputStream f1 = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;g:\\IOtest.txt&quot;</span>);</span><br><span class="line">        BufferedInputStream f2 = <span class="keyword">new</span> BufferedInputStream(f1);<span class="comment">//正是因为为其他流添加缓冲，所以参数是一个其他流，现在我们就用f2来代替f1执行功能。</span></span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">while</span> ((data=f2.read())!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(data+“ ”);</span><br><span class="line">        &#125;</span><br><span class="line">        f2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件还是我们那个老文件：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219162024335.png" alt="image-20211219162024335"></p>
<p>输出为：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219162107314.png" alt="一串熟悉的ascii码"></p>
<p>一串熟悉的ascii码。</p>
<p>在读取数据这一步时，其实是f2自己的缓冲区在进行读取，效率就高了许多。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>两日之恋人</title>
    <url>/2021/12/19/%E4%B8%A4%E6%97%A5%E4%B9%8B%E6%81%8B%E4%BA%BA/</url>
    <content><![CDATA[<p>筠池点了投降。</p>
<p>并不是这局已经无力回天让人痛苦，而是筠池突然感到了厌烦。</p>
<p>这几天筠池时不时的就会感觉到莫名心累，前几天还在嘲笑俞佑，没想到报应来的这么快。</p>
<p>队友当然不会放过他，开始进行各种语言攻击。</p>
<p>筠池瞟了一眼消息栏，然后直接退出游戏，关掉了显示器。</p>
<p>在漆黑的屏幕里他看见了自己的脸，他惊讶于自己彷佛是在观察一个陌生人那样看着自己，里面的人自己好像并不熟悉。</p>
<p>他打开手机，有二十三条未读消息的提醒占据了屏幕，是来自女友的。</p>
<p>最新的一条是“你到底爱不爱我？”</p>
<p>筠池没动，关掉了手机，熄掉了最后一丝光亮，疲惫地瘫在了沙发上。</p>
<p>自己以前不是这样的。</p>
<p>筠池记得以前的事，那时候自己喜欢打游戏是真的，经常做梦是真的，和同伴说骚话是真的，甚至。</p>
<p>爱上葭凛也是真的。</p>
<p>但是筠池忘了葭凛是怎么成为自己女朋友的了，就好像小时候偷偷在楼下租的影碟，播放到令人激动的剧情时，总是用“一夜之后”这样的字来搪塞，令小时候的筠池痛苦不已。</p>
<p>现在也是这样，筠池已经忘记的影片的剧情了，但“一夜之后”却无奈印入了脑海。</p>
<p>也许是自己勇敢表白，葭凛羞涩地回应了他？或者是葭凛提前发现了自己的心意，她的大胆表露？再不然是两个人不约而同的默契眼神？</p>
<p>筠池没有察觉到自己轻轻地笑了笑。</p>
<p>初长成的爱情总是这样的，总有人会觉得令人回味。</p>
<p>后来呢，又发生了什么吗。</p>
<p>筠池拼命回忆，他只想知道，这一切是自己的错吗。</p>
<p>该轮到自己负责了吗。</p>
<p>这也许毫无疑问，但筠池依然想找到点什么。</p>
<p>忽然，他好像真的找到了什么。</p>
<p>那是关于一个名字的，葭凛。</p>
<p>葭凛是个不错的女孩，筠池和她是青梅竹马，两家人的关系一直不错。</p>
<p>筠池是在高中后和她联系又多了起来的。</p>
<p>一定有什么原因，一定发生了什么。</p>
<p>他觉得自己陷入了一个迷宫，这迷宫如此之熟悉，筠池对它了如指掌。</p>
<p>可是他迷路了，明记下个得转弯就是出口，可那里竟然凭空出现一堵墙，上面写着“一夜之后”立在中间，分割了他和出口。</p>
<p>也分割了他与葭凛。</p>
<p>他不想再想下去了，站到窗前拉开了窗帘，望着窗外伴随着蝉声的夜色，筠池平静了下来。</p>
<p>“我觉得你还是太幼稚了吧”</p>
<p>那是葭凛的声音，筠池非常肯定。</p>
<p>他不再犹豫，做回桌前再次打开了电脑。</p>
<p>并不是像甩掉包袱的感觉，更像是多添了一道代表历练的伤疤。</p>
<p>重新连接发现队友还在坚守高地。</p>
<p>并不是每个人都很成熟，但总有人正成长着。</p>
<p>他久违地打开输入框，认真地敲下每一个字。</p>
<p>并不是每次都可以轻松逃掉的，这次就不行。</p>
<p>“不好意思，稳住我来C。”</p>
<p>他想葭凛了。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>记录</category>
      </categories>
      <tags>
        <tag>时间的恋人</tag>
      </tags>
  </entry>
  <entry>
    <title>十日之恋人</title>
    <url>/2021/12/19/%E5%8D%81%E6%97%A5%E4%B9%8B%E6%81%8B%E4%BA%BA/</url>
    <content><![CDATA[<p>俞佑回来了。</p>
<p>“只要我去找他，无论什么时候，他还是会等我的。“</p>
<p>“没有我，他根本活不下去。”</p>
<p>婉夏真的这么有把握？</p>
<p>她的确有把握，因为她知道俞佑爱她爱得要命。</p>
<p>俞佑已经好几天没有回来了，现在终于有消息了。</p>
<p>“他果然还会回到西南石油，因为那是‘我们的家’， 那里还有俞佑辛辛苦苦抽出来的装备，攒的各种各样的玩意儿。”</p>
<p>”他一定还在等着我回去。&quot;</p>
<p>想到这里，婉夏心里忽然觉得舒服多了。</p>
<p>”这两天他一定什么事都不想做，一直忙着跟那些bug对线，甚至连作业和预习都没有弄完。&quot;</p>
<p>想到这里，婉夏又不禁皱了皱眉。</p>
<p>&quot;但是没关系，只要我一见他，无论什么事，他都会抢 着去做了，根本不用我动手。 <strong>”</strong></p>
<p>婉夏满足地叹了口气，一个人已到了她这种时候，想 到还有个地方可以回去，还有人在苦苦地等着她，这 种感觉实在令人愉快。</p>
<p>“以前我对他也许的确太狠了些，逼他逼得太紧，以后 我也要改变方针了。”</p>
<p>”男人就像是孩子，你要他听话，多少也得给他点甜头 吃吃。”</p>
<p>想到这里，她忽然觉得心里有点发热。</p>
<p>”无论如何，他虽然不是个很强的男人，但毕竟不是个 很令人讨厌的人。”</p>
<p>她忽然发觉自己还是有点爱他的。</p>
<p>她这一生中，假如还有个人能真的令她动一点感情， 那人就是俞佑了，想得越多，她就越觉得俞佑的好处 比别人多。</p>
<p>“我真该好好地对他才是，像他这样又氟金又暴肝的男 人，世上并不多，以后我也许再也找不到了。&quot; 越想她越觉得不能放弃他。</p>
<p>也许她一直都在爱着他，只不过因为他爱得太深了， 所以才令她觉得无所谓。</p>
<p>他舔她舔得若没有那么深，她说不定反而会更爱他。 这就是人性的弱点，人性的矛盾。</p>
<p>所以聪明的男人就算爱极了一个女人，也只是藏在心 里，绝不要将他的爱全部在她面前表现出来。</p>
<p>&quot;俞佑，你放心，以后我绝不会再令你伤心了，我一定 天天陪着你，以前的事全已过去，现在我们再重头做起。</p>
<p>&quot;只要你还像以前那样对我，我什么事都可以依着你。</p>
<p>但俞佑是不是还会像以前那样对她呢？</p>
<p>婉夏忽然觉得并不十分有把握，对自己的信心已动摇。</p>
<p>她以前从未有过这种感觉，那只因她以前从未觉得俞佑对她有如此重要，无论俞佑对她是好是坏，她都全不放在心上。</p>
<p>一个人只有在很想“得到”的时候，才会怕&quot;失去”</p>
<p>这种患得患失的感觉，也正是人类许多种弱点之一。</p>
<p>可悲的是，你想&quot;得到”的人越急切，&quot;失去”的可能就越 大。</p>
<p>婉夏抬起头，已看到西南石油。</p>
<p>西南石油的俞佑室里居然有灯。</p>
<p>她忽然停下来，换了身衣裳，洗了洗脸，擦了擦大腿 和手臂的痕迹，又喷了点香水来掩盖味道，又用手指做梳子，梳了梳头发。</p>
<p>她不愿让俞佑看到她这种狼狈的样子。</p>
<p>因为她绝不能再失去他。</p>
<p>屋子里的灯还在亮着。</p>
<p>西南石油里很安静，静的好像没有什么人。</p>
<p>俞佑正坐在电脑旁，不知道在做什么。</p>
<p>滴滴滴，鼠标点击的声音密密麻麻的。</p>
<p>他看着很淡然，似乎在坐着再平常不过的日常活动，夜已深。</p>
<p>一个人面对着电脑，慢慢地点击着。</p>
<p>没有看到过这种景象的人，绝不会想到这景象是多么寂寞，多么凄凉。</p>
<p>然后，门轻轻被推开了。</p>
<p>婉夏忽然出现在门口，瞧着他。</p>
<p>在看到俞佑的这一瞬间，她心里忽然觉得有一阵热血上涌，就好像流浪已久的游子骤然见到亲人一样。 就连她自己都不知道她怎会有这种感觉。</p>
<p>她的血本是冷的。</p>
<p>俞佑却似乎根本没有发觉有人进来，还是低着头，点击着鼠标。</p>
<p>但他脸上的肌肉却似在逐渐僵硬。</p>
<p>婉夏忍不住轻唤了一声：“俞佑……”</p>
<p>这呼唤的声音还是那么温柔，那么甜蜜。</p>
<p>俞佑终于慢慢地抬起头，面对着她。</p>
<p>他的眼睛还是很亮，是不是因为有泪呢？</p>
<p>婉夏的眼睛似也有些湿了，柔声道：&quot;俞佑，我回来了。”</p>
<p>俞佑没有动，也没有说话。</p>
<p>他似已僵硬得不能有任何动作了 。</p>
<p>婉夏已慢慢地向他走了过来，轻轻道：“我知道你会等我的，因为我到现在才知道这世上只有你一个人是真的对我好。”</p>
<p>这种话她说过多少次了？</p>
<p>但每一次都管用，所以这次也会有用，她始终坚信着这件事。</p>
<p>“别的人都只不过是利用我……我利用他们，他们利用我！这本没有什么吃亏的，只有你，无论我怎么样对你，你对我总是真心真意。”</p>
<p>她没有注意俞佑脸上表情的变化。</p>
<p>因为她距离俞佑已越来越近了，已近得看不清许多她应该看到的事。</p>
<p>“我决心以后绝不再去穿兔女郎衣服了，绝不会再让你伤心了，无论你要怎么样，我都可以依着你，都可以 答应你……</p>
<p>&quot;砰！”俞佑将鼠标击向木制的桌面，声音大的吓人。 婉夏拉起他的手，放在自己胸膛上。</p>
<p>自己的胸有多勾人她是最清楚不过的，俞佑，还有那些人，都拜倒在她的石榴裙下。</p>
<p>她的声音甜得像蜜。</p>
<p>“以前我若有对不起你的地方，以后我一定会加倍补偿你，我会要你觉得无论你对我多好，都是值得的。” 她的胸膛温暖而柔软。</p>
<p>无论任何人的手若放在她胸膛上，绝对再也舍不得移开。</p>
<p>俞佑的手忽然自她胸膛上移开了</p>
<p>婉夏瞟了一眼电脑，那是背包，里面空荡荡的，什么都不剩下了。</p>
<p>婉夏眼睛里忽然露出丝恐惧之色道：&quot;你……你难道……</p>
<p>难道不要我了？ ”</p>
<p>俞佑静静地瞧着她，就好像第一次看到她这个人似 的。</p>
<p>婉夏道：“我对你说的全都是真话，以前我虽然也和别 的男人有……有过，但我对他们那全都是假的……“她声音忽然停顿，因为她忽然看到了俞佑脸上的表情。</p>
<p>俞佑的表情就像是想呕吐。</p>
<p>婉夏不由自主后退了两步，道：“你……你难道不愿听真话？你难道喜欢我骗你？ ”</p>
<p>俞佑盯着她，良久良久，忽然道：“我只奇怪一件</p>
<p>事</p>
<p>婉夏道：“你奇怪什么？&quot;</p>
<p>俞佑慢慢地站了起来，一字字道：“我只奇怪，我以前怎么会爱上你这种女人的！”</p>
<p>婉夏忽然觉得全身都凉了。</p>
<p>俞佑没有再说别的。</p>
<p>他用不着再说别的，这一句话就已足够。</p>
<p>这一句话就已足够将婉夏推入万劫不复的深渊。</p>
<p>俞佑慢慢地走了出去。</p>
<p>一个人若已受过无数次打击和侮辱，绝不会不变的。</p>
<p>一个人可以忍受谎言，却绝不能忍受那种最不能忍受 的侮辱–女人如此，男人也一样。</p>
<p>做妻子的如此，做丈夫的也一样。</p>
<p>婉夏只觉自己的心在往下沉，往下沉……</p>
<p>俞佑已拉开了门。</p>
<p>婉夏忽然转身扑过去，扑倒在他脚下，拉住他的衣服，嘶声道：“你怎么能就这样离开我……我现在已只 有你……“</p>
<p>他只是慢慢地将衣服脱了下来。</p>
<p>他赤着上身走了出去，走入雨中。</p>
<p>他走了出去，走入雨中。</p>
<p>雨很冷。</p>
<p>可是雨很干净。</p>
<p>他终于甩脱了婉夏，甩脱了他心灵上的枷锁，就好像甩脱了那件早已陈旧破烂的衣服，婉夏却还在紧紧抓着那件白色衣服，因为她知道除了这件衣服外，就再也抓不住别的。</p>
<p>“到头来你总会发现你原来什么也没有得到，什么都是空的……”</p>
<p>婉夏泪已流下。</p>
<p>到这时她才发现她原来的确是一直爱着俞佑的。</p>
<p>她折磨他，也许就因为她爱他，也知道他爱她。</p>
<p>”女人为什么总喜欢折磨最爱她的男人呢？&quot;</p>
<p>到现在，她才知道俞佑对她是多么重要。</p>
<p>因为她已失去了他。</p>
<p>“女人为什么总是对得到的东西加以轻蔑，为什么总要等到失去时才知道珍惜。”</p>
<p>也许不只女人如此，男人也是一样的。</p>
<p>婉夏突然狂笑起来，狂笑着将俞佑的衣服一片片撕碎。</p>
<p>“我怕什么，我这么漂亮，又这么年轻-一只要我喜欢，要多少男人就有多少男人，我每天换十个都没有关系。</p>
<p>她在笑，可是这笑却比哭更悲惨。</p>
<p>因为她也知道男人虽容易得到，但&quot;真情&quot;却绝不是青春和美貌可以买得到的……</p>
<p>雨很冷。</p>
<p>冷雨洒在俞佑胸膛上，他觉得舒服得很，因为这雨令 他觉得自己并不是麻木的，十天来，这也许是他第一次有这种感觉。</p>
<p>而且他觉得很轻松，就像是刚卸下了一个沉重的包袱。</p>
<p>远处有人在呼唤：“你好……”</p>
<p>呼声很轻，若在几天前，他也许根本听不见。</p>
<p>但现在，他的眼睛已不再瞎，耳朵也不再聋了。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>记录</category>
      </categories>
      <tags>
        <tag>时间的恋人</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用类</title>
    <url>/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/</url>
    <content><![CDATA[<h1>object类</h1>
<p>java语言所有类的根类，object也就是所有类的父类（也就意味着所有类都可以使用object类的方法），位于lang包中，所以不需要导包便可使用。</p>
<h2 id="getclass">getclass</h2>
<p>getclass()方法是返回应引用中存储的实际对象类型（返回值为class类型）</p>
<p>多用于判断两个对象是否是同一个类。</p>
<h2 id="hashCode">hashCode</h2>
<p>hashCode()方法返回的是一个int类型，是根据对象的地址或字符串或数字使用hash算法计算出的数值。</p>
<h2 id="tostring">tostring</h2>
<p>String tostring()   返回该对象的字符串表示。</p>
<p>类如我们创建一个person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用text测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        person p1 = <span class="keyword">new</span> person(<span class="string">&quot;瑾介&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        String s=p1.toString();</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211124624726.png" alt="image-20211211124624726"></p>
<p>我们发现，直接打印对象的名字，其实就是调用了tostring方法。打印的都是堆内存中的十六进制地址值。</p>
<p>如果想直接打印对象的属性的话，我们可以重写tostring方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;person&#123;name=&quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;,age=&quot;</span>+<span class="keyword">this</span>.age+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在再来打印的话：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211125454617.png" alt="image-20211211125454617"></p>
<p>这样就实现了我们自定义的tostring输出了。</p>
<h2 id="equals">equals</h2>
<p>指示其他的某个对象是否与此对象”相等“。</p>
<p>如果没有重写equals方法，那么它将会直接比较两个对象的地址值，我们依然用之前的person对象来做测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        person p1 = <span class="keyword">new</span> person(<span class="string">&quot;瑾介&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        person p2 = <span class="keyword">new</span> person(<span class="string">&quot;瑾介&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(p1.equals(p2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211130438858.png" alt="image-20211211130438858"></p>
<p>比较两个两个对象的地址值几乎没有什么意义，那我们还是来重写一下equals海曙吧。</p>
<p><em><strong>不过这里需要注意的是，这里隐含了一个多态的问题，即我们引入的参数obj是object类的，他无法访问到我们person类的name、age等参数，所以我们需要进行一个向下转型，也就是强制转换：</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">   person person = (person)obj;<span class="comment">//进行强制转换成我们的person类。</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.age==person.age&amp;&amp;<span class="keyword">this</span>.name==person.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211143201551.png" alt="image-20211211143201551"></p>
<p>当然为了防止类型转换异常，我们一般得写一个if条件来判断我们的参数是否是person的父类，完整的重写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> person) &#123;</span><br><span class="line">        person person = (person) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age == person.age &amp;&amp; <span class="keyword">this</span>.name == person.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//不是person类型直接false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="finalize">finalize</h2>
<p>当对象被判定为垃圾对象是，由jvm自动调用此方法，用于标记垃圾对象，进入回收队列。因为Java由自动回收垃圾机制，故平时一般不太会使用。</p>
<h1>String类</h1>
<h2 id="字符串池">字符串池</h2>
<p>字符串是常量，创建后不可以改变，字符串字面值存储在字符串池中，可以共享。</p>
<p>字符串池是位于堆的一个区，为了便于共享而创建的，当创建字符串的时候会先到字符串池里寻找，比如说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name=<span class="string">&quot;jinjie&quot;</span>;<span class="comment">//&quot;jinjie&quot;常量存储在字符串池中</span></span><br><span class="line">        name=<span class="string">&quot;jingjie&quot;</span>;<span class="comment">//新的字符串“jingjie”被创建赋值给了name（“jinjie”就成了废弃物。）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在多加两行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name=<span class="string">&quot;jinjie&quot;</span>;<span class="comment">//&quot;jinjie&quot;常量存储在字符串池中</span></span><br><span class="line">        name=<span class="string">&quot;jingjie&quot;</span>;<span class="comment">//新的字符串“jingjie”被创建赋值给了name（“jinjie”就成了废弃物。）</span></span><br><span class="line">         String name2=<span class="string">&quot;jingjie&quot;</span>;</span><br><span class="line">        System.out.println(name2==name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据共享的原则，这时候创建的name2先到字符串池中寻找有没有“jingjie”，在发现有之后，就把字符串池中“jingjie”的地址也赋值给了name2，所以name2和name的地址是相等的，所以结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211214144031671.png" alt="image-20211214144031671"></p>
<p>另外，我们有两种方式来定义字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name=<span class="string">&quot;jinjie&quot;</span>;</span><br><span class="line">String name=<span class="keyword">new</span> String(<span class="string">&quot;jinjie&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上面一种是我们常用的方法，它只创建了一个对象，但是下面一种方法我们却创造了两个对象，在堆里有一个对象，在字符串池里也有一个对象，但是真正的运行的时候只有一个对象，即堆里的对象也指向字符串池里的对象（所以比较浪费空间。</p>
<p>所以字符串比较要用equals进行比较（String重写了equals方法）。</p>
<h2 id="String的常用方法">String的常用方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;<span class="comment">//返回字符串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//根据下标获取字符。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String str)</span></span>;<span class="comment">//判断当前字符串是否含有str。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray();<span class="comment">//将字符串转化成数组。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span>;<span class="comment">//返回str首次出现的下标，若不存在则返回-1.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> interestinglast <span class="title">IndexOf</span><span class="params">(String str)</span>:<span class="comment">//查找字符串在当前字符串中最后一次出现的下标。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span></span>;<span class="comment">//去掉字符串的前后空格。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">()</span></span>;<span class="comment">//将小写转换成大写。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endWith</span><span class="params">(String str)</span></span>;<span class="comment">//判断字符串是否即以str结尾。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldchar,<span class="keyword">char</span> newChar)</span></span>;<span class="comment">//替换字符。</span></span><br><span class="line"><span class="keyword">public</span> String[] split(String str);<span class="comment">//根据str做拆分。</span></span><br></pre></td></tr></table></figure>
<h2 id="可变字符串">可变字符串</h2>
<p>StringBuilder:可变长字符串，效率快，线程不安全。</p>
<p>StringBuffer:可变长字符串，效率慢，线程安全。</p>
<blockquote>
<p>现在一般使用StringBuilder.</p>
</blockquote>
<p>我们来看个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   StringBuffer n = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">   n.append(<span class="string">&quot;我叫京介！&quot;</span>);<span class="comment">//1.在最后面添加字符。</span></span><br><span class="line">   n.append(<span class="string">&quot;请多指教！&quot;</span>);</span><br><span class="line">   System.out.println(n.toString());</span><br><span class="line">   System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line">   n.insert(<span class="number">0</span>,<span class="string">&quot;你好！&quot;</span>);<span class="comment">//2.在指定位置添加内容。</span></span><br><span class="line">        System.out.println(n.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line">n.replace(<span class="number">0</span>,<span class="number">2</span>,<span class="string">&quot;欢迎！&quot;</span>);<span class="comment">//替换字符串。</span></span><br><span class="line">System.out.println(n.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211215192541609.png" alt="image-20211215192541609"></p>
<h1>BigDecimal类</h1>
<p>float与double类型储存的数据都是近似值（比如1.0就是0.999999……），原因是因为它们采取的是二进制存储。需要精度存储时要使用BigDecimal类来精确计算浮点数。</p>
<p>我们举例来说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> a1=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> a2=<span class="number">0.9</span>;</span><br><span class="line">        System.out.println(a1-a2);</span><br><span class="line">        <span class="comment">//储存近似值。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        BigDecimal b1=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">        BigDecimal b2=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">        BigDecimal r=b1.subtract(b2);<span class="comment">//减法</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        BigDecimal r1=b1.add(b2);<span class="comment">//加法</span></span><br><span class="line">        System.out.println(r1);</span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        BigDecimal r2=b1.multiply(b2);<span class="comment">//乘法</span></span><br><span class="line">        System.out.println(r2);</span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        BigDecimal r3=b1.divide(b2,<span class="number">2</span>,BigDecimal.ROUND_HALF_UP);<span class="comment">//除法</span></span><br><span class="line">        System.out.println(r3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用BigDecimal进行运算时是调用BigDecimal的方法，值得注意的是，在使用BigDecimal的除法方法的时候，如果出现除不尽的现象的话，程序将会报错，所以这时3要使用到divide除法方法的重载方法，在参数的后面添加保留的小数位数以及保留的方法</p>
<blockquote>
<p>保留方法的参数是Bigdecimal的几个常量，BigDecimal.ROUND_HALF_UP的意义即为四舍五入。</p>
</blockquote>
<p>结果是：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211215195425390.png" alt="image-20211215195425390"></p>
<h1>System类</h1>
<p>系统类是静态的，直接使用就可以，下面我列举几个方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static void arraycopy(……)</td>
<td>复制数组</td>
</tr>
<tr>
<td>static void currentTimeMillis();</td>
<td>获取系统当前时间（返回毫秒值）</td>
</tr>
<tr>
<td>static void gc();</td>
<td>建议JVM回收垃圾</td>
</tr>
<tr>
<td>static void exit(int status);</td>
<td>退出JVM</td>
</tr>
</tbody>
</table>
<h1>++包装类</h1>
<p>对于基本数据类型所拓展的包装类型，这样基本数据类型就可以实现更多的方法和功能。</p>
<blockquote>
<p>实际上，更深层的原因是Java不在支持指针操作，因此创造出了内部类的功能使得数据能在堆和栈之间进行转换。</p>
</blockquote>
<p>其包装类对应如下：</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody>
</table>
<p>每一种包装类型都由更多的方法与属性。</p>
<h2 id="装箱、拆箱">装箱、拆箱</h2>
<p>装箱：把栈里面的东西装到堆里面去（基本类型转换为引用类型）。</p>
<p><em>一般通过引用类型的构造方法实现，比如：</em><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212144744804.png" alt="image-20211212144744804"></p>
<p>拆箱：把堆里面的东西装到栈里面去（引用类型转换为基本类型）。</p>
<p><em>一般通过number类（包装类型的父类）的方法进行拆箱</em>*，比如：*</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212172036602.png" alt="image-20211212172036602"></p>
<blockquote>
<p>JDK1.5之后，java开始提供自动装箱和拆箱……意思是直接用赋值符号就行了。但其背后的实质是一样的，只是Java在背后帮我们自动操作了。</p>
</blockquote>
<h2 id="类型转换">类型转换</h2>
<h3 id="1、基本类型与字符串类型转换">1、基本类型与字符串类型转换</h3>
<h4 id="1-1使用-号">1.1使用+号</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ni=<span class="number">10</span>;</span><br><span class="line">String s1=n1+<span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="1-2使用tostring方法">1.2使用tostring方法</h4>
<p>使用Integer中的tostring()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s2=Integer.toString(ni);</span><br><span class="line">String s2=Integer.toString(ni，<span class="number">16</span>);<span class="comment">//此方法可以重载，按十六进制进行转换。 </span></span><br></pre></td></tr></table></figure>
<h3 id="2、字符串类型与基本类型转换">2、字符串类型与基本类型转换</h3>
<h4 id="2-1使用Integer的parse方法">2.1使用Integer的parse方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">&quot;150&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> n=Integer.parse(str);<span class="comment">//str里只能有数字。</span></span><br></pre></td></tr></table></figure>
<h3 id="3、Boolean字符串转换为基本类型">3、Boolean字符串转换为基本类型</h3>
<p>依旧使用parse进行格式化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str2=<span class="string">&quot;true&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> b1=Boolean.parseBoolean(str2);<span class="comment">//只用true能被格式化为true,其它字符均为false。</span></span><br></pre></td></tr></table></figure>
<h2 id="整数缓冲区">整数缓冲区</h2>
<p>Java预先创建了256的常用的整数包装对象，在实际的应用当中，对已经创建的对象进行复用。</p>
<p>我们来举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer integer1 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">        Integer integer2 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">        System.out.println(integer1==integer2);</span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        Integer integer3=<span class="number">100</span>;<span class="comment">//自动装箱</span></span><br><span class="line">        Integer integer4=<span class="number">100</span>;</span><br><span class="line">        System.out.println(integer4==integer3);</span><br><span class="line">      	Integer integer5=<span class="number">200</span>;</span><br><span class="line">        Integer integer6=<span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>猜猜看会输出什么？</p>
<p>表面上都是生成代表int值100的Integer类型，但结果是：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212180010477.png" alt="image-20211212180010477"></p>
<p>为什么会出现这种情况呢？这是因为integer1与integer2是new出来的，属于不同的地址，“==”比较的是地址值，第一个当然不同。</p>
<p>第二个为自动装箱，调用的都是Integer的valueof方法。那我们来看一下valueof方法：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212180440932.png" alt="image-20211212180440932"></p>
<p>是不是发现只要参数是在一定范围里的int，那么就返回了一个cache数组里的元素？</p>
<p>我们再来具体的看一看具体的数和cache数组：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212180855001.png" alt="静态中间那坨可以忽略"></p>
<p><em>静态中间那坨可以忽略，为的是最后的high=h</em></p>
<p>这，就是我们的整数缓冲区，一个名为cache的数组，最高high为127，low为-128，所以我们的integer3与integer4是同一个，已经被实例好的对象，所以就是相等的咯。</p>
<p>当然，相信大家都发现了，integer5与integer6的int数字是大于了127的，所以执行相应语句，也就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br></pre></td></tr></table></figure>
<p>那这自然就跟1、2的结果是一样的了。</p>
<h1>日期时间类</h1>
<h2 id="Date类">Date类</h2>
<p>类Date表示特定的瞬间，精确到毫秒。</p>
<blockquote>
<p>毫秒，即为千分之一秒。</p>
</blockquote>
<p>毫秒值一般用于计算日期的间隔，即将日期都转换成毫秒值进行加减，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.currentTimeMillis()<span class="comment">//可以输出当前系统时间距离时间原点1970年1月1日凌晨经历了多少毫秒</span></span><br></pre></td></tr></table></figure>
<h3 id="无参构造">无参构造</h3>
<p>直接实例化一个无参构造的Date类，打印出来将是我们系统的标准时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">date</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">			text();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">text</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211150504218.png" alt="image-20211211150504218"></p>
<p>这里的CST指的是中国标准时间。</p>
<h3 id="带参的构造方法">带参的构造方法</h3>
<p>Date类还可以使用带参的构造方法，此时参数为从时间原点开始的毫秒值，列如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date(<span class="number">0</span>);<span class="comment">//将上面的代码块的构造方法添加为0的参数。</span></span><br></pre></td></tr></table></figure>
<p>此时它就会打印：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211151139834.png" alt="image-20211211151139834"></p>
<p>即为打印时间原点。</p>
<h3 id="gettime-方法">gettime()方法</h3>
<p>将日期转换成毫秒值，返回的是一个long类型的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">      <span class="keyword">long</span> s=date.getTime();</span><br><span class="line">      System.out.println(s);</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211151520479.png" alt="image-20211211151520479"></p>
<h2 id="DateFormat类">DateFormat类</h2>
<p>是对时间与日期进行一个格式化的抽象类，属于Java.text包中，有两个作用：</p>
<p>格式化：从日期转到文本[String format(Date date)]</p>
<p>解析：从文本转到日期[Date parse(String source)]</p>
<p>由于DateFormat是一个抽象类，所以我们要用到他的子类SimpleDateFormat进行对日期格式的约束。</p>
<blockquote>
<p><code>SimpleDateFormat</code> 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt;  文本）、解析（文本 -&gt; 日期）和规范化。</p>
</blockquote>
<h3 id="格式化">格式化</h3>
<p>要相对时间进行一个格式化的输出，需要用到SimpleDateFormat里的format方法，那我们首先的得创建一个**”模式“**，通过这个模式来告诉我们的类应该怎样输出时间，在SimpleDateFormat类中，模式通过字母来代表创建，下面我们列举一些常用的代表：</p>
<table>
<thead>
<tr>
<th>字母代表</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody>
</table>
<p>所以我们可以写出类似于： <strong>”yyyy-MM-dd  HH:mm:ss“</strong>   这样的时间格式。</p>
<p>来创建一个SimpleDateFormat类试试吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">demo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SimpleDateFormat t1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日HH:mm:ss&quot;</span>);<span class="comment">//模式作为参数传入SimpleDateFormat类。</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();<span class="comment">//创建一个时期类</span></span><br><span class="line">        String time;</span><br><span class="line">        time=t1.format(date);<span class="comment">//用方法来格式化我们的日期类.</span></span><br><span class="line">        System.out.println(time);</span><br><span class="line">        System.out.println(date);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211155207944.png" alt="image-20211211155207944"></p>
<h3 id="解析">解析</h3>
<p>使用SimpleDateFormat里的parse方法，可以将一段字符串日期转换为Date类日期。</p>
<p>这里值得注意的是，如果字符串日期的模式与设定的模式不相符合的话，parse方法会抛出一个异常，这时我们要么使用throw继续向上抛出异常，要么使用try  catch自己进行处理。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">demo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SimpleDateFormat t1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日HH:mm:ss&quot;</span>);<span class="comment">//模式作为参数传入。</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        String time;</span><br><span class="line">        time=t1.format(date);</span><br><span class="line">        Date d1 = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//使用try catch来监控</span></span><br><span class="line">            d1=t1.parse(time);</span><br><span class="line">            System.out.println(d1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">           System.out.println(<span class="string">&quot;格式出错&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211163615731.png" alt="image-20211211163615731"></p>
<p>如果我们使用不一样的时间的话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat t2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年dd日MM月HH:mm:ss&quot;</span>);<span class="comment">//模式作为参数传入。</span></span><br><span class="line">d1=t2.parse(time);<span class="comment">//修改要捕获异常的语句</span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211164157365.png" alt="image-20211211164157365"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>新泽没有夏天</title>
    <url>/2021/12/05/%E6%96%B0%E6%B3%BD%E6%B2%A1%E6%9C%89%E5%A4%8F%E5%A4%A9/</url>
    <content><![CDATA[<h1>新泽没有夏天</h1>
<h2 id="新泽没有夏天（一）">新泽没有夏天（一）</h2>
<p>暴雨如期而至。雨珠打翻了枯叶，搅混了池塘，空中弥漫着泥土的气息，池塘里的鱼群惊慌失措，仿佛因为看不清前途命运而焦躁不安。</p>
<p>叶瑾介当时也是在这种时候到达新泽的。</p>
<p>虽说新泽阴雨连绵，很少能够见到阳光，但对于参加过高考的叶瑾介来说，这注定会是他通往梦想的地方。</p>
<p>“新泽没有夏天”</p>
<p>叶瑾介曾发过誓，要与高中时的那个家伙分道扬镳。</p>
<p>叶瑾介口中的那个家伙，实际上是他的高中同桌，一个留着马尾的女生。</p>
<p>叶瑾介中考时翻了改变人生的车，那段时间，他在痛哭流涕中听说父母花了巨款强行将自己转到了本地的一所不太妙的高中，那是叶瑾介之前从未想象过的今后三年会去的地方，叶瑾介惊了，联想到自己的尊严，一抹眼泪，决定要发声抗议。</p>
<p>最近刚高考完的大学生叶瑾介不知为何经常想起自己中考后的日子，所以有时晚上经常睡不着，再说新泽的天气非常寒冷，能正常入睡和醒来实属罕见。</p>
<p>”目前是离夏天尚有一段时间的季节，所以有些冷也是正常的。”叶瑾介在早上被冻醒后已经开始条件反射的这样想。</p>
<p>叶瑾介早早地来到了图书馆自习，却发现熟悉的位置已经拥有主人，瑾介微微愣了一下，但很快便面色如常，随便找了个地方坐了下来。甩下书包，拉开拉链，拿出平板电脑，最后再接上电源，一套动作悉如平常，不过大脑不再像平常一样想着动态规划等种种，而是多了一道灰色的模糊身影，当然不会有其他答案，他想的是坐在他曾经位置上的少女。对于叶瑾介这种青春少年来说，这些看似平常的邂逅总能引发他的无限遐想，他回想起高中的时光，那时候，叶瑾介在班上还算是个帅哥，一些未曾知晓世界广阔的女生闲来无事时还曾经追求过他，这也是后来他进入大学后依然产生了“我也算是个抢手货”的错觉的原因。大学后的叶瑾介也确实基本放弃了在大学找个女朋友的想法，他目前的计划寄托在自己出国的这件事上。</p>
<p><img src="/2021/12/05/%E6%96%B0%E6%B3%BD%E6%B2%A1%E6%9C%89%E5%A4%8F%E5%A4%A9/IMG_38951562_1.jpg" alt></p>
<p>当然，到最后他与那位灰色的少女也没有发生任何的交集，因为当叶瑾介想起自己的充电器还长年的放在那里的并准备用这个理由去打个招呼时，那个少女早就消失不见了。叶瑾介懊悔地怪自己自己怎么偏偏就昨晚想起了给手机充电，导致了自己错失了因为手机没电了而导致的一系列事件。</p>
<p>“一开始就已经进入bad ending了啊……”叶瑾介心里默默地这样想，但他也并不感到难过，毕竟他知道自己犹豫不决的时间一定要比手机没电的时间长。说白了，叶瑾介，某些情况下，是个阿宅。</p>
<p>下午是一节高等数学，明明自己睡了午觉的，脸部肌肉却依然忍不住地抽搐，这是叶瑾介即将入眠的征兆。“要是这节课再睡着了，那我以后还是别来这节课了吧，自己自学好了。”</p>
<p>这明明是督促自己不要睡觉的想法，叶瑾介却发现自己有种做出承诺安下心来的快感，防线不攻自破，叶瑾介很快的睡了过去。</p>
<p>“你们没有权力替我做决定！”</p>
<p>想要冲向父母房间、还在为中考烂摊子苦恼的叶瑾介本来是想用这句绝妙的话来大声向父母反抗的，站在门口时却猛地想起自己的成绩应该就读蓝翔技校的，相较于蓝翔，这所差点的高中好像也还行，毕竟还是个公立学校，寝室听说也还不错……正当叶瑾介进行头脑风暴，拼命搜刮着自己所知的有关那个高中所有优点时，一声惬意的鼾声从房间传了出来，叶瑾介心中顿时涌起了一股暖流。</p>
<p>高中开学那天，叶瑾介抱着头脑风暴的成果去了学校，报道流程结束后，叶瑾介绕着学校转了一圈，没人知道叶瑾介这是在干什么，但有人看见了他最后坐在食堂门前的椅子上发出了一声悲鸣。叶瑾介自己知道，自己在这里和当年初中班上成绩榜郊区的同学打招呼时，是有些尴尬的，更何况自己是被一笔钱塞进来的，叶瑾介在那时就决定了，在高中，努力学习，一飞冲天。抱着做鸡头的想法，叶瑾介飘飘然地感到一阵眩晕。</p>
<h2 id="新泽没有夏天（二）">新泽没有夏天（二）</h2>
<p>再次醒来是因为下课准点时同学们不约而同的收拾离场声，此时高数老师还在讲台上高声呼喊着什么，叶瑾介虽然生理上起了反应，精神上还是一片混沌，他好像梦到了自己当年的高中生活，却又完全没记住任何细节。</p>
<p>“嗯……”一道低吟猝不及防地响起。</p>
<p>“哇！”叶瑾介本能地后仰，打翻了未曾翻开的高数上，回头发现了一个紫发少女正认真地看着自己的脸。</p>
<p>“呃……阔你几哇？”叶瑾介一紧张就容易说烂话。</p>
<p>紫发少女少女仍然默默坐在旁边，一言不发，只是神色越加疑惑。</p>
<p>本就社恐的叶瑾介更加局促不安，心中暗骂该死，自己说的什么烂话，搞的气氛更加尴尬了，还是应该正常一点，先从最基本的开始吧，叶瑾介清了一下嗓子，开口道：</p>
<p>“你叫……”</p>
<p>“蕾妤。”</p>
<p>还没等叶瑾介问完，少女就已经说出了答案，叶瑾介硬生生把后半句咽了回去，他发现喉咙好像有东西堵在那里了。</p>
<p>“你为……”</p>
<p>“因为我是数学课代表，整个教室都已经走光了，就你在这里发呆。”少女移开了目光，似乎感受到了叶瑾介的惊讶，轻松地对着叶瑾介笑了一下，顺手捡起了叶瑾介的高数书“只是一场考试的失利罢了，对你影响有这么大吗？另外，没有梦见我想要的东西喔。”</p>
<p>自称蕾妤的紫发少女再次看向叶瑾介，充满了戏谑的意味。</p>
<p>而叶瑾介没有反应过来，硬塞回了两句话，他再也忍不住了，对着少女，惬意地打了一个长长的嗝。</p>
<p>新泽没有夏天</p>
<p>“世界线？”叶瑾介好奇地问。</p>
<p>“嗯，这就是我的能力，可以和不同世界线的人沟通。”蕾妤耸了耸肩，侧过身去，紫色的短发随着身体弯曲成了优雅的弧线，轻贴在五官精致的小脸旁。叶瑾介想起了他高中的同桌，那时他偷瞄的，似乎也是这样的景象。</p>
<p>“啊不…我是觉得…呃…世界线是什么……”</p>
<p>叶瑾介在空无一人的教室，看着少女的侧脸，这样的氛围使得叶瑾介几乎无法呼吸，抱着“我这难道是要死了吗”的疑问，口齿不清地回答到。</p>
<p>“这样给你说吧，每个人的命运有无数多种，列如你，叶瑾介，有的你大富大贵，一生极尽奢侈。有的你却家道中落，一生苦难，最后病死在囚笼。有的你一生碌碌无为，最后的离去有如一片枯叶，无人在意。有的你却在万人之上，统治着半个世界。”</p>
<p>蕾妤神情恍惚，双手蜷缩在一起，把头埋进了臂弯。</p>
<p>“如今的你，便是以往所以世界线的随机排列组合。像是亿万不甘平静的灵魂，仍在创造追寻着不同的结局。而且，世界线拥有不同的载体，就像是一帧电影，一篇小说，一张照片，甚至是一句话。从不同的世界线来观测我们，我们的世界也许就是那样的。”</p>
<p>“呃，意思是，我们在其他世界的存在形式，也许只是一部小说？”</p>
<p>“嗯，对啊，也许还是质量很次的那种呢。”蕾妤抬头轻轻笑了一下。</p>
<p>“我们的世界…也许是一部小说？”叶瑾介又疑惑地重复了一遍，他望着周围空荡荡的教室，黑板上还有高数老师留下的满满的板书，一切都是那么的真实，叶瑾介很难想象这个世界在其他世界仅仅是用文字描绘的图像。叶瑾介感觉眩晕，不知在何处好像缺失了点什么。</p>
<p>“你也不用太紧张了，世界线的本质都是一样的，不同的载体只不过是观测其他世界的窗口而已。毕竟……”蕾妤突然转过头来，认真地盯着叶瑾介的眼睛，缓缓地说到</p>
<p>“世界线就是命运。”</p>
<p>“在我们的世界线周围，还环绕着另外一条世界线，那是我们的孪生世界。就像人类的双胞胎一样，不过概率低的可怕，人类DNA碱基的数量，比起世界线的数量来说，简直可以忽略不计。无论从什么角度上来说，这都是个奇迹。但是，奇迹，不总是带来好事。”</p>
<p>蕾妤离开了座位，站到窗边，眺望着楼下来来往往的人们，神色略显哀伤，叶瑾介。似乎听见她在轻轻叹息。</p>
<p>这位窥探命运的使者，难道是在为自己的命运所叹息吗？</p>
<p>叶瑾介的脑海不知为何突然出现这样的想法。</p>
<p>夕阳为蕾妤镀上了一层金边，这条金边一直延伸到了叶瑾介手边，叶瑾介很想抓住那道光。靠在窗边的瘦小身影像是在忍受着什么。叶瑾介抑制住想要上去抱住她的冲动，默默地坐在原地看着她。叶瑾介知道，他不可能成为那样的一个像是英雄的人。</p>
<p>“你就不会说句话吗，真是的。”蕾妤转头略微埋怨。</p>
<p>“呃…我不是很懂啊。”叶瑾介知道，自己又在说废话。</p>
<p>蕾妤看了看手上的表，眉头微微皱起。</p>
<p>“我只能简单的给你解释一下，我们两个孪生世界线非常相似，几乎可以说是一模一样，我们世界有的东西，那个世界也有。但我们发现这两条世界线越靠越近，可能在不久的将来会发生融合。”</p>
<p>“融合？”</p>
<p>“在我们的认知范围内，曾有幸了解到世界线的上一次融合。”</p>
<p>“那……会怎样？”</p>
<p>“世界上的所有东西，两个世界，只会留下其中的一份。”</p>
<p>“等等，也就是说那个世界还有一个我吗？！”叶瑾介突然想到。</p>
<p>“是的，在另一个世界，有一个和你差不多的家伙，也有和我对应相似的人，算是沟通我们两个世界的桥梁。”</p>
<p>蕾妤伸了个懒腰。</p>
<p>叶瑾介愣在座位上，一动不动。</p>
<p>“总之，今天和你说的太多了，不知道是好是坏，回去好好想想吧。”</p>
<p>蕾妤轻轻地从桌子上跃了下来，开始往教室门口的方向走去。</p>
<p>“等等，我还有一个问题！”叶瑾介突然惊醒。</p>
<p>“嗯，最后一个问题，说吧。”蕾妤了停下离开教室的脚步。</p>
<p>“为…为什么要告诉我这些？为什么是我？不可能是因为我高数课睡觉吧！一定是有什么原因的！”</p>
<p>叶瑾介试图掩饰自己的惊恐，听到问题的蕾妤轻轻地笑了一下，继续迈开脚步，离开了房间，叶瑾介急忙追到教室门外，却没能再看到她。</p>
<p>“想想吧，你梦里的故事。”</p>
<p>是蕾妤的声音，从走廊飘来。</p>
<p>“对了，作为课代表，你上课睡觉的事，已经被记录下来了喔。”</p>
<p>叶瑾介一直紧紧攥着的高数书，终于又掉在了地上。</p>
<hr>
<h1>穿越者的降临</h1>
<h2 id="穿越者的降临（一）">穿越者的降临（一）</h2>
<p>蕾妤是个孤儿。</p>
<p>据收留她孤儿院的院长老人回忆，那是一个冬天的早上，院长在门口扫雪时，听见敲门的声音，打开们发现了一个在雪地里小脸冻得通红的紫发女孩，院长赶紧将她领进了门，在她身上发现了一笔钱和一张纸，钱是拿给孤儿院的，纸是给蕾妤留下的。奇怪的是，纸上不仅写了蕾妤的名字和对小蕾妤最后的嘱托，还有对蕾妤的几条预言。</p>
<p>命运是可以改变的吗？蕾妤的出现就是对此最好的解释。</p>
<p>蕾妤第一次发现自己的这种能力是在孤儿院的一次糕点时间，蕾妤现在还记得清清楚楚，那时候幼育员问她“你要饼干还是面包？”</p>
<p>“你要饼干还是面包？”</p>
<p>这个普通人并不会记住太久的问题，却被蕾妤深深地记在了脑海，因为她当时纠结了很久，最后选择饼干，不过，在还没拿到饼干时她就后悔了——因为饼干虽然好吃但明显吃不饱。孤儿院的食物是分配制的，选定的食物一般不能更改。小蕾妤心里想着要是刚刚选面包就好了，那么今天至少不再那么饿了。</p>
<p>就在这时，幼育员居然将面包递给了小蕾妤，小蕾妤胆怯地问道为什么拿给自己面包？幼育员疑惑地回答说难道不是你自己选的吗？然后又开始教导小蕾妤要知足，要对自己的选择负责不能更改，后面又扯到节约粮食什么的，当时的蕾妤只能以为是幼育员阿姨记错了，后来才知道，她那时候，已经穿越世界线了。</p>
<p>这时，那张纸上的第一个预言实现了。</p>
<h2 id="穿越者的降临（二）">穿越者的降临（二）</h2>
<p>叶瑾介回到了寝室，室友们都不在，他觉得很奇怪，按道理现在应该是”峡谷四坑一”时间，四人间寝室的室友应该边扣着脚边冲着电脑屏幕大喊“索利亚噶同！”，但是现在，安静的就像刚才做的梦一般。</p>
<p>叶瑾介本来不是那种多疑的人，一般遇到这种情况除了窃喜然后赶紧打开隐藏文件夹里的某款青春游戏以外，也不会多虑，但也许是今天被灌输了一些不太妙的思想，一个人待着寝室让叶瑾介感到别扭。</p>
<p>叶瑾介摇了摇头，坐在桌子前想要好好休息一下，就在他准备把高数书塞回书架时，一不小心手一滑，书扑通一声掉在地上，滑出了一张卡片。叶瑾介疑惑地捡起卡片查看，背面一排烫金的字体写着“圣鹿蒂亚开发署”，叶瑾介正要翻到另一面时。</p>
<p>“别动。”</p>
<p>叶瑾介听见背后传来一声明显压着喉咙的男性嗓音。</p>
<p>“叶瑾介先生，别想着转过头来。”</p>
<p>声音顿了顿，然后贴在了叶瑾介耳边，悄悄地说。</p>
<p>“我他妈终于找到你了。”</p>
<p>叶瑾介打了个寒战。</p>
<p>叶瑾介连连后退，惊恐地一屁股坐在下铺的床上。</p>
<p>因为转过身来出现在叶瑾介面前的是一个怪人，一个造型奇特的“鸟人”，身高超过了叶瑾介，瘦长的脑袋上是一对深邃漆黑的眼睛，从脑袋的顶部延申到后脑勺耷拉着几根稀疏的白色羽毛，最奇怪的是它那鹰嘴似的鼻子突出在外，整个脸的皮肤像是老大爷手里经常玩弄的核桃那样蜡黄，看着光滑实则沟壑遍布，不知道是因为本来就是怪物还是说是带着面具的人，叶瑾介希望他属于后者。</p>
<p>“鸟人”眉头紧凑在一起，直直地盯着叶瑾介的脸看，像是想要从他脸上找到什么答案。</p>
<p>叶瑾介也毫不放松的盯着他，因为想起了他刚刚说的话，叶瑾介更倾向于他只是个戴着面具的人，叶瑾介想知道是谁在背后装神弄鬼。</p>
<p>“……”。</p>
<p>气氛变得异常安静。</p>
<p>“呃，那个，你好像是他，又好像不是。”</p>
<p>“鸟人”率先打破沉默，用的一串废话。叶瑾介更加证实了自己的观点，这背后不仅是个人，还可能脑袋不灵光。</p>
<p>“鸟人”伸出了手——一只正常人类的手将叶瑾介拉了起来，叶瑾介这时才发现他下半身是一套挺拔的西装，估计价格不菲。</p>
<p>“你找谁？”</p>
<p>叶瑾介本来想大骂他一顿，但是看见他昂贵的西装总感觉自己气势起不来，最后只得不情愿地突出这三个字。</p>
<p>“时间紧迫，来不及解释了。”</p>
<p>鸟人快速地整理了一下衣服，捡起了因为惊吓被叶瑾介摔在地上写有“圣鹿蒂亚开发署”的烫金卡片，随后径直走向叶瑾介寝室的生活阳台，在确认窗子可以无障碍的打开后，满意地回到叶瑾介面前。</p>
<p>“我们得出发了，蕾妤还在等我们。”鸟人抓起叶瑾介的手就往阳台走。</p>
<p>“诶？！等…等等，什么情况！”</p>
<p>叶瑾介思路一片混乱，而且叶瑾介发现这鸟人的力气非常大，自己这样一个虽然从不健身而且运动但是过的肥宅生活的人……仔细想想果然反抗没有任何办法。</p>
<p>叶瑾介很快放弃了抵抗，开始跟他讨价还价。</p>
<p>“这位哥！要不我们先加个微信再相互了解一下？至少先谈谈价格啊！”</p>
<p>叶瑾介知道自己一紧张就说烂话的问题还是改不了。</p>
<p>走到阳台，鸟人猛地停住了，他放开了叶瑾介的手，双手合十，口中念念有词。</p>
<p>正当叶瑾介见鸟人站着不动准备脚底抹油溜之大吉时，那鸟人的西装背部突然被撕开了一条裂缝，从里面迸发出了金色的光芒，叶瑾介努力地睁着眼睛想要看清里面的东西，然后下一秒，里面突然伸出来了一对看着像扳手的东西，和光芒融为一体，变成了一对金黄色的，叶瑾介所熟知的，翅膀。</p>
<p>从小接受唯物主义的叶瑾介，此刻的世界观，碎了。</p>
<h2 id="穿越者的降临（三）">穿越者的降临（三）</h2>
<p>与此同时的另一边，一名紫发少女穿过学校大门前的天桥，然后拐入右手边的小巷，没走多久后停在了一片空地前，这片空地显得非常诡异，诡异的原因在于这一条小巷属于很老的政府批建区，所有建筑都采用的一个建筑设计，因此整条小巷看起来十分整齐统一。虽然现在已经没什么人影，但以前曾是人们茶余饭后最喜欢来闲逛的地方。但现在在建筑群中凭空多出了一片空地，破坏了整条小巷的和谐统一，像是丢失了一片拼图一般。这片空地已经突兀到单让人站在它面前就能够想象到这里应该是个什么样的建筑。</p>
<p>少女挽起学校的制服裙，半蹲下来，仔细察看着这片空地，可是她发现，无论怎么看，空地的地面以及与两旁建筑的交界面始终看不清楚，像是被什么东西所包围了起来，少女站起来思索了片刻然后突然折返，回到了第一个路口，在这里，她抬起头注视着日夜交替不停的红绿灯，目光显得很淡然，似乎在等着什么。</p>
<p>在路口中央被高高悬挂起来的信号控制器没有什么心事可想，它只是忠诚地执行着自己的任务，一遍又一遍，一天又一天。现在，它一如既往收到一串信号，或者说一段电流，指示它应该在这最后五秒将型号切换。</p>
<p>五，四，三，二，一。</p>
<p>绿灯亮起，如同苏醒一般，等待的车辆开始缓慢移动，拥堵的人群开始向街对面扩散，对于大部分人来说，这是再平常不过的一件事了。但是那个少女不见了，迎接她的是一个新世界。</p>
<p><img src="/2021/12/05/%E6%96%B0%E6%B3%BD%E6%B2%A1%E6%9C%89%E5%A4%8F%E5%A4%A9/mmexport1630742263320.jpg" alt></p>
<p>蕾妤站在刚才同样的位置前，但那片空地已经消失不见，取而代之的是一家普通的小店，招牌上写有“万古秘事屋”几个大字，看招牌来说这家店已经有一些历史了。</p>
<p>万古秘事屋这五个字是这里的都市传说的高频词，据说只要运气好，就能碰上一家神秘的委托店，不管你之前遗失了什么东西，都能在这家店通过委托找回，有人找回了被前女友带走的戒指，有人找回了失踪三年的宠物狗，甚至有人找回了坐船时掉入大海的手机——还能开机。</p>
<p>蕾妤透过模糊的橱窗向里看，橱柜摆放着一些像是古董一样的装饰品，屋中隐约有古朴的吊灯向外散发出暖黄色的灯光，显得与旁边的店铺格格不入。</p>
<p>蕾妤稍微的犹豫了一下，推门走了进去。</p>
<p>门咿咿呀呀的在蕾妤的背后合上，最后轻轻嘭的一声卡住门闩。蕾妤走进来的第一感受就是温暖。</p>
<p>眼前是一个不到十平米的小屋，小屋的正中间摆放着一座很大的尖塔，挡住了蕾妤的视线，正对着的是一副欧式古典画，画中是一个男人骑着马高举西洋剑的情景。蕾妤走近那幅画，看见了被尖塔挡住的斜角柜台，柜台里站着一位少女，引人注目的就是她那如绢般的灰色长发以及白皙的面容，透露出一种灵动之美，看起来与蕾妤的年纪相仿，正仔细地擦拭着一个高脚杯，似乎并没有发现蕾妤的到来。</p>
<p>“你好。”蕾妤试着打招呼。</p>
<p>“咦？！”</p>
<p>尽管蕾妤已经尽量地压低声音，少女依然被吓了一跳，手也不自觉抖了一下，高脚杯脱落下来，眼看就要碰到地面却被蕾妤迅速接住了，她用纤细的手指轻轻地弹了一下杯沿，高脚杯随即发出了“叮~”的一声脆响，蕾妤笑了笑，把杯子放回到桌面上。</p>
<p>“谢…谢谢。”少女似乎还没有从惊吓的状态恢复过来。</p>
<p>“这家店装饰的很漂亮哦。”</p>
<p>蕾妤说完这句话后发现柜台旁边摆放着一台挂钟，看起来年代久远，但依然平稳地运作着，钟摆不停的发出“噔，噔，噔…”的声响。</p>
<p>“谢谢夸奖，都是家母设计装饰的这家小店，已经好久没来过客人了，所以刚才的反应真是抱歉。”</p>
<p>少女微笑着向蕾妤说抱歉，看来是已经恢复过来了，收好了高脚杯后注意到了蕾妤的视线，便向她解释到。</p>
<p>“这台挂钟已经坏掉了，家母喜欢听钟摆的声音，便把它留在了这里。”</p>
<p>蕾妤点了一下头表示了解，接着说出了自己的来意。</p>
<p>“初次见面，我的名字叫蕾妤，请问你们是可以帮助找人找物的店铺吗？”</p>
<p>“有幸相识，蕾妤小姐，叫我凛希就好。”</p>
<p>虽然只是站在柜台里，像是充当着服务员的角色，但这位名叫凛希的少女初次见面给蕾妤一种大家闺秀的感觉，有着良好的教养，应该是从小就接受着良好的教育。</p>
<p>“哦？是有委托吗？请移步到内厅详谈吧。”</p>
<p>凛希缓缓走出柜台，将蕾妤引向一个小房间内，凛希帮蕾妤拉开了客椅，自己随后坐在了主位上。</p>
<p>“好香的茶。”</p>
<p>蕾妤刚入座便闻到一股清茶的芳香。</p>
<p>“蕾妤小姐也喜欢喝茶吗？家母喜茶，常说经常喝茶能够改变一个人的气神面貌，我现在也有在试着喝茶了。”</p>
<p>凛希拿出一套紫砂壶，她把茶叶放到器具里，将沸水倒入壶中，让水和茶叶适当接触，然后又迅速倒出，目的应该是去掉茶表面的杂质。她随即把沸水再次倒入壶中，倒水的过程中壶嘴微微向蕾妤点了三下。最后盖上壶盖，用沸水遍浇壶身，称之为“封壶”。</p>
<p>乘着凛希泡茶的间隙，蕾妤粗略地打量了一下这个房间。</p>
<p>房间内陈列的物件并不多，一边是一张原木圆桌配上两把椅子加上一些蒲团，另一边放有一个装满各种书籍信件的书架，似乎是存放档案的地方，中间用屏风相隔离开，形成了两个区域。</p>
<p>“所以蕾妤小姐想要找谁呢？抱歉的是，店中人手不够，平时只有我和家母照料，而家母现在有要事在身，一段时间内回来不了，但是我能帮你写下委托，这样的话家母回来就能及时察看了。”</p>
<p>凛希一边俯身给蕾妤倒茶一边解释到。</p>
<p>“谢谢，不要紧的，凛希小姐，实际上我想拜托你帮我找一个人。”</p>
<p>蕾妤端起茶杯向茶面轻轻地呼气，轻啜了一口茶，感觉肠胃也开始跟着温暖了起来。</p>
<p>“抱歉，家母有令，我不能随便离店。”</p>
<p>凛希面露难色，将双手贴在腿上，对着蕾妤摇了摇头。</p>
<p>“这么多年了，一直是你与令堂两个人在经营这家店吗？”</p>
<p>蕾妤叹了一口气，转换了话题。</p>
<p>“是的，家父很久以前就失踪了，一直以来都是麻烦家母操劳着各种事情。家母一般不会让我插手店铺的事，我都没能帮上什么忙。直到这次家母出门，我才开始出来接待客人。”</p>
<p>提起母亲凛希总是会不自觉的露出微笑，像是十分自豪。</p>
<p>“我小时候身体瘦弱，很少与他人接触，所以即使是现在和陌生人说话都会感到紧张，这次家母突然要让我来招待客人了，我除了兴奋，更多的是犹豫。怕不能做到像家母那样，为此我还专门训练了一段时间，因为我喜欢看书，所以偶尔会独自到附近的大学的图书馆去看书，去尝试融入人群。话说回来，蕾妤小姐是我接待的第一个顾客呢。”</p>
<p>凛希不自觉地说了很多，蕾妤并没有打断她，而是安静地坐在旁边倾听着。</p>
<p>“啊！抱歉，好久没和其他人说过话了，总感觉蕾妤小姐会是个很温柔的人，所以一不小心说了太多了。”</p>
<p>凛希满脸歉意，害羞地对着蕾妤笑了笑。</p>
<p>望着凛希的笑容，蕾妤想到了更多的事。</p>
<p>凛希的母亲和父亲都是圣鹿蒂亚开发署的前成员，凛希的父亲在凛希很小的时候就在一次任务的执行过程中失踪了，从那以后凛希的母亲便带着她离开了开发署,开发署理解她们的决定，从此不再插手她们的生活。</p>
<p>凛希一家并不是普通人，他们本应该是生活在一个子世界的正常人，但不幸的是，这个子世界泡位于两条不断接近彼此的孪生世界线的中间，随着两条世界线的不断挤压，时间、空间发生了错乱，这个子世界泡就被两边强大的吸引力撕碎，这个子世界就这样灭亡了。不过，凛希一家因为却世界线的引力变异，拥有了穿越时间线的能力，他们穿越过了子世界泡灭亡的时间点，幸存了下来。</p>
<p>为了阻止世界线继续相接近，阻止像他们那样的子世界泡灭亡，凛希的父母加入了圣鹿蒂亚开发署。</p>
<p>“诶？蕾妤小姐，是在想什么事情吗？”</p>
<p>凛希的话打断了蕾妤回忆。</p>
<p>“啊…没什么，对了，凛希，你看看这个。”</p>
<p>蕾妤假装把手伸进包里寻找着什么，其实她的包里什么也没有，但神奇是，空间开始出现波纹，空气中凭空凝结出一样东西，显然它并不属于这个世界。</p>
<p>“嗯？！这是家母的戒指？”</p>
<p>看到蕾妤手中的东西，凛希发出一声惊呼，惊讶地想要站起来。</p>
<p>“对，其实我已经见过令堂了，她给我这个东西，告诉我只要给你这个东西，你就能够帮助我的。”</p>
<p>“家母曾说，若是有人带着她的戒指来到我们的店铺，那我就要乖乖地听她的话。”</p>
<p>凛希细细地思索着，像是在回忆着母亲的话。</p>
<p>“那好的，蕾妤小姐，既然家母已经说过，那么我会帮助你的。”</p>
<p>“嗯，那好，那我们就走吧。”</p>
<p>蕾妤站了起来，微笑着对凛希伸出了手。</p>
<p>“还有，不用叫我蕾妤小姐啦，叫我蕾妤就行了。”</p>
<p>“我知道了，蕾妤小…，蕾妤。”</p>
<p>凛希不明白为什么要握手，但望着蕾妤坚定的目光，她也握住了蕾妤的手。</p>
<p>“那么，我应该要去找谁呢？”</p>
<p>面对凛希疑惑的神情，再想到接下来要说出的名字，蕾妤忍不住想笑出来。</p>
<p>“叶瑾介，一个普通人。”</p>
<h2 id="穿越者的降临（四）">穿越者的降临（四）</h2>
<p>“所以……那个……”</p>
<p>心脏狂跳双眼紧闭的叶瑾介脑海里突然出现了鸟人的声音。</p>
<p>“啊？啊！什么？”</p>
<p>叶瑾介闭着眼拼了命地大喊。</p>
<p>“……我说，你不要乱动！再乱动我就只能把你直接甩下去了！”</p>
<p>叶瑾介突然反应过来，他现在被鸟人的双手架在身下，正在新泽市上空滑翔。如果其他人能够看见的话，现在的叶瑾介就像是一只被鸟妈妈叼回家的虫子一样，在注定被分食的路上拼命地扭动的身体。</p>
<p>“喂喂喂！你到底要干啊！”</p>
<p>叶瑾介愤怒地喊向鸟人，语调中包含着一丝恐惧。</p>
<p>“想知道的话，睁开眼睛看看吧。”</p>
<p>脑海再次清晰的传来鸟人的声音，不过这次有故作深沉的嫌疑。叶瑾介冷静了下来，开始照着他的话做，在反复吸气呼气后,他缓缓地睁开了眼睛。</p>
<p>“……？！”</p>
<p>“啊！！这不还是在天上吗？你玩儿我是吗？”</p>
<p>叶瑾介慌乱中摸到一撮毛，思来想去后还是没敢扯下来。</p>
<p>“诶，反应很差嘛，我本来以为你会吓得晕过去的。”</p>
<p>“让你失望了真不好意思，我不恐高的，反而是你，不怕被别人看见吗？”</p>
<p>事实上，叶瑾介不仅不恐高，反而很喜欢去玩一些刺激的游乐项目。他经常去离家不远的一座叫作天香国色的游乐场游玩，当然是一个人。</p>
<p>话说回来，叶瑾介发现鸟人是反着架住他，估计是为了让他更方便说话。不过现在在呼啸的风声中，连叶瑾介自己都听不见自己的声音，不知道鸟人是怎么听清的。</p>
<p>“没事儿，他们看不见我们的。”</p>
<p>“看不见？为什么？”</p>
<p>鸟人的声音听起来满不在乎，叶瑾介很好奇。</p>
<p>“因为我现在和他们不是一个世界线的。他们看不见我。”</p>
<p>“又来了，我搞不懂啊。” 叶瑾介想起了蕾妤 ，“等等，你的意思是他们能看见我咯？！”</p>
<p>安分的虫子突然又挣扎了起来。</p>
<p>也就在这时，一位新泽市的普通市民张先生，正好抬起头来望向天空，微微愣了一会儿，然后撇向别处，发出了一道寻常的叹息。</p>
<p>“唉，眼镜又花了。”</p>
<p>“欸？蕾妤还没给你讲明白吗？”</p>
<p>“我发誓你去听也听不懂的。”</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>随想</category>
      </categories>
      <tags>
        <tag>新泽没有夏天</tag>
      </tags>
  </entry>
  <entry>
    <title>用logisim实现八位可控加减法器</title>
    <url>/2021/12/03/%E7%AC%AC%E4%BA%8C/</url>
    <content><![CDATA[<h1>计算机组成原理实验</h1>
<p>你好，好久不见！吼吼吼吼吼吼吼吼吼吼吼吼吼吼吼，作为第二篇博客，我决定先从一些简单的实验分享开始啦！（实际因为本人是小菜鸡一只的原因。。）</p>
<h2 id="用logisim实现八位可控加减法器">用logisim实现八位可控加减法器</h2>
<h3 id="思路解析：">思路解析：</h3>
<p>要实现八位可控加减法器，采用并行思路，首先需要八个一位全加器，用分流器可以将八位二进制数分离，使得单独每一位用一位全加器来进行相关的运算，然后并行输出，最后用分流器进行还原。</p>
<h3 id="实验过程：">实验过程：</h3>
<p>1、首先进行一位全加器的设置，我们需要准备五个信号量，三个输入，两个输出，其中xi与yi为参加运算的对象，cin代表来自下一位的进位，si代表本位的输出结果，Cout代表向下一位的进位。</p>
<p><img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/%E5%9B%BE%E7%89%871.png" alt="11"></p>
<p>2、设计思路为：先用一个异或门判断xi与yi的和的情况，若异或门为1，则xi+yi==1，此时与cin进位再次进行异或门判断，若异或门为仍1，则说明不产生进位，则si可置1。若第一个异或门与cin的与门为1，则说明产生了进位并且si位为0.当xi与yi的与门为1时，cin也应该置1。经过调试判断，最终如图所示。</p>
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片2.png" style="zoom:50%;">
<p>3、用logisim进行测试，检验是否制作成果，经检验得制作成功。</p>
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片3.png" style="zoom:33%;">
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片4.png" style="zoom:50%;">
<p>4、制作分流器，准备分流器，数据位宽为8的输入，8个数据位宽为1的隧道，将隧道与分流器相连，分流器与8位位宽的输入相连。</p>
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片6.png" style="zoom:50%;">
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片7.png" style="zoom:50%;">
<p>5、同理，准备一个y输入与s输出。</p>
<p><img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/%E5%9B%BE%E7%89%878.png" alt></p>
<p><img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/%E5%9B%BE%E7%89%879.png" alt></p>
<p>6、准备8个一位全加器，一个用于表示加减的输入sub，一个用于检测溢出的of（overflow），一个cout表示最高位的进位。<br>
其基本思路是：利用sub与y输入形成异或门，用于执行加和减时y的不同形态，将异或门的结果与一起并入全加器的两个加位，输出位依次接上s的8个隧道。将8个全加器按照这样的方式链接，最后将一位全加器用进位位连接起来，sub链接至第一个全加器的进位位，这样做的目的是将原本的（x+y）变成（x+y的补码）即为（x+（1+y的反码））。结果连接如下。</p>
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片10.png" style="zoom:80%;">
]]></content>
      <categories>
        <category>学习</category>
        <category>硬件设计</category>
      </categories>
      <tags>
        <tag>logisim</tag>
      </tags>
  </entry>
  <entry>
    <title>零日之恋人</title>
    <url>/2021/12/19/%E9%9B%B6%E6%97%A5%E4%B9%8B%E6%81%8B%E4%BA%BA/</url>
    <content><![CDATA[<p>瑾介不知道葭玟是什么时候计划好的。</p>
<p>他依然活在过去，像个永远长不大的孩子，对爱恨没有那么深刻的认识。</p>
<p>“就算与亥氧分手分手以后……”</p>
<p>葭玟在网络上对着瑾介说。</p>
<p>瑾介不敢想象葭玟是怀着什么样的心情说下去的，他只知道自己的大脑一片空白，有许多的回忆喷涌而出，瑾介闭着眼拼命地想束缚住它们。</p>
<p>“我可能都……”</p>
<p>喷涌到达了极点，瑾介想起他在修脚店切除嵌甲时把甲根连根拔起的最后一刻，旁人都焦急地注视着状况，修脚师傅一头大汗，瑾介痛得呲牙咧嘴也感觉武士拔刀的最后时机已经到来。</p>
<p>“不会吃回头草。”</p>
<p>断了，不过，是嵌甲永远地断在里面了。准备折磨瑾介一辈子。</p>
<p>记忆安分了下来，静静地盘旋在他们主人的周围，希望能够给瑾介些许安慰。</p>
<p>瑾介开始想。</p>
<p>他拼命地想，他撕扯着周围的回忆，想要找到答案。</p>
<p>这些天是为了什么？</p>
<p>为了报复？为了利益？还是说，为了结束？</p>
<p>瑾介又开始怀疑起了自己，又是一次错过或是自作多情？自我意识过剩？还有值得分析下去的必要吗？</p>
<p>这些天的快乐是毋庸置疑的，即使是瑾介自己也无法否认，瑾介感觉自己获得了新生，更像高中那个时候的自己了。</p>
<p>但是瑾介看到的葭玟也是一样的，确实是高中时期的她。</p>
<p>是后来的所有还没发生的她。</p>
<p>瑾介又尝到的那种类似与考试快要结束试卷还没翻页的惊慌无措之感。</p>
<p>时间已经过去了五分钟，瑾介知道必须要说点什么。</p>
<p>他选择了半天，还是选择自己性格导致的必然结果。</p>
<p>“我还是会一直支持你的。”</p>
<p>瑾介本以为自己永远不会再说出这句话，瑾介这是第一次尝试对她给与自己最大的陪伴和交流，瑾介看着葭玟不断的笑容感到满意。</p>
<p>“快去睡觉吧，笨蛋”</p>
<p>瑾介毫无反应，甚至开始感受到丝丝尴尬。</p>
<p>他敢再想吗？他不能再想了，错的，全是错的，谁才是真正的小丑，瑾介想到了什么。总之，不能再想了。</p>
<p>他睁开了眼，看到了自己最不愿意看到的画面。</p>
<p>葭玟在漆黑的屋子里，躺在床上，抱着枕头上，无声地抽泣着。</p>
<p>瑾介看着这幅画面，身体一时动弹不得，他自己也不知道自己在等待着什么。</p>
<p>葭玟坐了起来，背对着瑾介，看起来是那样孤独弱小，然后她的手伸向了手机。</p>
<p>这时瑾介像是被诅咒一般发疯地把这副画面撕得粉碎，直到最后一片碎片落向地面消失不见。然后呆呆地坐在地上，掩面流泪。</p>
<p>旁边的手机显示送达了最新的消息。</p>
<p>“所以……”</p>
<p>“哥哥？”</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>记录</category>
      </categories>
      <tags>
        <tag>时间的恋人</tag>
      </tags>
  </entry>
</search>

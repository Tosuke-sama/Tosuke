<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>用logisim实现4位先行进位</title>
    <url>/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/</url>
    <content><![CDATA[<h3 id="实验目的：">实验目的：</h3>
<p>掌握快速加法器中先行进位的原理，能利用相关知识设计4位先行进位电路，并利用设计的4位先行进位电路构造4位快速加法器，能分析对应电路的时间延迟。</p>
<h3 id="实验结果：">实验结果：</h3>
<img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/图片9.png" style="zoom:80%;">
<h3 id="实验过程及结果分析：">实验过程及结果分析：</h3>
<p>由于串行加法器在每一位的加法时需要等待下一位的进位后才能进行加减，这就导致了时间的大量浪费，如果我们能够提前知道进位（先行进位）的话，这样的话后位的加减不用等着前位的进位，时间将会大大缩短。</p>
<p>所以，有规定为：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/%E5%9B%BE%E7%89%876.png" alt></p>
<p>所以，一位加法的所有进位形态分为进位取消、进位传播、进位产生，在这里我们只关心进位传播与进位产生，列出全加器的运算公式：</p>
<p>$$<br>
Si=ai⊕bi⊕ci;<br>
Ci+1=ai*bi+（ai⊕bi）*ci<br>
$$</p>
<p>这是每一位的结果，根据我们刚才的分类pi（进位传播项）=ai⊕bi、gi（进位产生项）=ai*bi我们可以得到全加器的公式变形：</p>
<p>$$<br>
Si=pi⊕ci;<br>
Ci+1=gi+pi*ci<br>
$$</p>
<p>这就是我们每一位求出来的值，pi、gi都只与ai与bi有关，故我们只需要求出ci即可，但是ci又与上一位ci有关系，我们将所有ci的运算公式列出：</p>
<img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/图片7.png" style="zoom:80%;">
<p>而我们将ci依次带入后一位得：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/%E5%9B%BE%E7%89%878.png" alt></p>
<p>所以现在所有值都只与ai、bi、c0有关了，我们就可以通过ai、bi和c0直接算出每一位的值而不再需要等待进位了。</p>
<p>将p1，g1，c0表示出来:</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/%E5%9B%BE%E7%89%8710.png" alt></p>
<p>用电路表示超前进位即为：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/%E5%9B%BE%E7%89%879.png" alt></p>
<blockquote>
<p>有问题请通过旁边的对话窗口联系京介喔。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
        <category>硬件设计</category>
      </categories>
      <tags>
        <tag>logisim</tag>
      </tags>
  </entry>
  <entry>
    <title>AJAX</title>
    <url>/2022/05/01/AJAX%E2%80%94%E5%86%AC%E6%97%A5%E9%98%BF%E8%B4%BE%E5%85%8B%E6%96%AF%EF%BC%88%E4%BC%AA%EF%BC%89/</url>
    <content><![CDATA[<h1>AJAX，动态刷新网页</h1>
<h1>前言</h1>
<p>学习完xml以及json这两种文件格式后，我们可以开始学习传输这些文件的工具AJAX了。</p>
<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</p>
<p>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。</p>
<p>AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。</p>
<p>AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。</p>
<h1>XMLHttpRequest</h1>
<p>XMLHttpRequest 是 AJAX 的基础，所有现代浏览器均支持 XMLHttpRequest 对象（什么IE就别提了），XMLHttpRequest 用于在后台与服务器交换数据。</p>
<h2 id="创建">创建</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">variable=<span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure>
<p>在学习xml的时候我们就已经讲到如何创建XMlHttpRequest(),</p>
<p>现在来回顾一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadXMLDoc</span>(<span class="params">dname</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)<span class="comment">//判断当前的浏览器版本，一些较为老旧的浏览器（没有window.XMLHttpRequest对象）需要用到else里的方法来创建对象。</span></span><br><span class="line">    &#123;</span><br><span class="line">        xhttp=<span class="keyword">new</span> XMLHttpRequest();<span class="comment">//一般的创建方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        xhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    xhttp.open(<span class="string">&quot;GET&quot;</span>,dname,<span class="literal">false</span>);<span class="comment">//open方法，稍后会讲到。</span></span><br><span class="line">    xhttp.send();</span><br><span class="line">    <span class="keyword">return</span> xhttp.responseXML;<span class="comment">//返回请求对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="向服务器发送请求">向服务器发送请求</h2>
<p>如需将请求发送到服务器，我们使用 <strong>XMLHttpRequest</strong> 对象的 <strong>open()</strong> 和 <strong>send()</strong> 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;ajax_info.txt&quot;,true);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/01/AJAX%E2%80%94%E5%86%AC%E6%97%A5%E9%98%BF%E8%B4%BE%E5%85%8B%E6%96%AF%EF%BC%88%E4%BC%AA%EF%BC%89/image-20220425103850389.png" alt="image-20220425103850389"></p>
<h2 id="open方法选择GET-还是-POST？">open方法选择GET 还是 POST？</h2>
<p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p>
<p>然而，在以下情况中，请使用 POST 请求：</p>
<ul>
<li>不愿使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（POST 没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>
</ul>
<h3 id="如果选择GET请求">如果选择GET请求</h3>
<p>一个简单的GET例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/try/ajax/demo_get.php&quot;</span>,<span class="literal">true</span>);<span class="comment">//三个参数依次是方法、文件在服务器的路径、同异步。</span></span><br><span class="line">xmlhttp.send();<span class="comment">//仅是POST请求时有string参数</span></span><br></pre></td></tr></table></figure>
<p>但这样有可能时服务器上缓存的结果（即文件没有及时得到更改）。</p>
<p>为了避免这种情况，我们向 URL 添加一个唯一的 ID：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/try/ajax/demo_get.php?t=&quot;</span> + <span class="built_in">Math</span>.random(),<span class="literal">true</span>);<span class="comment">//在链接的？后面通常是我们给定的一些参数。</span></span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，我们所添加的参数往往是接口事先规定好了的，即是API接口所规定要求的。</p>
</blockquote>
<h3 id="如果选择POST请求">如果选择POST请求</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;/try/ajax/demo_post.php&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>
<p>得到的效果与GET几乎一样，不过这里需要注意，当我们要向链接发送数据时，不再使用路径后？+数据的格式，需要使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据：</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;/try/ajax/demo_post2.php&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">xmlhttp.send(<span class="string">&quot;fname=Henry&amp;lname=Ford&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="setRequestHeader">setRequestHeader()</h4>
<p>通常在HTTP协议里，客户端像服务器取得某个网页的时候，必须发送一个HTTP协议的头文件， 告诉服务器客户端要下载什么信息以及相关的参数，这就是头文件的作用， setRequestHeader()就是用来设置头文件的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setRequestHeader(header, value);</span><br><span class="line"><span class="comment">//header字符串，请求头。</span></span><br><span class="line"><span class="comment">//value 字符串，值。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果已经存在已此名称命名的http头，则覆盖之。此方法必须在open方法后调用。</p>
</blockquote>
<h2 id="url-服务器上的文件">url - 服务器上的文件</h2>
<p>open() 方法的 <em>url</em> 参数是服务器上文件的地址（要是服务器是自己的话就是文件路径）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;ajax_test.html&quot;</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>该文件可以是任何类型的文件，比如 .txt 和 .xml，或者服务器脚本文件，比如 .asp 和 .php （在传回响应之前，能够在服务器上执行任务）。</p>
<h2 id="异步-True-或-False？">异步 - True 或 False？</h2>
<p>AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。</p>
<p>XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;ajax_test.html&quot;</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>对于 web 开发人员来说，发送异步请求是一个巨大的进步。很多在服务器执行的任务都相当费时。AJAX 出现之前，这可能会引起应用程序挂起或停止。</p>
<p>通过 AJAX，JavaScript 无需等待服务器的响应，而是：</p>
<ul>
<li>在等待服务器响应时执行其他脚本</li>
<li>当响应就绪后对响应进行处理</li>
</ul>
<h2 id="Async-true">Async=true</h2>
<p>当使用 async=true 时，在响应处于 onreadystatechange 事件中的就绪状态时执行的函数，也就是在异步文件已经传输完成时要执行的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;<span class="comment">//这里是用dom更改了网页的任容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/try/ajax/ajax_info.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>
<p>关于这个函数，稍后我们会提到更多。</p>
<h2 id="Async-false">Async = false</h2>
<p>如需使用 async=false，请将 open() 方法中的第三个参数改为 false：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;test1.txt&quot;</span>,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>我们不推荐使用 async=false，但是对于一些小型的请求，也是可以的。</p>
<p>请记住，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。</p>
<blockquote>
<p>**注意：**当您使用 async=false 时，请不要编写 onreadystatechange 函数 - 把代码放到 send() 语句后面即可：</p>
</blockquote>
<h1>服务器响应</h1>
<p>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。</p>
<p><img src="/2022/05/01/AJAX%E2%80%94%E5%86%AC%E6%97%A5%E9%98%BF%E8%B4%BE%E5%85%8B%E6%96%AF%EF%BC%88%E4%BC%AA%EF%BC%89/image-20220425225713978.png" alt="image-20220425225713978"></p>
<h2 id="responseText-属性">responseText 属性</h2>
<p>如果来自服务器的响应并非 XML，请使用 responseText 属性。</p>
<p>responseText 属性返回字符串形式的响应，因此可以这样使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;</span><br></pre></td></tr></table></figure>
<p>直接用dom将html的内容用服务器传来的数据代替。</p>
<h2 id="responseXML-属性">responseXML 属性</h2>
<p>如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 responseXML 属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlDoc=xmlhttp.responseXML;</span><br><span class="line">txt=<span class="string">&quot;&quot;</span>;</span><br><span class="line">x=xmlDoc.getElementsByTagName(<span class="string">&quot;ARTIST&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;x.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    txt=txt + x[i].childNodes[<span class="number">0</span>].nodeValue + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=txt;</span><br></pre></td></tr></table></figure>
<p>返回的xml我们可以利用之前学习的xmldom进行一些读取操作。</p>
<h1>onreadystatechange 事件</h1>
<p>当请求被发送到服务器时，我们需要执行一些基于响应的任务。</p>
<p>每当 readyState 改变时，就会触发 onreadystatechange 事件。</p>
<p>readyState 属性存有 XMLHttpRequest 的状态信息。</p>
<p>下面是 XMLHttpRequest 对象的三个重要的属性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onreadystatechange</td>
<td style="text-align:left">存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。</td>
</tr>
<tr>
<td style="text-align:left">readyState</td>
<td style="text-align:left">存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化                                                              1: 服务器连接已建立                                                       2: 请求已接收                                                                   3: 请求处理中4: 请求已完成，且响应已就绪</td>
</tr>
<tr>
<td style="text-align:left">status</td>
<td style="text-align:left">200: “OK” 404: 未找到页面</td>
</tr>
</tbody>
</table>
<p>相当于我们onreadystatechange函数是个监听函数，每当xmlhttp的 readyState（状态信息）发生改变时，便会执行一次这个函数，所以我们只要在里面写上if条件就可以筛选出特殊情况来执行我们的任务</p>
<p>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">    &#123;  <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 if条件设为readyState 等于 4 且状态为 200 时，表示表示响应已就绪</p>
<blockquote>
<p>onreadystatechange 事件被触发 4 次（0 - 4）, 分别是： 0-1、1-2、2-3、3-4，对应着 readyState 的每个变化。</p>
</blockquote>
<h2 id="使用回调函数吧">使用回调函数吧</h2>
<p>回调函数是一种以参数形式传递给另一个函数的函数。</p>
<blockquote>
<p>简洁：以函数为参数。</p>
</blockquote>
<p>如果您的网站上存在多个 AJAX 任务，那么您应该为创建 XMLHttpRequest 对象编写一个<em>标准</em>的函数，并为每个 AJAX 任务调用该函数。</p>
<p>该函数调用应该包含 URL 以及发生 onreadystatechange 事件时执行的任务（每次调用可能不尽相同）：</p>
<p>就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadXMLDoc</span>(<span class="params">url,cfunc</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span><br><span class="line">  &#123;<span class="comment">// IE7+, Firefox, Chrome, Opera, Safari 代码</span></span><br><span class="line">  xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;<span class="comment">// IE6, IE5 代码</span></span><br><span class="line">  xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">xmlhttp.onreadystatechange=cfunc;</span><br><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,url,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们定义的加载xmldoc的函数的参数列表中添加对onreadystatechange函数的要求，这样我们在加载xml文档的过程中可以一并将我们需要进行的文档操作写了，从而避免一些其他问题。</p>
<h1>AJAX实例</h1>
<h2 id="1、推荐名字（输入框”onkeyup-事件触发）">1、推荐名字（<strong>输入框”onkeyup&quot; 事件触发</strong>）</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHint</span>(<span class="params">str</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xmlhttp;</span><br><span class="line">    <span class="keyword">if</span> (str.length==<span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;txtHint&quot;</span>).innerHTML=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span></span><br><span class="line">        xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// IE6, IE5 浏览器执行代码</span></span><br><span class="line">        xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">&quot;txtHint&quot;</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/try/ajax/gethint.php?q=&quot;</span>+str,<span class="literal">true</span>);</span><br><span class="line">    xmlhttp.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/01/AJAX%E2%80%94%E5%86%AC%E6%97%A5%E9%98%BF%E8%B4%BE%E5%85%8B%E6%96%AF%EF%BC%88%E4%BC%AA%EF%BC%89/image-20220425235330296.png" alt="image-20220425235330296"></p>
<p>实例地址：<a href="https://www.runoob.com/try/try.php?filename=tryajax_suggest">菜鸟教程在线编辑器 (runoob.com)</a></p>
<h2 id="2、AJAX数据库（表单下拉框-onchange-函数触发）">2、AJAX数据库（表单下拉框 onchange 函数触发）</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showCustomer</span>(<span class="params">str</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xmlhttp;    </span><br><span class="line">  <span class="keyword">if</span> (str==<span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;txtHint&quot;</span>).innerHTML=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span></span><br><span class="line">    xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// IE6, IE5 浏览器执行代码</span></span><br><span class="line">    xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">&quot;txtHint&quot;</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/try/ajax/getcustomer.php?q=&quot;</span>+str,<span class="literal">true</span>);</span><br><span class="line">  xmlhttp.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/01/AJAX%E2%80%94%E5%86%AC%E6%97%A5%E9%98%BF%E8%B4%BE%E5%85%8B%E6%96%AF%EF%BC%88%E4%BC%AA%EF%BC%89/image-20220425235512853.png" alt="image-20220425235512853"></p>
<p>实例地址：<a href="https://www.runoob.com/try/try.php?filename=tryajax_database">菜鸟教程在线编辑器 (runoob.com)</a></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>4位快速加法器的设计</title>
    <url>/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="4位快速加法器的设计">4位快速加法器的设计</h2>
<h3 id="实验目的：">实验目的：</h3>
<p>掌握快速加法器中先行进位的原理，能利用相关知识设计4位先行进位电路，并利用设计的4位先行进位电路构造4位快速加法器，能分析对应电路的时间延迟。</p>
<h3 id="实验结果：">实验结果：</h3>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8711.png" alt></p>
<h3 id="实验结果分析：">实验结果分析：</h3>
<p>因为我们已经完成了的4位先行进位，（什么？你没什么印象？<a href="https://tosuke.gitee.io/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/">点我马上传送</a>现在我们可以来来实现4位快速加法器，没错，其实4位快速加法器就是根据我们第三个实验的原理而来，实验三所写的4位先行进位现在在4位快速加法器里是重要的中心电路。</p>
<p>第一步先准备一下我们需要的输入输出：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8712.png" alt></p>
<p>然后对应好我们之前的4位先行进位的电路封装：</p>
<img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/图片13.png" style="zoom:80%;">
<img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/图片14.png" style="zoom:80%;">
<p>确认好我们的电路封装后，那我们先来输入我们的P1、P2等Pi输入，因为</p>
<pre><code>                          **Pi=ai⊕bi  Gi=ai*bi**
</code></pre>
<p>所以我们将xi、yi连上异或门连上电路封装的pi输入，将xi、yi连上与门连上电路封装的gi输入，最后不要忘了连上C0的输入：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8715.png" alt></p>
<p>那我们输入就算完成了，现在来看看电路封装的输出部分，我们电路的电路的输出分别是Ci和p*、g*成组先进函数，又因为我们推出的运算公式中：</p>
<p>​														Si=Pi⊕Ci</p>
<p>所以我们需要将封装电路输出的Ci与Pi连上异或门再输出给Si，由于在上一步已经制造了Pi，所以连接如图：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8716.png" alt></p>
<p>最后连接上代表最高位进位的C4与p*、g*成组先进函数，电路图就链接好了。</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8717.png" alt></p>
<blockquote>
<p>有问题请通过旁边的对话窗口联系京介喔。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
        <category>硬件设计</category>
      </categories>
      <tags>
        <tag>logisim</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS入门小识</title>
    <url>/2022/01/18/CSS%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/</url>
    <content><![CDATA[<blockquote>
<p>更新时间：2022.1.27，css内容的学习需要富有艺术性。。缓慢更新中。。</p>
</blockquote>
<h1>2、选择器</h1>
<h2 id="1、标签选择器">1、标签选择器</h2>
<h2 id="2、类选择器">2、类选择器</h2>
<h2 id="3、id选择器">3、id选择器</h2>
<h1>3、层次选择器</h1>
<h2 id="3-1后代选择器">3.1后代选择器</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">body p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-子选择器">3.2 子选择器</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">body&gt;p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3相邻兄弟选择器">3.3相邻兄弟选择器</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.class + p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4通用兄弟选择器-向下">3.4通用兄弟选择器(向下)</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.class + p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>字体样式</h1>
<h1>文本样式</h1>
<h2 id="1、颜色">1、颜色</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">color：</span><br></pre></td></tr></table></figure>
<h2 id="2、文本对齐的方式">2、文本对齐的方式</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text-align:</span><br></pre></td></tr></table></figure>
<h2 id="3、首行缩进">3、首行缩进</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text-indent:2em(em为一个字)</span><br></pre></td></tr></table></figure>
<h2 id="4、行高">4、行高</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">line-height:(设为容器一样的高度)</span><br></pre></td></tr></table></figure>
<h2 id="5、装饰">5、装饰</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">text-decoration:underline/line-through/overline(上划线、中、下)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">img,span&#123;</span><br><span class="line">vertical-align:middle(img/span居中对齐两个标签)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>超链接去下划线。</p>
<h1>超链接伪类</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.hover&#123;</span><br><span class="line"></span><br><span class="line">&#125;鼠标悬浮效果</span><br><span class="line">a.active&#123;</span><br><span class="line">激活，点击未放开</span><br><span class="line">&#125;</span><br><span class="line">cursor: url(&#x27;img/hammer.ico&#x27;),auto;</span><br><span class="line">鼠标效果</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text-shadow: 阴影颜色 偏移 偏移 模糊</span><br></pre></td></tr></table></figure>
<h1>列表样式</h1>
<p>list-style:<br>
none去掉原点<br>
circle空心圆<br>
decimal数字<br>
square正方形</p>
<h1>边框</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">border: 1px solid red</span><br></pre></td></tr></table></figure>
<h1>背景图片</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">background-repeat：repeat-x/repeat-y/no repeat</span><br><span class="line">背景重复方式</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/18/CSS%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/image-20220119111404781.png" alt="image-20220119111404781"></p>
<h1>渐变</h1>
<p><img src="/2022/01/18/CSS%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/image-20220119112059881.png" alt="image-20220119112059881"></p>
<h1>盒子模型</h1>
<h2 id="什么是盒子模型">什么是盒子模型</h2>
<p><img src="/2022/01/18/CSS%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/image-20220119112515546.png" alt="image-20220119112515546"></p>
<h2 id="边框">边框</h2>
<p>margin+border+padding</p>
<h1>浮动</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h1~h6 p div  列表</span><br></pre></td></tr></table></figure>
<p>行内元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">span img strong。。</span><br></pre></td></tr></table></figure>
<h2 id="display">display</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display:block(行内变块内)</span><br><span class="line">display:inline-block(行内变块内)是块且可以内联</span><br><span class="line">inline（行内）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Babel学习</title>
    <url>/2022/04/26/Babel%E5%B0%8F%E8%AF%86/</url>
    <content><![CDATA[<h1>Babel 简介</h1>
<p>Babel 是一个 JavaScript 编译器，Babel 是一个工具链，主要用于将采用 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。下面列出的是 Babel 能为你做的事情：</p>
<ul>
<li>语法转换</li>
<li>通过 Polyfill 方式在目标环境中添加缺失的特性 （通过引入第三方 polyfill 模块，例如 <a href="https://github.com/zloirock/core-js">core-js</a>）</li>
<li>源码转换（codemods）</li>
</ul>
<p>大概的功能就是帮助我们在旧的浏览器环境中将 <code>ES6+</code> 的代码转换为兼容低版本的 <code>JS</code> 代码。</p>
<p>让我们从一个案例入手来学习Babel。</p>
<p>首先从终端来初始化一个项目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir babel-basic &amp;&amp; cd babel-basic</span><br><span class="line">//创建文件夹并进入</span><br><span class="line">npm init -y</span><br><span class="line">//初始化项目，-y是yes的意思，省略了敲回车的步骤。</span><br><span class="line">mkdir src &amp;&amp; cd src</span><br><span class="line">touch index.js</span><br></pre></td></tr></table></figure>
<h1>@babel/core</h1>
<p>学习 Babel，首先要了解一个叫 @babel/core 的东西，它是 Babel 的核心模块，所以首先要安装这个模块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i --save-dev @babel/core</span><br></pre></td></tr></table></figure>
<p>安装成功之后就可以在我们的代码中使用了，在js中直接引用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&#x27;@babel/core&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h1>@babel/cli</h1>
<p>这是一个终端运行工具，内置的插件，运行你从终端使用 babel 的工具。同样也需要安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i --save-dev @babel/cli</span><br></pre></td></tr></table></figure>
<p>接着，在 src/index.js 中写一段简单代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">() =&gt;</span> <span class="number">1</span>; <span class="comment">// 箭头函数, 返回值为1</span></span><br><span class="line"><span class="built_in">console</span>.log(fn());</span><br></pre></td></tr></table></figure>
<p>用法一：命令行的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./node_modules/.bin/babel src --out-dir lib  </span><br></pre></td></tr></table></figure>
<p>这行代码的意思是：它使用我们设置的<strong>解析方式</strong>来解释 <code>src</code> 目录下的所有 <code>js</code> 文件，并将转换后的每个文件都输出到 <code>lib</code> 目录下。</p>
<blockquote>
<p>也可以利用 npm@5.2.0 所自带的 npm 包运行器将 <code>./node_modules/.bin/babel</code> 命令缩短为 <code>npx babel</code></p>
</blockquote>
<p>注意，大家在使用命令行时可能会用到“因为在此系统上禁止运行脚本”的错误（如下）</p>
<p><img src="/2022/04/26/Babel%E5%B0%8F%E8%AF%86/image-20220505160117375.png" alt="image-20220505160117375"></p>
<p>解决方法如下：</p>
<ul>
<li>管理员身份运行 PowerShell</li>
<li>执行：get-ExecutionPolicy，若显示 Restricted 表示状态是禁止的</li>
<li>执行：set-ExecutionPolicy，会提示输入参数</li>
<li>输入 RemoteSigned 会提示进行选择</li>
<li>输入：Y，回车</li>
</ul>
<p><img src="/2022/04/26/Babel%E5%B0%8F%E8%AF%86/image-20220505160227355.png" alt="image-20220505160227355"></p>
<p>回到正题，我们打开lib文件夹会发现里面的文件与src文件夹里的一模一样，这是因为到目前为止我们并没有设置任何的解析方式，解析最重要的就是<code>--plugins</code> 和 <code>--presets</code> 这两个参数。</p>
<p>不过在那之前，我们先看看我们上面使用过的–out-dir参数，你可以通过 <code>--help</code> 参数来查看命令行工具所能接受的所有参数列表。</p>
<p>这里给大家部分列举一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -f, --filename [filename]                   The filename to use when reading from stdin. This will be used in source-maps, errors etc.</span><br><span class="line">  --presets [list]                            A comma-separated list of preset names.</span><br><span class="line">  --plugins [list]                            A comma-separated list of plugin names.</span><br><span class="line">  --config-file [path]                        Path to a .babelrc file to use.  --env-name [name]                           The name of the &#x27;env&#x27; to use when loading configs and plugins. Defaults to the value of BABEL_ENV, or else NODE_ENV, or else &#x27;development&#x27;.</span><br><span class="line">  --root-mode [mode]                          The project-root resolution mode. One of &#x27;root&#x27; (the default), &#x27;upward&#x27;, or &#x27;upward-optional&#x27;.</span><br><span class="line">  --source-type [script|module]</span><br><span class="line">  --no-babelrc                                Whether or not to look up .babelrc and .babelignore files.</span><br><span class="line">  --ignore [list]                             List of glob paths to **not** compile.</span><br><span class="line">  --only [list]                               List of glob paths to **only** </span><br><span class="line">compile.</span><br><span class="line">  --no-highlight-code                         Enable or disable ANSI syntax highlighting of code frames. (on by default)</span><br></pre></td></tr></table></figure>
<h1>插件（plugins）和预设（preset）</h1>
<h2 id="piugins">piugins</h2>
<p><code>plugins</code> 的本质是一个 <code>js</code> 程序，指示着 <code>Babel</code> 如何转换代码，如何解析代码。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6,Javascript下一代版本答案(二)</title>
    <url>/2022/02/09/ES6-Javascript%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%89%88%E6%9C%AC%E7%AD%94%E6%A1%88-%E4%BA%8C/</url>
    <content><![CDATA[<h1>Symbol</h1>
<p>一种新引入的原始数据类型，表示独一无二的值，定义对象的唯一属性名，另外，ES6所有的数据类型为Number 、 String 、 Boolean 、 Object、 null 和 undefined ，还新增了 Symbol。</p>
<h2 id="用法">用法</h2>
<p>定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy=<span class="built_in">Symbol</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"><span class="comment">//其中的xxx为描述symbol的内容，便于区分不同的symbol类型。</span></span><br></pre></td></tr></table></figure>
<p>不同的写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法1</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;&#125;;</span><br><span class="line">syObject[sy] = <span class="string">&quot;kk&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(syObject);    <span class="comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;</span><br><span class="line">  [sy]: <span class="string">&quot;kk&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(syObject);    <span class="comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法3</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(syObject, sy, &#123;<span class="attr">value</span>: <span class="string">&quot;kk&quot;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(syObject);   <span class="comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="特点">特点</h2>
<p>使用 Symbol 定义常量，这样就可以保证一组常量的值都不相等。避免引发选择错误。</p>
<h2 id="方法">方法</h2>
<h3 id="Symbol-for">Symbol.for()</h3>
<p>会全局搜索是否有含有参数值的symbol类型数据，如果没有将会创造一个新的symbol并登记供搜索（以普通的方法构造的symbol不会被搜索到）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yellow = <span class="built_in">Symbol</span>(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> yellow1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">yellow === yellow1;      <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> yellow2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">yellow1 === yellow2;     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="Symbol-keyFor">Symbol.keyFor()</h3>
<p>直接返回一个Symbol的key值，参数为symbol类型的名称。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yellow1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(yellow1);    <span class="comment">// &quot;Yellow&quot;</span></span><br></pre></td></tr></table></figure>
<h1>Map 与 Set</h1>
<p>Map对象保存键值对，任何对象或是原始值都可以作为一个键或者一个值。可以说，Map比object做的更加彻底，从另一方面来说也印证了随着时代的发展，编程的语法将会不再那么严格，会变得越来越简单，学编程的成本也会大幅下降。</p>
<h2 id="Maps-和-Objects-的区别">Maps 和 Objects 的区别</h2>
<ul>
<li>一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。</li>
<li>Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</li>
<li>Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。</li>
<li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li>
</ul>
<p><img src="/2022/02/09/ES6-Javascript%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%89%88%E6%9C%AC%E7%AD%94%E6%A1%88-%E4%BA%8C/image-20220321090356352.png" alt="图片来自菜鸟教程"></p>
<h2 id="用法-2">用法</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mymap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">var</span> key=<span class="string">&quot;key`s value&quot;</span></span><br><span class="line">mymap.set(key,<span class="string">&quot;value&quot;</span>);<span class="comment">//值不一定是字符串。</span></span><br><span class="line">mymap.get(key);<span class="comment">//mymap.get(&quot;key`s value&quot;)相同。</span></span><br></pre></td></tr></table></figure>
<p>下面来列举几个Map键值对中的key是其他类型的例子：</p>
<p><strong>key是字符串：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">var</span> keyString = <span class="string">&quot;a string&quot;</span>; </span><br><span class="line"> </span><br><span class="line">myMap.set(keyString, <span class="string">&quot;和键&#x27;a string&#x27;关联的值&quot;</span>);</span><br><span class="line"> </span><br><span class="line">myMap.get(keyString);    <span class="comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span></span><br><span class="line">myMap.get(<span class="string">&quot;a string&quot;</span>);   <span class="comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span></span><br><span class="line">                         <span class="comment">// 因为 keyString === &#x27;a string&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>key 是对象</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line"><span class="keyword">var</span> keyObj = &#123;&#125;,   </span><br><span class="line"> myMap.set(keyObj, <span class="string">&quot;和键 keyObj 关联的值&quot;</span>);  myMap.get(keyObj); <span class="comment">// &quot;和键 keyObj 关联的值&quot; myMap.get(&#123;&#125;); // undefined, 因为 keyObj !== &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>key 是函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line"><span class="keyword">var</span> keyFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,  </span><br><span class="line">    <span class="comment">//函数  myMap.set(keyFunc, &quot;和键 keyFunc 关联的值&quot;);  myMap.get(keyFunc); </span></span><br><span class="line">    <span class="comment">// &quot;和键 keyFunc 关联的值&quot; myMap.get(function() &#123;&#125;) </span></span><br><span class="line">    <span class="comment">// undefined, 因为 keyFunc !== function () &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>key 是 NaN</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line">myMap.set(<span class="literal">NaN</span>, <span class="string">&quot;not a number&quot;</span>);  </span><br><span class="line">myMap.get(<span class="literal">NaN</span>); </span><br><span class="line"><span class="comment">// &quot;not a number&quot;  var otherNaN = Number(&quot;foo&quot;); myMap.get(otherNaN); </span></span><br><span class="line"><span class="comment">// &quot;not a number&quot;</span></span><br></pre></td></tr></table></figure>
<p>虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，NaN作为Map的键来说是没有区别的。</p>
<p><strong>Map的迭代</strong></p>
<p>1、for…of</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>);</span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在for循环中使用key和value的组用of对map进行迭代。</span></span><br></pre></td></tr></table></figure>
<p>被在for中用of进行迭代的对象不只是map对象，还有myMap.entries()、myMap.keys()、myMap.values()</p>
<p>等方法。</p>
<h3 id="Map-对象的操作">Map 对象的操作</h3>
<p><strong>Map 与 Array的转换</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> kvArray = [[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象</span></span><br><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(kvArray);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组</span></span><br><span class="line"><span class="keyword">var</span> outArray = <span class="built_in">Array</span>.from(myMap);</span><br></pre></td></tr></table></figure>
<p><strong>Map 的克隆</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]]);</span><br><span class="line"><span class="keyword">var</span> myMap2 = <span class="keyword">new</span> <span class="built_in">Map</span>(myMap1);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(original === clone); </span><br><span class="line"><span class="comment">// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。</span></span><br></pre></td></tr></table></figure>
<p><strong>Map 的合并</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],]);</span><br><span class="line"><span class="keyword">var</span> second = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;uno&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;dos&#x27;</span>]]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three</span></span><br><span class="line"><span class="keyword">var</span> merged = <span class="keyword">new</span> <span class="built_in">Map</span>([...first, ...second]);</span><br></pre></td></tr></table></figure>
<h3 id="Map-的迭代">Map 的迭代</h3>
<p>对 Map 进行遍历，以下两个最高级。</p>
<h4 id="for…of">for…of</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>);</span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="forEach">forEach()</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>); </span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);  </span><br><span class="line"><span class="comment">// 将会显示两个 logs。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot; </span></span><br><span class="line">myMap.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key</span>) </span>&#123;  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value); &#125;, myMap)</span><br></pre></td></tr></table></figure>
<h3 id="Map-对象的操作-2">Map 对象的操作</h3>
<p><strong>Map 与 Array的转换</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> kvArray = [[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]];  </span><br><span class="line"><span class="comment">// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象 </span></span><br><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(kvArray);  </span><br><span class="line"><span class="comment">// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组 </span></span><br><span class="line"><span class="keyword">var</span> outArray = <span class="built_in">Array</span>.from(myMap);</span><br></pre></td></tr></table></figure>
<p><strong>Map 的克隆</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]]); </span><br><span class="line"><span class="keyword">var</span> myMap2 = <span class="keyword">new</span> <span class="built_in">Map</span>(myMap1);  </span><br><span class="line"><span class="built_in">console</span>.log(original === clone);  </span><br><span class="line"><span class="comment">// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。</span></span><br></pre></td></tr></table></figure>
<p><strong>Map 的合并</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],]); </span><br><span class="line"><span class="keyword">var</span> second = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;uno&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;dos&#x27;</span>]]); </span><br><span class="line"><span class="comment">// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three var merged = new Map([...first, ...second]);</span></span><br></pre></td></tr></table></figure>
<h2 id="Set-对象">Set 对象</h2>
<p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p>
<h3 id="Set-中的特殊值">Set 中的特殊值</h3>
<p>Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：</p>
<ul>
<li>+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；</li>
<li>undefined 与 undefined 是恒等的，所以不重复；</li>
<li>NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。</li>
</ul>
<h1>ES6 字符串</h1>
<p>ES6对于字符串本身的indexof来说增加了几个函数：</p>
<h2 id="查找字符串">查找字符串</h2>
<ul>
<li><strong>includes()</strong>：返回布尔值，判断是否找到参数字符串。</li>
<li><strong>startsWith()</strong>：返回布尔值，判断参数字符串是否在原字符串的头部。</li>
<li><strong>endsWith()</strong>：返回布尔值，判断参数字符串是否在原字符串的尾部。</li>
</ul>
<p>以上每个函数都可以接受两个参数，即需要搜索的字符串和起始位置。</p>
<h3 id="字符串重复">字符串重复</h3>
<p>repeat()：返回新的字符串，表示将字符串重复指定次数返回。</p>
<p>参数为重复的次数，如果是小数的话则按照去尾法（向下处理）处理，负数则会报错。</p>
<h3 id="字符串补全">字符串补全</h3>
<ul>
<li><strong>padStart</strong>：返回新的字符串，表示用参数字符串从头部（左侧）补全原字符串。</li>
<li><strong>padEnd</strong>：返回新的字符串，表示用参数字符串从尾部（右侧）补全原字符串。</li>
</ul>
<p>以上两个方法接受两个参数，第一个参数是指定生成的字符串的最小长度，第二个参数是用来补全的字符串。如果没有指定第二个参数，默认用空格填充。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;h&quot;</span>.padStart(<span class="number">5</span>,<span class="string">&quot;o&quot;</span>));  <span class="comment">// &quot;ooooh&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;h&quot;</span>.padEnd(<span class="number">5</span>,<span class="string">&quot;o&quot;</span>));    <span class="comment">// &quot;hoooo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;h&quot;</span>.padStart(<span class="number">5</span>));      <span class="comment">// &quot;    h&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="模板字符串">模板字符串</h3>
<p>模板字符串相当于加强版的字符串，用反引号 <strong>`</strong>,除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。一般用来向字符串中插入变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Mike&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">let</span> info = <span class="string">`My Name is <span class="subst">$&#123;name&#125;</span>,I am <span class="subst">$&#123;age+<span class="number">1</span>&#125;</span> years old next year.`</span></span><br><span class="line"><span class="built_in">console</span>.log(info);</span><br><span class="line"><span class="comment">// My Name is Mike,I am 28 years old next year.</span></span><br></pre></td></tr></table></figure>
<p>以及调用函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;have fun!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> string2= <span class="string">`Game start,<span class="subst">$&#123;f()&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string2);  <span class="comment">// Game start,have fun!</span></span><br></pre></td></tr></table></figure>
<p><strong>注意要点</strong></p>
<p>模板字符串中的换行和空格都是会被保留的，意思是模板看起来是什么样的，他就会以什么样输出。</p>
<h1>ES6数值</h1>
<p>二进制表示法新写法: 前缀 0b 或 0B 。</p>
<p>八进制表示法新写法: 前缀 0o 或 0O 。</p>
<h2 id="Number-对象新方法"><strong>Number 对象新方法</strong></h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite()<span class="comment">//检测数值是否为无限的</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt()<span class="comment">//进制转换，与全局的 parseInt() 函数是同一个函数，默认10进制。</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt(<span class="string">&#x27;0011&#x27;</span>,<span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h2 id="Math-对象的扩展">Math 对象的扩展</h2>
<p>新方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt<span class="comment">//计算一个数的立方根。</span></span><br><span class="line"><span class="built_in">Math</span>.imul<span class="comment">//返回两个数以 32 位带符号整数形式相乘的结果。</span></span><br><span class="line"><span class="built_in">Math</span>.hypot<span class="comment">//用于计算所有参数的平方和的平方根。</span></span><br><span class="line"><span class="built_in">Math</span>.trunc<span class="comment">//放回数字的整数部分。</span></span><br><span class="line"><span class="built_in">Math</span>.sign<span class="comment">//判断数字正负。</span></span><br><span class="line"><span class="built_in">Math</span>.clz32<span class="comment">//用于返回数字的32 位无符号整数形式的前导0的个数。</span></span><br><span class="line"><span class="built_in">Math</span>.fround<span class="comment">//获取数字的32为单精度浮点数形式。</span></span><br></pre></td></tr></table></figure>
<h1>ES6 对象</h1>
<h3 id="属性的简洁表示法">属性的简洁表示法</h3>
<p>ES6允许对象的属性直接写变量，这时候属性名是变量名，属性值是变量值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Amy&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;age, name&#125;;</span><br><span class="line">person   <span class="comment">//&#123;age: 12, name: &quot;Amy&quot;&#125;</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">age</span>: age, <span class="attr">name</span>: name&#125;</span><br></pre></td></tr></table></figure>
<p>方法名也可以简写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">sayHi</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性名表达式">属性名表达式</h3>
<p>ES6允许用表达式作为属性名，但是一定要将表达式放在方括号内。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"> [<span class="string">&quot;he&quot;</span>+<span class="string">&quot;llo&quot;</span>]()&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.hello();  <span class="comment">//&quot;Hi&quot;//hello用表达式表示。</span></span><br></pre></td></tr></table></figure>
<h2 id="对象的拓展运算符">对象的拓展运算符</h2>
<p>拓展运算符（…）用于取出参数对象所有可遍历属性然后拷贝到当前对象（相当于一个复制粘贴）。</p>
<h3 id="基本用法">基本用法</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>, <span class="attr">age</span>: <span class="number">15</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> someone = &#123; ...person &#125;; </span><br><span class="line">someone;  </span><br><span class="line"><span class="comment">//&#123;name: &quot;Amy&quot;, age: 15&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="可用于合并两个对象">可用于合并两个对象</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = &#123;<span class="attr">age</span>: <span class="number">15</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> name = &#123;<span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> person = &#123;...age, ...name&#125;; person;  </span><br><span class="line"><span class="comment">//&#123;age: 15, name: &quot;Amy&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="注意点">注意点</h3>
<p>自定义的属性和拓展运算符对象里面属性的相同的时候，实际属性根据栈结构决定，即后面的会把前面的属性覆盖掉。</p>
<h2 id="对象的新方法">对象的新方法</h2>
<p><strong>Object.assign(target, source_1, ···)</strong></p>
<p>用于将源对象的所有可枚举属性复制到目标对象中，相当于合并对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object2 = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object3 = &#123;<span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target,object2,object3);  </span><br><span class="line"><span class="comment">// 第一个参数是目标对象，后面的参数是源对象</span></span><br><span class="line">target;  <span class="comment">// &#123;a: 1, b: 2, c: 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性（与拓展运算符相同）</li>
<li>如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。</li>
</ul>
<h3 id="Object-is-value1-value2"><a href="http://Object.is">Object.is</a>(value1, value2)</h3>
<p>用来比较两个值是否严格相等，与（===）基本类似。</p>
<h1>ES6 数组</h1>
<h2 id="数组创建">数组创建</h2>
<p><strong>Array.of()</strong></p>
<p>将参数中所有值作为元素形成数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数值可为不同类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>, <span class="literal">true</span>)); <span class="comment">// [1, &#x27;2&#x27;, true]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数为空时返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of()); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p><strong>Array.from()</strong></p>
<p>将类数组对象或可迭代对象转化为数组。</p>
<h2 id="类数组对象">类数组对象</h2>
<p>一个类数组对象必须含有 length 属性，且元素属性名必须是数值或者可转换为数值的字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(&#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, 3]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 没有 length 属性,则返回空数组</span></span><br><span class="line"><span class="keyword">let</span> array = <span class="built_in">Array</span>.from(&#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// []</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 元素属性名不为数值且无法转换为数值，返回长度为 length 元素值为 undefined 的数组  </span></span><br><span class="line"><span class="keyword">let</span> array1 = <span class="built_in">Array</span>.from(&#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array1); <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure>
<h2 id="扩展的方法">扩展的方法</h2>
<h3 id="查找">查找</h3>
<p><strong>find()</strong>；</p>
<p>查找数组中符合条件的元素,若有多个符合条件的元素，则返回第一个元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组空位处理为 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="number">1</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> <span class="literal">true</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于箭头函数（=&gt;），ES6标准新增了一种新的函数：Arrow Function（箭头函数），相当于用item为参数定义了一个函数，然后返回item &gt; 2。</p>
</blockquote>
<p><strong>findIndex()</strong></p>
<p>查找数组中符合条件的元素索引，若有多个符合条件的元素，则返回第一个元素索引。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 参数1：回调函数</span></span><br><span class="line"><span class="comment">// 参数2(可选)：指定回调函数中的 this 值</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item == <span class="number">2</span>)); <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组空位处理为 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="number">1</span>].findIndex(<span class="function"><span class="params">n</span> =&gt;</span> <span class="literal">true</span>)); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<h3 id="填充">填充</h3>
<p><strong>fill()</strong></p>
<p>将一定范围索引的数组元素内容填充为单个指定的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 参数1：用来填充的值</span></span><br><span class="line"><span class="comment">// 参数2：被填充的起始索引</span></span><br><span class="line"><span class="comment">// 参数3(可选)：被填充的结束索引，默认为数组末尾</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.fill(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">// [1, 0, 3, 4]</span></span><br></pre></td></tr></table></figure>
<h3 id="遍历">遍历</h3>
<p><strong>entries()</strong></p>
<p>遍历键值对。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不使用 for... of 循环</span></span><br><span class="line"><span class="keyword">let</span> entries = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, &quot;a&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, &quot;b&quot;]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组含空位</span></span><br><span class="line"><span class="built_in">console</span>.log([...[,<span class="string">&#x27;a&#x27;</span>].entries()]); <span class="comment">// [[0, undefined], [1, &quot;a&quot;]]</span></span><br></pre></td></tr></table></figure>
<p><strong>keys()</strong></p>
<p>遍历键名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组含空位</span></span><br><span class="line"><span class="built_in">console</span>.log([...[,<span class="string">&#x27;a&#x27;</span>].keys()]); <span class="comment">// [0, 1]</span></span><br></pre></td></tr></table></figure>
<h1>ES6 函数</h1>
<h2 id="函数参数的扩展">函数参数的扩展</h2>
<h3 id="默认参数">默认参数</h3>
<p>基本用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name,age=<span class="number">17</span></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(name+<span class="string">&quot;,&quot;</span>+age);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">&quot;Amy&quot;</span>,<span class="number">18</span>);  <span class="comment">// Amy,18</span></span><br><span class="line">fn(<span class="string">&quot;Amy&quot;</span>,<span class="string">&quot;&quot;</span>);  <span class="comment">// Amy,</span></span><br><span class="line">fn(<span class="string">&quot;Amy&quot;</span>);     <span class="comment">// Amy,17</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>与我们平时的用法一致。</p>
</blockquote>
<h3 id="不定参数">不定参数</h3>
<p>不定参数用来表示不确定参数个数，形如，…变量名，由…加上一个具名参数标识符组成。具名参数只能放在参数组的最后，并且有且只有一个不定参数。</p>
<p>基本用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">...values</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(values.length);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>);      <span class="comment">//2</span></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);  <span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<h2 id="箭头函数">箭头函数</h2>
<p>箭头函数提供了一种更加简洁的函数书写方式。基本语法是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">参数 =&gt; 函数体</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>当箭头函数没有参数或者有多个参数，要用 <strong>()</strong> 括起来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b; f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">//8</span></span><br></pre></td></tr></table></figure>
<p>当箭头函数函数体有多行语句，用 <strong>{}</strong> 包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略 <strong>{}</strong> , 结果会自动返回。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123; <span class="keyword">let</span> result = a+b; <span class="keyword">return</span> result; &#125; f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>当箭头函数要返回对象的时候，为了区分于代码块，要用 <strong>()</strong> 将对象包裹起来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">id,name</span>) =&gt;</span> &#123;<span class="attr">id</span>: id, <span class="attr">name</span>: name&#125;; f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// SyntaxError: Unexpected token :  </span></span><br><span class="line"><span class="comment">// 不报错 var f = (id,name) =&gt; (&#123;id: id, name: name&#125;); f(6,2);  </span></span><br><span class="line"><span class="comment">// &#123;id: 6, name: 2&#125;</span></span><br></pre></td></tr></table></figure>
<h1>ES6 Class 类</h1>
<h2 id="概述">概述</h2>
<p>在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。</p>
<p>class 的本质是 function。</p>
<p>它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。</p>
<h2 id="基础用法">基础用法</h2>
<h3 id="类定义">类定义</h3>
<p>类表达式可以为匿名或命名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名类</span></span><br><span class="line"><span class="keyword">let</span> Example = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 命名类</span></span><br><span class="line"><span class="keyword">let</span> Example = <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类声明">类声明</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，类定义不会被提升，这意味着，必须在访问前对类进行定义，否则就会报错。</p>
<p>类中方法不需要 function 关键字。</p>
<p>方法间不能加分号。</p>
<p><strong>方法</strong></p>
<p>constructor 方法</p>
<p>constructor 方法是类的默认方法，创建类的实例化对象时被调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;我是constructor&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Example(); <span class="comment">// 我是constructor</span></span><br></pre></td></tr></table></figure>
<h2 id="封装与继承">封装与继承</h2>
<h3 id="getter-setter">getter / setter</h3>
<p>定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a; <span class="comment">// 实例化时调用 set 方法</span></span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">a</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;getter&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">a</span>(<span class="params">a</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;setter&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.a = a; <span class="comment">// 自身递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> exam = <span class="keyword">new</span> Example(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 不断输出 setter ，最终导致 RangeError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">a</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;getter&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">a</span>(<span class="params">a</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;setter&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>._a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> exam1 = <span class="keyword">new</span> Example1(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 只输出 setter , 不会调用 getter 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(exam1._a); <span class="comment">// 1, 可以直接访问</span></span><br></pre></td></tr></table></figure>
<h3 id="extends">extends</h3>
<p>通过 extends 实现类的继承。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h3 id="super">super</h3>
<p>子类 constructor 方法中必须有 super ，且必须出现在 this 之前。</p>
<p>调用父类方法, super 作为对象，在普通方法中，指向父类的原型对象，在静态方法中，指向父类</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// 调用父类普通方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">super</span>.test()); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">test3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类静态方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.test1+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Child2.test3(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h1>ES6 模块</h1>
<h2 id="特点-2">特点</h2>
<p>ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 <strong>use strict;</strong>。</p>
<p>模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。</p>
<p>每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。</p>
<p>每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----export [test.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> myfn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;My name is&quot;</span> + myName + <span class="string">&quot;! I&#x27;m &#x27;&quot;</span> + myAge + <span class="string">&quot;years old.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myClass =  <span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> a = <span class="string">&quot;yeah!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; myName, myAge, myfn, myClass &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName, myAge, myfn, myClass &#125; <span class="keyword">from</span> <span class="string">&quot;./test.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myfn());<span class="comment">// My name is Tom! I&#x27;m 20 years old.</span></span><br><span class="line"><span class="built_in">console</span>.log(myAge);<span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(myName);<span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(myClass.a );<span class="comment">// yeah!</span></span><br></pre></td></tr></table></figure>
<h3 id="as-的用法">as 的用法</h3>
<p>export 命令导出的接口名称，须和模块内部的变量有一一对应关系。</p>
<p>导入的变量名，须和导出的接口名称相同，即顺序可以不一致。</p>
<p>一般用于重新定义接口名称，隐藏模块内部的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----export [test.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName <span class="keyword">as</span> exportName &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; exportName &#125; <span class="keyword">from</span> <span class="string">&quot;./test.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(exportName);<span class="comment">// Tom</span></span><br><span class="line">使用 <span class="keyword">as</span> 重新定义导出的接口名称，隐藏模块内部的变量</span><br><span class="line"><span class="comment">/*-----export [test1.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName &#125;</span><br><span class="line"><span class="comment">/*-----export [test2.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Jerry&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName &#125;</span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName <span class="keyword">as</span> name1 &#125; <span class="keyword">from</span> <span class="string">&quot;./test1.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; myName <span class="keyword">as</span> name2 &#125; <span class="keyword">from</span> <span class="string">&quot;./test2.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name1);<span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(name2);<span class="comment">// Jerry</span></span><br></pre></td></tr></table></figure>
<h3 id="import-命令的特点">import 命令的特点</h3>
<p><strong>只读属性</strong>：不允许在加载模块的脚本里面，改写接口的引用指向，即可以改写 import 变量类型为对象的属性值，不能改写 import 变量类型为基本类型的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span></span><br><span class="line">a = &#123;&#125;; <span class="comment">// error</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span></span><br><span class="line">a.foo = <span class="string">&quot;hello&quot;</span>; <span class="comment">// a = &#123; foo : &#x27;hello&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>单例模式</strong>：多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。import 同一模块，声明不同接口引用，会声明对应变量，但只执行一次 import 。</p>
<h3 id="export-default-命令">export default 命令</h3>
<ul>
<li>在一个文件或模块中，export、import 可以有多个，export default 仅有一个。</li>
<li>export default 中的 default 是对应的导出接口变量。</li>
<li>通过 export 方式导出，在导入时要加{ }，export default 则不需要。</li>
<li>export default 向外暴露的成员，可以使用任意变量来接收。</li>
</ul>
<h1>ES6 Promise 对象</h1>
<h2 id="概述-2">概述</h2>
<p>是异步编程的一种解决方案。</p>
<p>从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>
<h2 id="Promise-状态">Promise 状态</h2>
<h3 id="状态的特点">状态的特点</h3>
<p>Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。</p>
<p>Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success1&#x27;</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;success2&#x27;</span>);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;  </span><br><span class="line">    resolve(<span class="string">&#x27;success3&#x27;</span>); </span><br><span class="line">    reject(<span class="string">&#x27;reject&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success1</span></span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>已经忘记了promise函数？<a href="https://tosuke.gitee.io/2022/01/20/JavaScript%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/#Promise">点击我回顾</a></p>
</blockquote>
<h1>ES6 Generator 函数</h1>
<p>ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。 基本用法</p>
<h3 id="Generator-函数组成">Generator 函数组成</h3>
<p>Generator 有两个区分于普通函数的部分：</p>
<ul>
<li>一是在 function 后面，函数名之前有个 * ；</li>
<li>函数内部有 yield 表达式。</li>
</ul>
<p>其中 * 用来表示函数为 Generator 函数，yield 用来定义函数内部的状态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;two&quot;</span>);</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;three&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行机制">执行机制</h3>
<p>调用 Generator 函数和调用普通函数一样，在函数名后面加上()即可，但是 Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针，所以要调用遍历器对象Iterator 的 next 方法，指针就会从函数头部或者上一次停下来的地方开始执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f.next();</span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;1&quot;, done: false&#125;</span></span><br><span class="line"> </span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line"> </span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// three</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;3&quot;, done: true&#125;</span></span><br><span class="line"> </span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>第一次调用 next 方法时，从 Generator 函数的头部开始执行，先是打印了 one ,执行到 yield 就停下来，并将yield 后边表达式的值 ‘1’，作为返回对象的 value 属性值，此时函数还没有执行完， 返回对象的 done 属性值是 false。</p>
<p>第二次调用 next 方法时，同上步 。</p>
<p>第三次调用 next 方法时，先是打印了 three ，然后执行了函数的返回操作，并将 return 后面的表达式的值，作为返回对象的 value 属性值，此时函数已经结束，多以 done 属性值为true 。</p>
<p>第四次调用 next 方法时， 此时函数已经执行完了，所以返回 value 属性值是 undefined ，done 属性值是 true 。如果执行第三步时，没有 return 语句的话，就直接返回 {value: undefined, done: true}。</p>
<h1>ES6 async 函数</h1>
<h2 id="async">async</h2>
<p>async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">[param[, param[, ... param]]]</span>) </span>&#123; statements &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>name: 函数名称。</li>
<li>param: 要传递给函数的参数的名称。</li>
<li>statements: 函数体语句。</li>
</ul>
<h2 id="5-3-ES6-async-函数">5.3 ES6 async 函数</h2>
<h3 id="分类-ES6-教程"><em>分类</em> <a href="https://www.runoob.com/w3cnote_genre/es6">ES6 教程</a></h3>
<h2 id="async-2">async</h2>
<p>async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的。</p>
<h3 id="语法">语法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function name([param[, param[, ... param]]]) &#123; statements &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>name: 函数名称。</li>
<li>param: 要传递给函数的参数的名称。</li>
<li>statements: 函数体语句。</li>
</ul>
<h3 id="返回值">返回值</h3>
<p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;helloAsync&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(helloAsync())  <span class="comment">// Promise &#123;&lt;resolved&gt;: &quot;helloAsync&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line">helloAsync().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(v);         <span class="comment">// helloAsync</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架</title>
    <url>/2022/04/18/Express%20%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="Express-简介">Express 简介</h2>
<p>Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。</p>
<p>使用 Express 可以快速地搭建一个完整功能的网站。</p>
<p>Express 框架核心特性：</p>
<ul>
<li>可以设置中间件来响应 HTTP 请求。</li>
<li>定义了路由表用于执行不同的 HTTP 请求动作。</li>
<li>可以通过向模板传递参数来动态渲染 HTML 页面。</li>
</ul>
<h2 id="安装-Express">安装 Express</h2>
<p>安装 Express 并将其保存到依赖列表中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cnpm install express --save</span><br></pre></td></tr></table></figure>
<p>以上命令会将 Express 框架安装在当前目录的 <strong>node_modules</strong> 目录中， <strong>node_modules</strong> 目录下会自动创建 express 目录。以下几个重要的模块是需要与 express 框架一起安装的：</p>
<ul>
<li><strong>body-parser</strong> - node.js 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。</li>
<li><strong>cookie-parser</strong> - 这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。</li>
<li><strong>multer</strong> - node.js 中间件，用于处理 enctype=“multipart/form-data”（设置表单的MIME编码）的表单数据。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cnpm install body-parser --save</span><br><span class="line">$ cnpm install cookie-parser --save</span><br><span class="line">$ cnpm install multer --save</span><br></pre></td></tr></table></figure>
<p>安装完后，我们可以查看下 express 使用的版本号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cnpm list express</span><br><span class="line">/data/www/node</span><br><span class="line">└── express@4.15.2  -&gt; /Users/tianqixin/www/node/node_modules/.4.15.2@express</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意以上均是在淘宝镜像上进行加载的，需要提前安装淘宝镜像，如没有安装也无妨，删除cnpm的c即可。</p>
</blockquote>
<h2 id="第一个-Express-框架实例">第一个 Express 框架实例</h2>
<p>接下来我们使用 Express 框架来输出 “Hello World”。</p>
<p>以下实例中我们引入了 express 模块，并在客户端发起请求后，响应 “Hello World” 字符串。</p>
<p>创建 express_demo.js 文件，代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//express_demo.js 文件</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   res.send(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8081</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> host = server.address().address</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;应用实例，访问地址为 http://%s:%s&quot;</span>, host, port)</span><br><span class="line"> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>执行以上代码后，在浏览器中访问 <a href="http://127.0.0.1:8081">http://127.0.0.1:8081</a>，便可得到服务器返回的hello world。</p>
<h2 id="请求和响应">请求和响应</h2>
<p>Express 应用使用回调函数的参数： <strong>request</strong> 和 <strong>response</strong> 对象来处理请求和响应的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.get(&#x27;/&#x27;, function (req, res) &#123;</span><br><span class="line">   // --</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>request</strong> 和 <strong>response</strong> 对象的具体介绍：</p>
<p><strong>Request 对象</strong> - request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有：</p>
<ol>
<li>req.app：当callback为外部文件时，用req.app访问express的实例</li>
<li>req.baseUrl：获取路由当前安装的URL路径</li>
<li>req.body / req.cookies：获得「请求主体」/ Cookies</li>
<li>req.fresh / req.stale：判断请求是否还「新鲜」</li>
<li>req.hostname / req.ip：获取主机名和IP地址</li>
<li>req.originalUrl：获取原始请求URL</li>
<li>req.params：获取路由的parameters</li>
<li>req.path：获取请求路径</li>
<li>req.protocol：获取协议类型</li>
<li>req.query：获取URL的查询参数串</li>
<li>req.route：获取当前匹配的路由</li>
<li>req.subdomains：获取子域名</li>
<li>req.accepts()：检查可接受的请求的文档类型</li>
<li>req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages：返回指定字符集的第一个可接受字符编码</li>
<li>req.get()：获取指定的HTTP请求头</li>
<li><a href="http://req.is">req.is</a>()：判断请求头Content-Type的MIME类型</li>
</ol>
<p><strong>Response 对象</strong> - response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有：</p>
<ol>
<li>res.app：同req.app一样</li>
<li>res.append()：追加指定HTTP头</li>
<li>res.set()在res.append()后将重置之前设置的头</li>
<li>res.cookie(name，value [，option])：设置Cookie</li>
<li>opition: domain / expires / httpOnly / maxAge / path / secure / signed</li>
<li>res.clearCookie()：清除Cookie</li>
<li>res.download()：传送指定路径的文件</li>
<li>res.get()：返回指定的HTTP头</li>
<li>res.json()：传送JSON响应</li>
<li>res.jsonp()：传送JSONP响应</li>
<li>res.location()：只设置响应的Location HTTP头，不设置状态码或者close response</li>
<li>res.redirect()：设置响应的Location HTTP头，并且设置状态码302</li>
<li>res.render(view,[locals],callback)：渲染一个view，同时向callback传递渲染后的字符串，如果在渲染过程中有错误发生next(err)将会被自动调用。callback将会被传入一个可能发生的错误以及渲染后的页面，这样就不会自动输出了。</li>
<li>res.send()：传送HTTP响应</li>
<li>res.sendFile(path [，options] [，fn])：传送指定路径的文件 -会自动根据文件extension设定Content-Type</li>
<li>res.set()：设置HTTP头，传入object可以一次设置多个头</li>
<li>res.status()：设置HTTP状态码</li>
<li>res.type()：设置Content-Type的MIME类型</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6,Javascript下一代版本答案(一)</title>
    <url>/2022/02/09/ES6-Javascript%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%89%88%E6%9C%AC%E7%AD%94%E6%A1%88/</url>
    <content><![CDATA[<h1>ES6简介</h1>
<p>ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。</p>
<p>ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。</p>
<blockquote>
<p>实际上JavaScript现行最佳的语法规则就是ES6，几乎所有浏览器都支持ES6（除了已经被废弃的IE浏览器）。</p>
</blockquote>
<h2 id="ECMAScript-的背景">ECMAScript 的背景</h2>
<p>JavaScript 是大家所了解的语言名称，但是这个语言名称是商标（ Oracle 公司注册的商标）。因此，JavaScript 的正式名称是 ECMAScript 。1996年11月，JavaScript 的创造者网景公司将 JS 提交给国际化标准组织 ECMA（European computer manufactures association，欧洲计算机制造联合会），希望这种语言能够成为国际标准，随后 ECMA 发布了规定浏览器脚本语言的标准，即 ECMAScript。这也有利于这门语言的开放和中立。</p>
<h1>webpack</h1>
<p>这是一款JavaScript应用程序的打包器，会对JavaScript程序进行分模块的打包，这里暂时不深入探讨。</p>
<h1>let 与 const</h1>
<p>ES6 新增加了两个重要的 JavaScript 关键字: <strong>let</strong> 和 <strong>const</strong>。</p>
<h2 id="let">let</h2>
<h3 id="只代码块内有效">只代码块内有效</h3>
<p>let 声明的变量只在 let 命令所在的代码块内有效，即只在let所在的大括号内有效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;<span class="comment">//仅在大括号内有效。</span></span><br><span class="line">  a   <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line">a   <span class="comment">// 报错 ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>
<p>let 是在代码块内有效，而我们以前常用的var 是在全局范围内有效。</p>
<h3 id="不能重复声明"><strong>不能重复声明</strong></h3>
<p>let 只能声明一次，而var 可以声明多次</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">4</span>;</span><br><span class="line">a  <span class="comment">// Identifier &#x27;a&#x27; has already been declared</span></span><br><span class="line">b  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>for 循环计数器很适合用 let</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环计数器很适合用 <span class="keyword">let</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出十个 10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 0123456789</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实以上代码还牵扯到关于对“任务队列”的理解，用var定义的i为什么会输出十个10？是因为每一次for循环的时候，setTimeout都执行一次， 但是里面的函数没有被执行，而是被放到了任务队列里面，等待执行， for循环了4次，就放了4次，当主线程执行完成后，才进入任务队列里面执行——京介</p>
</blockquote>
<h3 id="不存在变量提升">不存在变量提升</h3>
<p>即let只能先定义声明才能使用，而var可以使用变量后再声明（变量提升）。</p>
<h2 id="const-命令">const 命令</h2>
<p>const命令大家应该很熟悉，类似于c语言的default，const 声明一个只读变量，声明之后不允许改变。意味着，一旦声明必须初始化，否则会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="string">&quot;3.1415926&quot;</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">const</span> age;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<p>ES6 明确规定，代码块内如果存在 let 或者 const，代码块会对这些命令声明的变量从块的开始就形成一个封闭作用域。代码块内，在声明变量 PI 之前使用它会报错。</p>
<h3 id="注意要点">注意要点</h3>
<p>const 如何做到变量在声明初始化之后不允许改变的？其实 const 其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动。此时，你可能已经想到，简单类型和复合类型保存值的方式是不同的。是的，对于简单类型（数值 number、字符串 string 、布尔值 boolean）,值就保存在变量指向的那个内存地址，因此 const 声明的简单类型变量等同于常量。而复杂类型（对象 object，数组 array，函数 function），变量指向的内存地址其实是保存了一个指向实际数据的指针，所以 const 只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了，所以使用 const 声明复杂类型对象时要慎重。</p>
<h1>解构赋值</h1>
<h2 id="概述">概述</h2>
<p>解构赋值是对赋值运算符的扩展。</p>
<p>他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。</p>
<p>在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。</p>
<p>举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure>
<p>是不是一目了然呢？</p>
<p>通俗地说，结构赋值就类似于一种快捷批处理命令，可以f方便我们的代码书写。</p>
<hr>
<h2 id="解构模型">解构模型</h2>
<p>在解构中，有下面两部分参与：</p>
<p>解构的源，解构赋值表达式的右边部分。解构的目标，解构赋值表达式的左边部分。</p>
<p>数组的解构有以下特点模型：</p>
<p><strong>可嵌套</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]]; </span><br><span class="line"><span class="comment">// a = 1 </span></span><br><span class="line"><span class="comment">// b = 2 </span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure>
<p><strong>可忽略</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 3</span></span><br></pre></td></tr></table></figure>
<p><strong>不完全解构</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b] = [];</span><br><span class="line"><span class="comment">// a = 1, b = undefined</span></span><br></pre></td></tr></table></figure>
<p><strong>剩余运算符</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line"><span class="comment">//a = 1 </span></span><br><span class="line"><span class="comment">//b = [2, 3]</span></span><br></pre></td></tr></table></figure>
<p><strong>字符串等</strong></p>
<p>在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。可遍历对象即实现 Iterator 接口的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="comment">// a = &#x27;h&#x27; </span></span><br><span class="line"><span class="comment">// b = &#x27;e&#x27; </span></span><br><span class="line"><span class="comment">// c = &#x27;l&#x27;</span></span><br><span class="line"><span class="comment">// d = &#x27;l&#x27; </span></span><br><span class="line"><span class="comment">// e = &#x27;o&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>解构默认值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">2</span>] = [<span class="literal">undefined</span>]; <span class="comment">// a = 2</span></span><br></pre></td></tr></table></figure>
<p>当解构模式有匹配结果，且匹配结果是 undefined 时，会触发默认值作为返回结果。</p>
<ul>
<li>
<pre><code class="language-js">let [a = 3, b = a] = [];     
// a = 3, b = 3 let [a = 3, b = a] = [1];
// a = 1, b = 1 let [a = 3, b = a] = [1, 2]; 
// a = 1, b = 2
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1、a 与 b 匹配结果为 undefined ，触发默认值：**a = 3; b = a =3**</span><br><span class="line"></span><br><span class="line">2、a 正常解构赋值，匹配结果：a = 1，b 匹配结果 undefined ，触发默认值：**b = a =1**</span><br><span class="line"></span><br><span class="line">3、a 与 b 正常解构赋值，匹配结果：**a = 1，b = 2**</span><br><span class="line"></span><br><span class="line">## 对象模型的解构（Object）</span><br><span class="line"></span><br><span class="line">对象模型也有相应的解构特点模型，这里仅供了解。</span><br><span class="line"></span><br><span class="line">**基本**</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">let &#123; foo, bar &#125; = &#123; foo: &#x27;aaa&#x27;, bar: &#x27;bbb&#x27; &#125;;</span><br><span class="line">// foo = &#x27;aaa&#x27;</span><br><span class="line">// bar = &#x27;bbb&#x27;</span><br><span class="line"> </span><br><span class="line">let &#123; baz : foo &#125; = &#123; baz : &#x27;ddd&#x27; &#125;;</span><br><span class="line">// foo = &#x27;ddd&#x27;</span><br></pre></td></tr></table></figure>

**可嵌套可忽略**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj; </span><br><span class="line"><span class="comment">// x = &#x27;hello&#x27; </span></span><br><span class="line"><span class="comment">// y = &#x27;world&#x27; let obj = &#123;p: [&#x27;hello&#x27;, &#123;y: &#x27;world&#x27;&#125;] &#125;; </span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123;  &#125;] &#125; = obj; </span><br><span class="line"><span class="comment">// x = &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>

**不完全解构**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [&#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;; </span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [&#123; y &#125;, x ] &#125; = obj; </span><br><span class="line"><span class="comment">// x = undefined </span></span><br><span class="line"><span class="comment">// y = &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>

**剩余运算符**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>&#125;; </span><br><span class="line"><span class="comment">// a = 10 </span></span><br><span class="line"><span class="comment">// b = 20 </span></span><br><span class="line"><span class="comment">// rest = &#123;c: 30, d: 40&#125;</span></span><br></pre></td></tr></table></figure>

**解构默认值**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a = <span class="number">10</span>, b = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;; </span><br><span class="line"><span class="comment">// a = 3; b = 5; </span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>: aa = <span class="number">10</span>, <span class="attr">b</span>: bb = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// aa = 3; bb = 5;</span></span><br></pre></td></tr></table></figure>

# Symbol

## 概述

ES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，**最大的用法是用来定义对象的唯一属性名。**

ES6 数据类型除了 Number 、 String 、 Boolean 、 Object、 null 和 undefined ，还新增了 Symbol 。

------

## 基本用法

Symbol 函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象。可以接受一个字符串作为参数，为新创建的 Symbol 提供描述，用来显示在控制台或者作为字符串的时候使用，便于区分。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">&quot;KK&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sy);   <span class="comment">// Symbol(KK)</span></span><br><span class="line"><span class="keyword">typeof</span>(sy);        <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 相同参数 Symbol() 返回的值不相等</span></span><br><span class="line"><span class="keyword">let</span> sy1 = <span class="built_in">Symbol</span>(<span class="string">&quot;kk&quot;</span>); </span><br><span class="line">sy === sy1;       <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

## 使用场景

第一是作为属性名，由于每一个 Symbol 的值都是不相等的，所以 Symbol 作为对象的属性名，可以保证属性不重名。

第二是定义常量，Symbol 的值是唯一的，所以不会出现相同值得常量。

# Symbol

一种新引入的原始数据类型，表示独一无二的值，定义对象的唯一属性名，另外，ES6所有的数据类型为Number 、 String 、 Boolean 、 Object、 null 和 undefined ，还新增了 Symbol。

## 用法

定义：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy=<span class="built_in">Symbol</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"><span class="comment">//其中的xxx为描述symbol的内容，便于区分不同的symbol类型。</span></span><br></pre></td></tr></table></figure>

不同的写法：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法1</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;&#125;;</span><br><span class="line">syObject[sy] = <span class="string">&quot;kk&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(syObject);    <span class="comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;</span><br><span class="line">  [sy]: <span class="string">&quot;kk&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(syObject);    <span class="comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法3</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(syObject, sy, &#123;<span class="attr">value</span>: <span class="string">&quot;kk&quot;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(syObject);   <span class="comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span></span><br></pre></td></tr></table></figure>

## 特点

使用 Symbol 定义常量，这样就可以保证一组常量的值都不相等。避免引发选择错误。

## 方法

### Symbol.for()

会全局搜索是否有含有参数值的symbol类型数据，如果没有将会创造一个新的symbol并登记供搜索（以普通的方法构造的symbol不会被搜索到）。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yellow = <span class="built_in">Symbol</span>(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> yellow1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">yellow === yellow1;      <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> yellow2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">yellow1 === yellow2;     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

### Symbol.keyFor()

直接返回一个Symbol的key值，参数为symbol类型的名称。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yellow1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(yellow1);    <span class="comment">// &quot;Yellow&quot;</span></span><br></pre></td></tr></table></figure>

# Map 与 Set

Map对象保存键值对，任何对象或是原始值都可以作为一个键或者一个值。可以说，Map比object做的更加彻底，从另一方面来说也印证了随着时代的发展，编程的语法将会不再那么严格，会变得越来越简单，学编程的成本也会大幅下降。

## Maps 和 Objects 的区别

- 一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。
- Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。
- Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。
- Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。

![图片来自菜鸟教程](E:/BaiduNetdiskWorkspace/source/image-20220321090356352.png)

## 用法

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mymap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">var</span> key=<span class="string">&quot;key`s value&quot;</span></span><br><span class="line">mymap.set(key,<span class="string">&quot;value&quot;</span>);<span class="comment">//值不一定是字符串。</span></span><br><span class="line">mymap.get(key);<span class="comment">//mymap.get(&quot;key`s value&quot;)相同。</span></span><br></pre></td></tr></table></figure>

下面来列举几个Map键值对中的key是其他类型的例子：

**key是字符串：**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">var</span> keyString = <span class="string">&quot;a string&quot;</span>; </span><br><span class="line"> </span><br><span class="line">myMap.set(keyString, <span class="string">&quot;和键&#x27;a string&#x27;关联的值&quot;</span>);</span><br><span class="line"> </span><br><span class="line">myMap.get(keyString);    <span class="comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span></span><br><span class="line">myMap.get(<span class="string">&quot;a string&quot;</span>);   <span class="comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span></span><br><span class="line">                         <span class="comment">// 因为 keyString === &#x27;a string&#x27;</span></span><br></pre></td></tr></table></figure>

**key 是对象**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line"><span class="keyword">var</span> keyObj = &#123;&#125;,   </span><br><span class="line"> myMap.set(keyObj, <span class="string">&quot;和键 keyObj 关联的值&quot;</span>);  myMap.get(keyObj); <span class="comment">// &quot;和键 keyObj 关联的值&quot; myMap.get(&#123;&#125;); // undefined, 因为 keyObj !== &#123;&#125;</span></span><br></pre></td></tr></table></figure>

**key 是函数**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line"><span class="keyword">var</span> keyFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,  </span><br><span class="line">    <span class="comment">//函数  myMap.set(keyFunc, &quot;和键 keyFunc 关联的值&quot;);  myMap.get(keyFunc); </span></span><br><span class="line">    <span class="comment">// &quot;和键 keyFunc 关联的值&quot; myMap.get(function() &#123;&#125;) </span></span><br><span class="line">    <span class="comment">// undefined, 因为 keyFunc !== function () &#123;&#125;</span></span><br></pre></td></tr></table></figure>

**key 是 NaN**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line">myMap.set(<span class="literal">NaN</span>, <span class="string">&quot;not a number&quot;</span>);  </span><br><span class="line">myMap.get(<span class="literal">NaN</span>); </span><br><span class="line"><span class="comment">// &quot;not a number&quot;  var otherNaN = Number(&quot;foo&quot;); myMap.get(otherNaN); </span></span><br><span class="line"><span class="comment">// &quot;not a number&quot;</span></span><br></pre></td></tr></table></figure>

虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，NaN作为Map的键来说是没有区别的。

**Map的迭代**

1、for...of

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>);</span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在for循环中使用key和value的组用of对map进行迭代。</span></span><br></pre></td></tr></table></figure>

被在for中用of进行迭代的对象不只是map对象，还有myMap.entries()、myMap.keys()、myMap.values()

等方法。

### Map 对象的操作

**Map 与 Array的转换**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> kvArray = [[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象</span></span><br><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(kvArray);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组</span></span><br><span class="line"><span class="keyword">var</span> outArray = <span class="built_in">Array</span>.from(myMap);</span><br></pre></td></tr></table></figure>

**Map 的克隆**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]]);</span><br><span class="line"><span class="keyword">var</span> myMap2 = <span class="keyword">new</span> <span class="built_in">Map</span>(myMap1);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(original === clone); </span><br><span class="line"><span class="comment">// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。</span></span><br></pre></td></tr></table></figure>

**Map 的合并**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],]);</span><br><span class="line"><span class="keyword">var</span> second = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;uno&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;dos&#x27;</span>]]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three</span></span><br><span class="line"><span class="keyword">var</span> merged = <span class="keyword">new</span> <span class="built_in">Map</span>([...first, ...second]);</span><br></pre></td></tr></table></figure>

### Map 的迭代

对 Map 进行遍历，以下两个最高级。

#### for...of

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>);</span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### forEach()

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>); </span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);  </span><br><span class="line"><span class="comment">// 将会显示两个 logs。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot; </span></span><br><span class="line">myMap.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key</span>) </span>&#123;  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value); &#125;, myMap)</span><br></pre></td></tr></table></figure>

### Map 对象的操作

**Map 与 Array的转换**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> kvArray = [[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]];  </span><br><span class="line"><span class="comment">// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象 </span></span><br><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(kvArray);  </span><br><span class="line"><span class="comment">// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组 </span></span><br><span class="line"><span class="keyword">var</span> outArray = <span class="built_in">Array</span>.from(myMap);</span><br></pre></td></tr></table></figure>

**Map 的克隆**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]]); </span><br><span class="line"><span class="keyword">var</span> myMap2 = <span class="keyword">new</span> <span class="built_in">Map</span>(myMap1);  </span><br><span class="line"><span class="built_in">console</span>.log(original === clone);  </span><br><span class="line"><span class="comment">// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。</span></span><br></pre></td></tr></table></figure>

**Map 的合并**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],]); </span><br><span class="line"><span class="keyword">var</span> second = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;uno&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;dos&#x27;</span>]]); </span><br><span class="line"><span class="comment">// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three var merged = new Map([...first, ...second]);</span></span><br></pre></td></tr></table></figure>

## Set 对象

Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。

### Set 中的特殊值

Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：

- +0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；
- undefined 与 undefined 是恒等的，所以不重复；
- NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。

# ES6 字符串

ES6对于字符串本身的indexof来说增加了几个函数：

## 查找字符串

- **includes()**：返回布尔值，判断是否找到参数字符串。
- **startsWith()**：返回布尔值，判断参数字符串是否在原字符串的头部。
- **endsWith()**：返回布尔值，判断参数字符串是否在原字符串的尾部。

以上每个函数都可以接受两个参数，即需要搜索的字符串和起始位置。

### 字符串重复

repeat()：返回新的字符串，表示将字符串重复指定次数返回。

参数为重复的次数，如果是小数的话则按照去尾法（向下处理）处理，负数则会报错。

### 字符串补全

- **padStart**：返回新的字符串，表示用参数字符串从头部（左侧）补全原字符串。
- **padEnd**：返回新的字符串，表示用参数字符串从尾部（右侧）补全原字符串。

以上两个方法接受两个参数，第一个参数是指定生成的字符串的最小长度，第二个参数是用来补全的字符串。如果没有指定第二个参数，默认用空格填充。

例如：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;h&quot;</span>.padStart(<span class="number">5</span>,<span class="string">&quot;o&quot;</span>));  <span class="comment">// &quot;ooooh&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;h&quot;</span>.padEnd(<span class="number">5</span>,<span class="string">&quot;o&quot;</span>));    <span class="comment">// &quot;hoooo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;h&quot;</span>.padStart(<span class="number">5</span>));      <span class="comment">// &quot;    h&quot;</span></span><br></pre></td></tr></table></figure>

### 模板字符串

模板字符串相当于加强版的字符串，用反引号 **`**,除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。一般用来向字符串中插入变量。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Mike&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">let</span> info = <span class="string">`My Name is <span class="subst">$&#123;name&#125;</span>,I am <span class="subst">$&#123;age+<span class="number">1</span>&#125;</span> years old next year.`</span></span><br><span class="line"><span class="built_in">console</span>.log(info);</span><br><span class="line"><span class="comment">// My Name is Mike,I am 28 years old next year.</span></span><br></pre></td></tr></table></figure>

以及调用函数：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;have fun!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> string2= <span class="string">`Game start,<span class="subst">$&#123;f()&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string2);  <span class="comment">// Game start,have fun!</span></span><br></pre></td></tr></table></figure>

**注意要点**

模板字符串中的换行和空格都是会被保留的，意思是模板看起来是什么样的，他就会以什么样输出。

# ES6数值

二进制表示法新写法: 前缀 0b 或 0B 。

八进制表示法新写法: 前缀 0o 或 0O 。

## **Number 对象新方法**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite()<span class="comment">//检测数值是否为无限的</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt()<span class="comment">//进制转换，与全局的 parseInt() 函数是同一个函数，默认10进制。</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt(<span class="string">&#x27;0011&#x27;</span>,<span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

## Math 对象的扩展

新方法：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt<span class="comment">//计算一个数的立方根。</span></span><br><span class="line"><span class="built_in">Math</span>.imul<span class="comment">//返回两个数以 32 位带符号整数形式相乘的结果。</span></span><br><span class="line"><span class="built_in">Math</span>.hypot<span class="comment">//用于计算所有参数的平方和的平方根。</span></span><br><span class="line"><span class="built_in">Math</span>.trunc<span class="comment">//放回数字的整数部分。</span></span><br><span class="line"><span class="built_in">Math</span>.sign<span class="comment">//判断数字正负。</span></span><br><span class="line"><span class="built_in">Math</span>.clz32<span class="comment">//用于返回数字的32 位无符号整数形式的前导0的个数。</span></span><br><span class="line"><span class="built_in">Math</span>.fround<span class="comment">//获取数字的32为单精度浮点数形式。</span></span><br></pre></td></tr></table></figure>

# ES6 对象

### 属性的简洁表示法

ES6允许对象的属性直接写变量，这时候属性名是变量名，属性值是变量值。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Amy&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;age, name&#125;;</span><br><span class="line">person   <span class="comment">//&#123;age: 12, name: &quot;Amy&quot;&#125;</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">age</span>: age, <span class="attr">name</span>: name&#125;</span><br></pre></td></tr></table></figure>

方法名也可以简写：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

等同于

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">sayHi</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 属性名表达式

ES6允许用表达式作为属性名，但是一定要将表达式放在方括号内。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"> [<span class="string">&quot;he&quot;</span>+<span class="string">&quot;llo&quot;</span>]()&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.hello();  <span class="comment">//&quot;Hi&quot;//hello用表达式表示。</span></span><br></pre></td></tr></table></figure>

## 对象的拓展运算符

拓展运算符（...）用于取出参数对象所有可遍历属性然后拷贝到当前对象（相当于一个复制粘贴）。

### 基本用法

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>, <span class="attr">age</span>: <span class="number">15</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> someone = &#123; ...person &#125;; </span><br><span class="line">someone;  </span><br><span class="line"><span class="comment">//&#123;name: &quot;Amy&quot;, age: 15&#125;</span></span><br></pre></td></tr></table></figure>

### 可用于合并两个对象

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = &#123;<span class="attr">age</span>: <span class="number">15</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> name = &#123;<span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> person = &#123;...age, ...name&#125;; person;  </span><br><span class="line"><span class="comment">//&#123;age: 15, name: &quot;Amy&quot;&#125;</span></span><br></pre></td></tr></table></figure>

### 注意点

自定义的属性和拓展运算符对象里面属性的相同的时候，实际属性根据栈结构决定，即后面的会把前面的属性覆盖掉。

## 对象的新方法

**Object.assign(target, source_1, ···)**

用于将源对象的所有可枚举属性复制到目标对象中，相当于合并对象。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object2 = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object3 = &#123;<span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target,object2,object3);  </span><br><span class="line"><span class="comment">// 第一个参数是目标对象，后面的参数是源对象</span></span><br><span class="line">target;  <span class="comment">// &#123;a: 1, b: 2, c: 3</span></span><br></pre></td></tr></table></figure>

- 如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性（与拓展运算符相同）
- 如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。

### Object.is(value1, value2)

用来比较两个值是否严格相等，与（===）基本类似。

# ES6 数组

## 数组创建

**Array.of()**

将参数中所有值作为元素形成数组。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数值可为不同类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>, <span class="literal">true</span>)); <span class="comment">// [1, &#x27;2&#x27;, true]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数为空时返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of()); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

**Array.from()**

将类数组对象或可迭代对象转化为数组。

## 类数组对象

一个类数组对象必须含有 length 属性，且元素属性名必须是数值或者可转换为数值的字符。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(&#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, 3]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 没有 length 属性,则返回空数组</span></span><br><span class="line"><span class="keyword">let</span> array = <span class="built_in">Array</span>.from(&#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// []</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 元素属性名不为数值且无法转换为数值，返回长度为 length 元素值为 undefined 的数组  </span></span><br><span class="line"><span class="keyword">let</span> array1 = <span class="built_in">Array</span>.from(&#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array1); <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure>

## 扩展的方法

### 查找

**find()**；

查找数组中符合条件的元素,若有多个符合条件的元素，则返回第一个元素。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组空位处理为 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="number">1</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> <span class="literal">true</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

&gt; 关于箭头函数（=&gt;），ES6标准新增了一种新的函数：Arrow Function（箭头函数），相当于用item为参数定义了一个函数，然后返回item &gt; 2。

**findIndex()**

查找数组中符合条件的元素索引，若有多个符合条件的元素，则返回第一个元素索引。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 参数1：回调函数</span></span><br><span class="line"><span class="comment">// 参数2(可选)：指定回调函数中的 this 值</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item == <span class="number">2</span>)); <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组空位处理为 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="number">1</span>].findIndex(<span class="function"><span class="params">n</span> =&gt;</span> <span class="literal">true</span>)); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

### 填充

**fill()**

将一定范围索引的数组元素内容填充为单个指定的值。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 参数1：用来填充的值</span></span><br><span class="line"><span class="comment">// 参数2：被填充的起始索引</span></span><br><span class="line"><span class="comment">// 参数3(可选)：被填充的结束索引，默认为数组末尾</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.fill(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">// [1, 0, 3, 4]</span></span><br></pre></td></tr></table></figure>

### 遍历

**entries()**

遍历键值对。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不使用 for... of 循环</span></span><br><span class="line"><span class="keyword">let</span> entries = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, &quot;a&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, &quot;b&quot;]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组含空位</span></span><br><span class="line"><span class="built_in">console</span>.log([...[,<span class="string">&#x27;a&#x27;</span>].entries()]); <span class="comment">// [[0, undefined], [1, &quot;a&quot;]]</span></span><br></pre></td></tr></table></figure>

**keys()**

遍历键名。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组含空位</span></span><br><span class="line"><span class="built_in">console</span>.log([...[,<span class="string">&#x27;a&#x27;</span>].keys()]); <span class="comment">// [0, 1]</span></span><br></pre></td></tr></table></figure>

# ES6 函数

## 函数参数的扩展

### 默认参数

基本用法

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name,age=<span class="number">17</span></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(name+<span class="string">&quot;,&quot;</span>+age);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">&quot;Amy&quot;</span>,<span class="number">18</span>);  <span class="comment">// Amy,18</span></span><br><span class="line">fn(<span class="string">&quot;Amy&quot;</span>,<span class="string">&quot;&quot;</span>);  <span class="comment">// Amy,</span></span><br><span class="line">fn(<span class="string">&quot;Amy&quot;</span>);     <span class="comment">// Amy,17</span></span><br></pre></td></tr></table></figure>

&gt; 与我们平时的用法一致。

### 不定参数

不定参数用来表示不确定参数个数，形如，...变量名，由...加上一个具名参数标识符组成。具名参数只能放在参数组的最后，并且有且只有一个不定参数。

基本用法

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">...values</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(values.length);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>);      <span class="comment">//2</span></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);  <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

## 箭头函数

箭头函数提供了一种更加简洁的函数书写方式。基本语法是：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">参数 =&gt; 函数体</span><br></pre></td></tr></table></figure>

例如：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

当箭头函数没有参数或者有多个参数，要用 **()** 括起来。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b; f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">//8</span></span><br></pre></td></tr></table></figure>

当箭头函数函数体有多行语句，用 **&#123;&#125;** 包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略 **&#123;&#125;** , 结果会自动返回。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123; <span class="keyword">let</span> result = a+b; <span class="keyword">return</span> result; &#125; f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

当箭头函数要返回对象的时候，为了区分于代码块，要用 **()** 将对象包裹起来

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">id,name</span>) =&gt;</span> &#123;<span class="attr">id</span>: id, <span class="attr">name</span>: name&#125;; f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// SyntaxError: Unexpected token :  </span></span><br><span class="line"><span class="comment">// 不报错 var f = (id,name) =&gt; (&#123;id: id, name: name&#125;); f(6,2);  </span></span><br><span class="line"><span class="comment">// &#123;id: 6, name: 2&#125;</span></span><br></pre></td></tr></table></figure>

# ES6 Class 类

## 概述

在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。

class 的本质是 function。

它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。

## 基础用法

### 类定义

类表达式可以为匿名或命名。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名类</span></span><br><span class="line"><span class="keyword">let</span> Example = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 命名类</span></span><br><span class="line"><span class="keyword">let</span> Example = <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 类声明

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

注意，类定义不会被提升，这意味着，必须在访问前对类进行定义，否则就会报错。

类中方法不需要 function 关键字。

方法间不能加分号。

**方法**

constructor 方法

constructor 方法是类的默认方法，创建类的实例化对象时被调用。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;我是constructor&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Example(); <span class="comment">// 我是constructor</span></span><br></pre></td></tr></table></figure>

## 封装与继承

### getter / setter

定义

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a; <span class="comment">// 实例化时调用 set 方法</span></span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">a</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;getter&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">a</span>(<span class="params">a</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;setter&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.a = a; <span class="comment">// 自身递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> exam = <span class="keyword">new</span> Example(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 不断输出 setter ，最终导致 RangeError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">a</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;getter&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">a</span>(<span class="params">a</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;setter&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>._a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> exam1 = <span class="keyword">new</span> Example1(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 只输出 setter , 不会调用 getter 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(exam1._a); <span class="comment">// 1, 可以直接访问</span></span><br></pre></td></tr></table></figure>

### extends

通过 extends 实现类的继承。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

### super

子类 constructor 方法中必须有 super ，且必须出现在 this 之前。

调用父类方法, super 作为对象，在普通方法中，指向父类的原型对象，在静态方法中，指向父类

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// 调用父类普通方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">super</span>.test()); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">test3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类静态方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.test1+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Child2.test3(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

#  ES6 模块

## 特点

ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 **use strict;**。

模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。

每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。

每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----export [test.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> myfn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;My name is&quot;</span> + myName + <span class="string">&quot;! I&#x27;m &#x27;&quot;</span> + myAge + <span class="string">&quot;years old.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myClass =  <span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> a = <span class="string">&quot;yeah!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; myName, myAge, myfn, myClass &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName, myAge, myfn, myClass &#125; <span class="keyword">from</span> <span class="string">&quot;./test.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myfn());<span class="comment">// My name is Tom! I&#x27;m 20 years old.</span></span><br><span class="line"><span class="built_in">console</span>.log(myAge);<span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(myName);<span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(myClass.a );<span class="comment">// yeah!</span></span><br></pre></td></tr></table></figure>

### as 的用法

export 命令导出的接口名称，须和模块内部的变量有一一对应关系。

导入的变量名，须和导出的接口名称相同，即顺序可以不一致。

一般用于重新定义接口名称，隐藏模块内部的变量。 

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----export [test.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName <span class="keyword">as</span> exportName &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; exportName &#125; <span class="keyword">from</span> <span class="string">&quot;./test.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(exportName);<span class="comment">// Tom</span></span><br><span class="line">使用 <span class="keyword">as</span> 重新定义导出的接口名称，隐藏模块内部的变量</span><br><span class="line"><span class="comment">/*-----export [test1.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName &#125;</span><br><span class="line"><span class="comment">/*-----export [test2.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Jerry&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName &#125;</span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName <span class="keyword">as</span> name1 &#125; <span class="keyword">from</span> <span class="string">&quot;./test1.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; myName <span class="keyword">as</span> name2 &#125; <span class="keyword">from</span> <span class="string">&quot;./test2.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name1);<span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(name2);<span class="comment">// Jerry</span></span><br></pre></td></tr></table></figure>

### import 命令的特点

**只读属性**：不允许在加载模块的脚本里面，改写接口的引用指向，即可以改写 import 变量类型为对象的属性值，不能改写 import 变量类型为基本类型的值。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span></span><br><span class="line">a = &#123;&#125;; <span class="comment">// error</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span></span><br><span class="line">a.foo = <span class="string">&quot;hello&quot;</span>; <span class="comment">// a = &#123; foo : &#x27;hello&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

**单例模式**：多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。import 同一模块，声明不同接口引用，会声明对应变量，但只执行一次 import 。

### export default 命令

- 在一个文件或模块中，export、import 可以有多个，export default 仅有一个。
- export default 中的 default 是对应的导出接口变量。
- 通过 export 方式导出，在导入时要加&#123; &#125;，export default 则不需要。
- export default 向外暴露的成员，可以使用任意变量来接收。

# ES6 Promise 对象

## 概述

是异步编程的一种解决方案。

从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。

## Promise 状态

### 状态的特点

Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。

Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success1&#x27;</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;success2&#x27;</span>);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;  </span><br><span class="line">    resolve(<span class="string">&#x27;success3&#x27;</span>); </span><br><span class="line">    reject(<span class="string">&#x27;reject&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success1</span></span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

&gt; 已经忘记了promise函数？[点击我回顾](https://tosuke.gitee.io/2022/01/20/JavaScript%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/#Promise)

# ES6 Generator 函数

ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。 基本用法

### Generator 函数组成

Generator 有两个区分于普通函数的部分：

- 一是在 function 后面，函数名之前有个 * ；
- 函数内部有 yield 表达式。

其中 * 用来表示函数为 Generator 函数，yield 用来定义函数内部的状态。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;two&quot;</span>);</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;three&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 执行机制

调用 Generator 函数和调用普通函数一样，在函数名后面加上()即可，但是 Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针，所以要调用遍历器对象Iterator 的 next 方法，指针就会从函数头部或者上一次停下来的地方开始执行。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f.next();</span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;1&quot;, done: false&#125;</span></span><br><span class="line"> </span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line"> </span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// three</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;3&quot;, done: true&#125;</span></span><br><span class="line"> </span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

第一次调用 next 方法时，从 Generator 函数的头部开始执行，先是打印了 one ,执行到 yield 就停下来，并将yield 后边表达式的值 '1'，作为返回对象的 value 属性值，此时函数还没有执行完， 返回对象的 done 属性值是 false。

第二次调用 next 方法时，同上步 。

第三次调用 next 方法时，先是打印了 three ，然后执行了函数的返回操作，并将 return 后面的表达式的值，作为返回对象的 value 属性值，此时函数已经结束，多以 done 属性值为true 。

第四次调用 next 方法时， 此时函数已经执行完了，所以返回 value 属性值是 undefined ，done 属性值是 true 。如果执行第三步时，没有 return 语句的话，就直接返回 &#123;value: undefined, done: true&#125;。

# ES6 async 函数

## async

async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">[param[, param[, ... param]]]</span>) </span>&#123; statements &#125;</span><br></pre></td></tr></table></figure>

- name: 函数名称。
- param: 要传递给函数的参数的名称。
- statements: 函数体语句。

## 5.3 ES6 async 函数

### *分类* [ES6 教程](https://www.runoob.com/w3cnote_genre/es6)

## async

async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的。

### 语法

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function name([param[, param[, ... param]]]) &#123; statements &#125;</span><br></pre></td></tr></table></figure>

- name: 函数名称。
- param: 要传递给函数的参数的名称。
- statements: 函数体语句。

### 返回值

async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;helloAsync&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(helloAsync())  <span class="comment">// Promise &#123;&lt;resolved&gt;: &quot;helloAsync&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line">helloAsync().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(v);         <span class="comment">// helloAsync</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

# Symbol

一种新引入的原始数据类型，表示独一无二的值，定义对象的唯一属性名，另外，ES6所有的数据类型为Number 、 String 、 Boolean 、 Object、 null 和 undefined ，还新增了 Symbol。

## 用法

定义：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy=<span class="built_in">Symbol</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"><span class="comment">//其中的xxx为描述symbol的内容，便于区分不同的symbol类型。</span></span><br></pre></td></tr></table></figure>

不同的写法：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法1</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;&#125;;</span><br><span class="line">syObject[sy] = <span class="string">&quot;kk&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(syObject);    <span class="comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;</span><br><span class="line">  [sy]: <span class="string">&quot;kk&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(syObject);    <span class="comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法3</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(syObject, sy, &#123;<span class="attr">value</span>: <span class="string">&quot;kk&quot;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(syObject);   <span class="comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span></span><br></pre></td></tr></table></figure>

## 特点

使用 Symbol 定义常量，这样就可以保证一组常量的值都不相等。避免引发选择错误。

## 方法

### Symbol.for()

会全局搜索是否有含有参数值的symbol类型数据，如果没有将会创造一个新的symbol并登记供搜索（以普通的方法构造的symbol不会被搜索到）。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yellow = <span class="built_in">Symbol</span>(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> yellow1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">yellow === yellow1;      <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> yellow2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">yellow1 === yellow2;     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

### Symbol.keyFor()

直接返回一个Symbol的key值，参数为symbol类型的名称。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yellow1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(yellow1);    <span class="comment">// &quot;Yellow&quot;</span></span><br></pre></td></tr></table></figure>

# Map 与 Set

Map对象保存键值对，任何对象或是原始值都可以作为一个键或者一个值。可以说，Map比object做的更加彻底，从另一方面来说也印证了随着时代的发展，编程的语法将会不再那么严格，会变得越来越简单，学编程的成本也会大幅下降。

## Maps 和 Objects 的区别

- 一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。
- Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。
- Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。
- Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。

![图片来自菜鸟教程](E:/BaiduNetdiskWorkspace/source/image-20220321090356352.png)

## 用法

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mymap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">var</span> key=<span class="string">&quot;key`s value&quot;</span></span><br><span class="line">mymap.set(key,<span class="string">&quot;value&quot;</span>);<span class="comment">//值不一定是字符串。</span></span><br><span class="line">mymap.get(key);<span class="comment">//mymap.get(&quot;key`s value&quot;)相同。</span></span><br></pre></td></tr></table></figure>

下面来列举几个Map键值对中的key是其他类型的例子：

**key是字符串：**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">var</span> keyString = <span class="string">&quot;a string&quot;</span>; </span><br><span class="line"> </span><br><span class="line">myMap.set(keyString, <span class="string">&quot;和键&#x27;a string&#x27;关联的值&quot;</span>);</span><br><span class="line"> </span><br><span class="line">myMap.get(keyString);    <span class="comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span></span><br><span class="line">myMap.get(<span class="string">&quot;a string&quot;</span>);   <span class="comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span></span><br><span class="line">                         <span class="comment">// 因为 keyString === &#x27;a string&#x27;</span></span><br></pre></td></tr></table></figure>

**key 是对象**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line"><span class="keyword">var</span> keyObj = &#123;&#125;,   </span><br><span class="line"> myMap.set(keyObj, <span class="string">&quot;和键 keyObj 关联的值&quot;</span>);  myMap.get(keyObj); <span class="comment">// &quot;和键 keyObj 关联的值&quot; myMap.get(&#123;&#125;); // undefined, 因为 keyObj !== &#123;&#125;</span></span><br></pre></td></tr></table></figure>

**key 是函数**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line"><span class="keyword">var</span> keyFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,  </span><br><span class="line">    <span class="comment">//函数  myMap.set(keyFunc, &quot;和键 keyFunc 关联的值&quot;);  myMap.get(keyFunc); </span></span><br><span class="line">    <span class="comment">// &quot;和键 keyFunc 关联的值&quot; myMap.get(function() &#123;&#125;) </span></span><br><span class="line">    <span class="comment">// undefined, 因为 keyFunc !== function () &#123;&#125;</span></span><br></pre></td></tr></table></figure>

**key 是 NaN**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line">myMap.set(<span class="literal">NaN</span>, <span class="string">&quot;not a number&quot;</span>);  </span><br><span class="line">myMap.get(<span class="literal">NaN</span>); </span><br><span class="line"><span class="comment">// &quot;not a number&quot;  var otherNaN = Number(&quot;foo&quot;); myMap.get(otherNaN); </span></span><br><span class="line"><span class="comment">// &quot;not a number&quot;</span></span><br></pre></td></tr></table></figure>

虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，NaN作为Map的键来说是没有区别的。

**Map的迭代**

1、for...of

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>);</span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在for循环中使用key和value的组用of对map进行迭代。</span></span><br></pre></td></tr></table></figure>

被在for中用of进行迭代的对象不只是map对象，还有myMap.entries()、myMap.keys()、myMap.values()

等方法。

### Map 对象的操作

**Map 与 Array的转换**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> kvArray = [[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象</span></span><br><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(kvArray);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组</span></span><br><span class="line"><span class="keyword">var</span> outArray = <span class="built_in">Array</span>.from(myMap);</span><br></pre></td></tr></table></figure>

**Map 的克隆**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]]);</span><br><span class="line"><span class="keyword">var</span> myMap2 = <span class="keyword">new</span> <span class="built_in">Map</span>(myMap1);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(original === clone); </span><br><span class="line"><span class="comment">// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。</span></span><br></pre></td></tr></table></figure>

**Map 的合并**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],]);</span><br><span class="line"><span class="keyword">var</span> second = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;uno&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;dos&#x27;</span>]]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three</span></span><br><span class="line"><span class="keyword">var</span> merged = <span class="keyword">new</span> <span class="built_in">Map</span>([...first, ...second]);</span><br></pre></td></tr></table></figure>

### Map 的迭代

对 Map 进行遍历，以下两个最高级。

#### for...of

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>);</span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### forEach()

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>); </span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);  </span><br><span class="line"><span class="comment">// 将会显示两个 logs。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot; </span></span><br><span class="line">myMap.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key</span>) </span>&#123;  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value); &#125;, myMap)</span><br></pre></td></tr></table></figure>

### Map 对象的操作

**Map 与 Array的转换**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> kvArray = [[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]];  </span><br><span class="line"><span class="comment">// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象 </span></span><br><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(kvArray);  </span><br><span class="line"><span class="comment">// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组 </span></span><br><span class="line"><span class="keyword">var</span> outArray = <span class="built_in">Array</span>.from(myMap);</span><br></pre></td></tr></table></figure>

**Map 的克隆**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]]); </span><br><span class="line"><span class="keyword">var</span> myMap2 = <span class="keyword">new</span> <span class="built_in">Map</span>(myMap1);  </span><br><span class="line"><span class="built_in">console</span>.log(original === clone);  </span><br><span class="line"><span class="comment">// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。</span></span><br></pre></td></tr></table></figure>

**Map 的合并**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],]); </span><br><span class="line"><span class="keyword">var</span> second = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;uno&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;dos&#x27;</span>]]); </span><br><span class="line"><span class="comment">// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three var merged = new Map([...first, ...second]);</span></span><br></pre></td></tr></table></figure>

## Set 对象

Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。

### Set 中的特殊值

Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：

- +0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；
- undefined 与 undefined 是恒等的，所以不重复；
- NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。

# ES6 字符串

ES6对于字符串本身的indexof来说增加了几个函数：

## 查找字符串

- **includes()**：返回布尔值，判断是否找到参数字符串。
- **startsWith()**：返回布尔值，判断参数字符串是否在原字符串的头部。
- **endsWith()**：返回布尔值，判断参数字符串是否在原字符串的尾部。

以上每个函数都可以接受两个参数，即需要搜索的字符串和起始位置。

### 字符串重复

repeat()：返回新的字符串，表示将字符串重复指定次数返回。

参数为重复的次数，如果是小数的话则按照去尾法（向下处理）处理，负数则会报错。

### 字符串补全

- **padStart**：返回新的字符串，表示用参数字符串从头部（左侧）补全原字符串。
- **padEnd**：返回新的字符串，表示用参数字符串从尾部（右侧）补全原字符串。

以上两个方法接受两个参数，第一个参数是指定生成的字符串的最小长度，第二个参数是用来补全的字符串。如果没有指定第二个参数，默认用空格填充。

例如：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;h&quot;</span>.padStart(<span class="number">5</span>,<span class="string">&quot;o&quot;</span>));  <span class="comment">// &quot;ooooh&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;h&quot;</span>.padEnd(<span class="number">5</span>,<span class="string">&quot;o&quot;</span>));    <span class="comment">// &quot;hoooo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;h&quot;</span>.padStart(<span class="number">5</span>));      <span class="comment">// &quot;    h&quot;</span></span><br></pre></td></tr></table></figure>

### 模板字符串

模板字符串相当于加强版的字符串，用反引号 **`**,除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。一般用来向字符串中插入变量。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Mike&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">let</span> info = <span class="string">`My Name is <span class="subst">$&#123;name&#125;</span>,I am <span class="subst">$&#123;age+<span class="number">1</span>&#125;</span> years old next year.`</span></span><br><span class="line"><span class="built_in">console</span>.log(info);</span><br><span class="line"><span class="comment">// My Name is Mike,I am 28 years old next year.</span></span><br></pre></td></tr></table></figure>

以及调用函数：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;have fun!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> string2= <span class="string">`Game start,<span class="subst">$&#123;f()&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string2);  <span class="comment">// Game start,have fun!</span></span><br></pre></td></tr></table></figure>

**注意要点**

模板字符串中的换行和空格都是会被保留的，意思是模板看起来是什么样的，他就会以什么样输出。

# ES6数值

二进制表示法新写法: 前缀 0b 或 0B 。

八进制表示法新写法: 前缀 0o 或 0O 。

## **Number 对象新方法**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite()<span class="comment">//检测数值是否为无限的</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt()<span class="comment">//进制转换，与全局的 parseInt() 函数是同一个函数，默认10进制。</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt(<span class="string">&#x27;0011&#x27;</span>,<span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

## Math 对象的扩展

新方法：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt<span class="comment">//计算一个数的立方根。</span></span><br><span class="line"><span class="built_in">Math</span>.imul<span class="comment">//返回两个数以 32 位带符号整数形式相乘的结果。</span></span><br><span class="line"><span class="built_in">Math</span>.hypot<span class="comment">//用于计算所有参数的平方和的平方根。</span></span><br><span class="line"><span class="built_in">Math</span>.trunc<span class="comment">//放回数字的整数部分。</span></span><br><span class="line"><span class="built_in">Math</span>.sign<span class="comment">//判断数字正负。</span></span><br><span class="line"><span class="built_in">Math</span>.clz32<span class="comment">//用于返回数字的32 位无符号整数形式的前导0的个数。</span></span><br><span class="line"><span class="built_in">Math</span>.fround<span class="comment">//获取数字的32为单精度浮点数形式。</span></span><br></pre></td></tr></table></figure>

# ES6 对象

### 属性的简洁表示法

ES6允许对象的属性直接写变量，这时候属性名是变量名，属性值是变量值。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Amy&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;age, name&#125;;</span><br><span class="line">person   <span class="comment">//&#123;age: 12, name: &quot;Amy&quot;&#125;</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">age</span>: age, <span class="attr">name</span>: name&#125;</span><br></pre></td></tr></table></figure>

方法名也可以简写：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

等同于

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">sayHi</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 属性名表达式

ES6允许用表达式作为属性名，但是一定要将表达式放在方括号内。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"> [<span class="string">&quot;he&quot;</span>+<span class="string">&quot;llo&quot;</span>]()&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.hello();  <span class="comment">//&quot;Hi&quot;//hello用表达式表示。</span></span><br></pre></td></tr></table></figure>

## 对象的拓展运算符

拓展运算符（...）用于取出参数对象所有可遍历属性然后拷贝到当前对象（相当于一个复制粘贴）。

### 基本用法

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>, <span class="attr">age</span>: <span class="number">15</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> someone = &#123; ...person &#125;; </span><br><span class="line">someone;  </span><br><span class="line"><span class="comment">//&#123;name: &quot;Amy&quot;, age: 15&#125;</span></span><br></pre></td></tr></table></figure>

### 可用于合并两个对象

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = &#123;<span class="attr">age</span>: <span class="number">15</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> name = &#123;<span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> person = &#123;...age, ...name&#125;; person;  </span><br><span class="line"><span class="comment">//&#123;age: 15, name: &quot;Amy&quot;&#125;</span></span><br></pre></td></tr></table></figure>

### 注意点

自定义的属性和拓展运算符对象里面属性的相同的时候，实际属性根据栈结构决定，即后面的会把前面的属性覆盖掉。

## 对象的新方法

**Object.assign(target, source_1, ···)**

用于将源对象的所有可枚举属性复制到目标对象中，相当于合并对象。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object2 = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object3 = &#123;<span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target,object2,object3);  </span><br><span class="line"><span class="comment">// 第一个参数是目标对象，后面的参数是源对象</span></span><br><span class="line">target;  <span class="comment">// &#123;a: 1, b: 2, c: 3</span></span><br></pre></td></tr></table></figure>

- 如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性（与拓展运算符相同）
- 如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。

### Object.is(value1, value2)

用来比较两个值是否严格相等，与（===）基本类似。

# ES6 数组

## 数组创建

**Array.of()**

将参数中所有值作为元素形成数组。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数值可为不同类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>, <span class="literal">true</span>)); <span class="comment">// [1, &#x27;2&#x27;, true]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数为空时返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of()); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

**Array.from()**

将类数组对象或可迭代对象转化为数组。

## 类数组对象

一个类数组对象必须含有 length 属性，且元素属性名必须是数值或者可转换为数值的字符。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(&#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, 3]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 没有 length 属性,则返回空数组</span></span><br><span class="line"><span class="keyword">let</span> array = <span class="built_in">Array</span>.from(&#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// []</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 元素属性名不为数值且无法转换为数值，返回长度为 length 元素值为 undefined 的数组  </span></span><br><span class="line"><span class="keyword">let</span> array1 = <span class="built_in">Array</span>.from(&#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array1); <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure>

## 扩展的方法

### 查找

**find()**；

查找数组中符合条件的元素,若有多个符合条件的元素，则返回第一个元素。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组空位处理为 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="number">1</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> <span class="literal">true</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

&gt; 关于箭头函数（=&gt;），ES6标准新增了一种新的函数：Arrow Function（箭头函数），相当于用item为参数定义了一个函数，然后返回item &gt; 2。

**findIndex()**

查找数组中符合条件的元素索引，若有多个符合条件的元素，则返回第一个元素索引。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 参数1：回调函数</span></span><br><span class="line"><span class="comment">// 参数2(可选)：指定回调函数中的 this 值</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item == <span class="number">2</span>)); <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组空位处理为 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="number">1</span>].findIndex(<span class="function"><span class="params">n</span> =&gt;</span> <span class="literal">true</span>)); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

### 填充

**fill()**

将一定范围索引的数组元素内容填充为单个指定的值。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 参数1：用来填充的值</span></span><br><span class="line"><span class="comment">// 参数2：被填充的起始索引</span></span><br><span class="line"><span class="comment">// 参数3(可选)：被填充的结束索引，默认为数组末尾</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.fill(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">// [1, 0, 3, 4]</span></span><br></pre></td></tr></table></figure>

### 遍历

**entries()**

遍历键值对。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不使用 for... of 循环</span></span><br><span class="line"><span class="keyword">let</span> entries = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, &quot;a&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, &quot;b&quot;]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组含空位</span></span><br><span class="line"><span class="built_in">console</span>.log([...[,<span class="string">&#x27;a&#x27;</span>].entries()]); <span class="comment">// [[0, undefined], [1, &quot;a&quot;]]</span></span><br></pre></td></tr></table></figure>

**keys()**

遍历键名。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组含空位</span></span><br><span class="line"><span class="built_in">console</span>.log([...[,<span class="string">&#x27;a&#x27;</span>].keys()]); <span class="comment">// [0, 1]</span></span><br></pre></td></tr></table></figure>

# ES6 函数

## 函数参数的扩展

### 默认参数

基本用法

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name,age=<span class="number">17</span></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(name+<span class="string">&quot;,&quot;</span>+age);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">&quot;Amy&quot;</span>,<span class="number">18</span>);  <span class="comment">// Amy,18</span></span><br><span class="line">fn(<span class="string">&quot;Amy&quot;</span>,<span class="string">&quot;&quot;</span>);  <span class="comment">// Amy,</span></span><br><span class="line">fn(<span class="string">&quot;Amy&quot;</span>);     <span class="comment">// Amy,17</span></span><br></pre></td></tr></table></figure>

&gt; 与我们平时的用法一致。

### 不定参数

不定参数用来表示不确定参数个数，形如，...变量名，由...加上一个具名参数标识符组成。具名参数只能放在参数组的最后，并且有且只有一个不定参数。

基本用法

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">...values</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(values.length);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>);      <span class="comment">//2</span></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);  <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

## 箭头函数

箭头函数提供了一种更加简洁的函数书写方式。基本语法是：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">参数 =&gt; 函数体</span><br></pre></td></tr></table></figure>

例如：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

当箭头函数没有参数或者有多个参数，要用 **()** 括起来。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b; f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">//8</span></span><br></pre></td></tr></table></figure>

当箭头函数函数体有多行语句，用 **&#123;&#125;** 包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略 **&#123;&#125;** , 结果会自动返回。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123; <span class="keyword">let</span> result = a+b; <span class="keyword">return</span> result; &#125; f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

当箭头函数要返回对象的时候，为了区分于代码块，要用 **()** 将对象包裹起来

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">id,name</span>) =&gt;</span> &#123;<span class="attr">id</span>: id, <span class="attr">name</span>: name&#125;; f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// SyntaxError: Unexpected token :  </span></span><br><span class="line"><span class="comment">// 不报错 var f = (id,name) =&gt; (&#123;id: id, name: name&#125;); f(6,2);  </span></span><br><span class="line"><span class="comment">// &#123;id: 6, name: 2&#125;</span></span><br></pre></td></tr></table></figure>

# ES6 Class 类

## 概述

在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。

class 的本质是 function。

它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。

## 基础用法

### 类定义

类表达式可以为匿名或命名。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名类</span></span><br><span class="line"><span class="keyword">let</span> Example = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 命名类</span></span><br><span class="line"><span class="keyword">let</span> Example = <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 类声明

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

注意，类定义不会被提升，这意味着，必须在访问前对类进行定义，否则就会报错。

类中方法不需要 function 关键字。

方法间不能加分号。

**方法**

constructor 方法

constructor 方法是类的默认方法，创建类的实例化对象时被调用。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;我是constructor&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Example(); <span class="comment">// 我是constructor</span></span><br></pre></td></tr></table></figure>

## 封装与继承

### getter / setter

定义

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a; <span class="comment">// 实例化时调用 set 方法</span></span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">a</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;getter&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">a</span>(<span class="params">a</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;setter&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.a = a; <span class="comment">// 自身递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> exam = <span class="keyword">new</span> Example(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 不断输出 setter ，最终导致 RangeError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">a</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;getter&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">a</span>(<span class="params">a</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;setter&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>._a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> exam1 = <span class="keyword">new</span> Example1(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 只输出 setter , 不会调用 getter 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(exam1._a); <span class="comment">// 1, 可以直接访问</span></span><br></pre></td></tr></table></figure>

### extends

通过 extends 实现类的继承。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

### super

子类 constructor 方法中必须有 super ，且必须出现在 this 之前。

调用父类方法, super 作为对象，在普通方法中，指向父类的原型对象，在静态方法中，指向父类

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// 调用父类普通方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">super</span>.test()); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">test3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类静态方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.test1+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Child2.test3(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

#  ES6 模块

## 特点

ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 **use strict;**。

模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。

每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。

每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----export [test.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> myfn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;My name is&quot;</span> + myName + <span class="string">&quot;! I&#x27;m &#x27;&quot;</span> + myAge + <span class="string">&quot;years old.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myClass =  <span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> a = <span class="string">&quot;yeah!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; myName, myAge, myfn, myClass &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName, myAge, myfn, myClass &#125; <span class="keyword">from</span> <span class="string">&quot;./test.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myfn());<span class="comment">// My name is Tom! I&#x27;m 20 years old.</span></span><br><span class="line"><span class="built_in">console</span>.log(myAge);<span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(myName);<span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(myClass.a );<span class="comment">// yeah!</span></span><br></pre></td></tr></table></figure>

### as 的用法

export 命令导出的接口名称，须和模块内部的变量有一一对应关系。

导入的变量名，须和导出的接口名称相同，即顺序可以不一致。

一般用于重新定义接口名称，隐藏模块内部的变量。 

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----export [test.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName <span class="keyword">as</span> exportName &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; exportName &#125; <span class="keyword">from</span> <span class="string">&quot;./test.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(exportName);<span class="comment">// Tom</span></span><br><span class="line">使用 <span class="keyword">as</span> 重新定义导出的接口名称，隐藏模块内部的变量</span><br><span class="line"><span class="comment">/*-----export [test1.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName &#125;</span><br><span class="line"><span class="comment">/*-----export [test2.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Jerry&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName &#125;</span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName <span class="keyword">as</span> name1 &#125; <span class="keyword">from</span> <span class="string">&quot;./test1.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; myName <span class="keyword">as</span> name2 &#125; <span class="keyword">from</span> <span class="string">&quot;./test2.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name1);<span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(name2);<span class="comment">// Jerry</span></span><br></pre></td></tr></table></figure>

### import 命令的特点

**只读属性**：不允许在加载模块的脚本里面，改写接口的引用指向，即可以改写 import 变量类型为对象的属性值，不能改写 import 变量类型为基本类型的值。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span></span><br><span class="line">a = &#123;&#125;; <span class="comment">// error</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span></span><br><span class="line">a.foo = <span class="string">&quot;hello&quot;</span>; <span class="comment">// a = &#123; foo : &#x27;hello&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

**单例模式**：多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。import 同一模块，声明不同接口引用，会声明对应变量，但只执行一次 import 。

### export default 命令

- 在一个文件或模块中，export、import 可以有多个，export default 仅有一个。
- export default 中的 default 是对应的导出接口变量。
- 通过 export 方式导出，在导入时要加&#123; &#125;，export default 则不需要。
- export default 向外暴露的成员，可以使用任意变量来接收。

# ES6 Promise 对象

## 概述

是异步编程的一种解决方案。

从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。

## Promise 状态

### 状态的特点

Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。

Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success1&#x27;</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;success2&#x27;</span>);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;  </span><br><span class="line">    resolve(<span class="string">&#x27;success3&#x27;</span>); </span><br><span class="line">    reject(<span class="string">&#x27;reject&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success1</span></span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

&gt; 已经忘记了promise函数？[点击我回顾](https://tosuke.gitee.io/2022/01/20/JavaScript%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/#Promise)

# ES6 Generator 函数

ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。 基本用法

### Generator 函数组成

Generator 有两个区分于普通函数的部分：

- 一是在 function 后面，函数名之前有个 * ；
- 函数内部有 yield 表达式。

其中 * 用来表示函数为 Generator 函数，yield 用来定义函数内部的状态。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;two&quot;</span>);</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;three&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 执行机制

调用 Generator 函数和调用普通函数一样，在函数名后面加上()即可，但是 Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针，所以要调用遍历器对象Iterator 的 next 方法，指针就会从函数头部或者上一次停下来的地方开始执行。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f.next();</span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;1&quot;, done: false&#125;</span></span><br><span class="line"> </span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line"> </span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// three</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;3&quot;, done: true&#125;</span></span><br><span class="line"> </span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

第一次调用 next 方法时，从 Generator 函数的头部开始执行，先是打印了 one ,执行到 yield 就停下来，并将yield 后边表达式的值 '1'，作为返回对象的 value 属性值，此时函数还没有执行完， 返回对象的 done 属性值是 false。

第二次调用 next 方法时，同上步 。

第三次调用 next 方法时，先是打印了 three ，然后执行了函数的返回操作，并将 return 后面的表达式的值，作为返回对象的 value 属性值，此时函数已经结束，多以 done 属性值为true 。

第四次调用 next 方法时， 此时函数已经执行完了，所以返回 value 属性值是 undefined ，done 属性值是 true 。如果执行第三步时，没有 return 语句的话，就直接返回 &#123;value: undefined, done: true&#125;。

# ES6 async 函数

## async

async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">[param[, param[, ... param]]]</span>) </span>&#123; statements &#125;</span><br></pre></td></tr></table></figure>

- name: 函数名称。
- param: 要传递给函数的参数的名称。
- statements: 函数体语句。

## 5.3 ES6 async 函数

### *分类* [ES6 教程](https://www.runoob.com/w3cnote_genre/es6)

## async

async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的。

### 语法

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function name([param[, param[, ... param]]]) &#123; statements &#125;</span><br></pre></td></tr></table></figure>

- name: 函数名称。
- param: 要传递给函数的参数的名称。
- statements: 函数体语句。

### 返回值

async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;helloAsync&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(helloAsync())  <span class="comment">// Promise &#123;&lt;resolved&gt;: &quot;helloAsync&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line">helloAsync().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(v);         <span class="comment">// helloAsync</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML入门</title>
    <url>/2022/01/11/HTML%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1>初识HTML</h1>
<p>HTML全称hyper Text marker language（超文本标记语言），使web时代更具有稳定性，是多个厂商共同认定的互联网标准。</p>
<h2 id="HTML5的优势">HTML5的优势</h2>
<h3 id="世界知名浏览器厂商对HTML-5的支持">世界知名浏览器厂商对HTML 5的支持</h3>
<p>微软<br>
Google<br>
苹果<br>
Opera<br>
Mozilla</p>
<h3 id="市场的需求">市场的需求</h3>
<h3 id="跨平台">跨平台</h3>
<h2 id="W3C–万维网联盟">W3C–万维网联盟</h2>
<p>W3C<br>
World Wide Web Consortium (万维网联盟)<br>
成立于1994年，Web技术领域最权威和具影响力的国际中立性技术标准机<br>
<a href="http://www.w3.org/">http://www.w3.org/</a><br>
<a href="http://www.chinaw3c.org/">http://www.chinaw3c.org/</a><br>
W3C标准包括<br>
1、结构化标准语言(HTML、 XML)<br>
2、表现标准语言(CSS)<br>
3、行为标准(DOM、ECMAScript )</p>
<h1>HTML的结构</h1>
<p>主要由head（头部）、body（主体）构成：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112133518702.png" alt="image-20220112133518702" style="zoom:80%;">
<p>HTML名为标签语言，意味着每个语句都是一个标签，而标签是一个标签组，像</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>与<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样，必须成对出现（单独呈现的标签加‘/’来关闭元素，例如<hr>；），前一个叫<strong>开放标签</strong>后一个叫<strong>闭合标签</strong>，中间就是我们所编写的内容，开放标签里还可以添加一些参数。</p>
<p>在head标签里有一些网页基本信息</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">DOCTYPE声明：文档声明，使用什么规范。</span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>标签<span class="comment">&lt;!-- 网页的名字--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span>&gt;</span>标签<span class="comment">&lt;!-- meta一般用来做seo，即关键字描述--&gt;</span></span><br><span class="line"> 注：<span class="comment">&lt;!-- ***--&gt;</span>为HTML的注释写法，***即为想要写的内容。</span><br></pre></td></tr></table></figure>
<h1>网页基本标签</h1>
<h2 id="标题标签">标题标签</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;一级标题&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;二级标题&lt;/h2&gt;</span><br><span class="line">&lt;h3&gt;三级标题&lt;/h3&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;h1&gt;&lt;h1/&gt;</code>这样的结构就是我们的标题标签，h几就代表第几级标签，对于划分网页的结构用处很大，实际效果如下：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112135742592.png" alt="image-20220112135742592" style="zoom:80%;">
<h2 id="段落标签">段落标签</h2>
<p>假设我们直接在body标签里这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">暴雨如期而至。雨珠打翻了枯叶，搅混了池塘，空中弥漫着泥土的气息，池塘里的鱼群惊慌失措，仿佛因为看不清前途命运而焦躁不安。</span><br><span class="line"></span><br><span class="line">叶瑾介当时也是在这种时候到达新泽的。</span><br><span class="line"></span><br><span class="line">虽说新泽阴雨连绵，很少能够见到阳光，但对于参加过高考的叶瑾介来说，这注定会是他通往梦想的地方。</span><br><span class="line"></span><br><span class="line">“新泽没有夏天”</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>虽然我们编写的时候事注意了空格和换行的，当时在网页中的显示效果却是这样：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112140243572.png" alt="image-20220112140243572"></p>
<p>也就是全部一字排开，并没有识别到我们的换行。这是因为HTML并不能直接识别到我们的回车换行分段，需要使用<code>&lt;p&gt;&lt;/p&gt;</code>来进行分段规范，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    暴雨如期而至。雨珠打翻了枯叶，搅混了池塘，空中弥漫着泥土的气息，池塘里的鱼群惊慌失措，仿佛因为看不清前途命运而焦躁不安。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line">    叶瑾介当时也是在这种时候到达新泽的。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">    虽说新泽阴雨连绵，很少能够见到阳光，但对于参加过高考的叶瑾介来说，这注定会是他通往梦想的地方。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt;“新泽没有夏天”&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>诺，这样分好段的话，就是这个样子了：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112154049136.png" alt="image-20220112154049136"></p>
<h2 id="换行标签">换行标签</h2>
<p>换行与分段的效果很像，换行是在你想要换行的地方加入<code>&lt;br/&gt;</code>,不过换行的行间距要小于分段的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">暴雨如期而至。雨珠打翻了枯叶，搅混了池塘，空中弥漫着泥土的气息，池塘里的鱼群惊慌失措，仿佛因为看不清前途命运而焦躁不安。<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">叶瑾介当时也是在这种时候到达新泽的。<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">虽说新泽阴雨连绵，很少能够见到阳光，但对于参加过高考的叶瑾介来说，这注定会是他通往梦想的地方。<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">“新泽没有夏天”<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>对比效果如下：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112154636593.png" alt="image-20220112154636593"></p>
<h2 id="水平线标签">水平线标签</h2>
<p>水平线标签<code>&lt;hr/&gt;</code>就是分割文章的水平线，效果如下：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112154840335.png" alt="image-20220112154840335"></p>
<h2 id="字体样式标签">字体样式标签</h2>
<p>字体样式标签分为粗体、斜体与特殊符号</p>
<p>粗体与斜体分别用<code>&lt;strong&gt;</code>与<code>&lt;/em&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">粗体：<span class="tag">&lt;<span class="name">strong</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">斜体: <span class="tag">&lt;<span class="name">em</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>具体效果为：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112155953378.png" alt="image-20220112155953378"></p>
<h2 id="注释和特殊符号">注释和特殊符号</h2>
<p>注释已经说过了，特殊字符包括我们的代码、&lt;(这个尖括号)、空格等。</p>
<p>空格：</p>
<p>标签为&amp;nbsp，像我们自己手动打出来的空格HTML是不会认的，需要在需要空格的地方添加这个标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span> 换行</span><br><span class="line"><span class="symbol">&amp;gt;</span>大于符号</span><br><span class="line"><span class="symbol">&amp;lt;</span>小于符号</span><br><span class="line"><span class="symbol">&amp;copy;</span>版权所有</span><br></pre></td></tr></table></figure>
<p>其他标签都是由&amp;+标识符+;组成的。</p>
<h1>图像标签</h1>
<p>常见的图像格式有：jpg、gif、png、bmp（位图）等等。</p>
<p>图像标签为<code>&lt;img/&gt;</code>标签，标签内可以编写格式，它的格式为：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112162359069.png" alt="image-20220112162359069"></p>
<p>src为图片路径，分为绝对路径贺相对路径，绝对路径是文件在具体磁盘分区的位置。</p>
<p>相对分区的格式一般要先使用…/进入上级标签，然后进入相应的文件夹选择相应的图片.</p>
<p>例如：我的图片已经放在了与HTML文件同级的img文件夹下、</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220114230853528.png" alt="image-20220114230853528" style="zoom:50%;">
<p>所以引用的相对地址就是…/img/1.jpg。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../img/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;春川魔姬&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>引用成功！：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220114231106834.png" alt="image-20220114231106834" style="zoom:50%;">
<p>至于img后的alt属性是指在图由于各种原因没加载出来时，所显示的图片名称，例如如果我把img文件夹的图片删除时，加载出来的就是这样的：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220114231508890.png" alt="image-20220114231508890" style="zoom: 67%;">
<p>另外图片标签还有title属性，就是当鼠标悬停时所显示的文字。width以及height属性，用于控制图片大小，但我们一般用CSS来完成这些工作，所以这里就请大家自己去试试吧。</p>
<h1>链接标签</h1>
<p>链接标签就是网页中点击可以跳转的文字或者图片，这种标签在网页中非常常见，所以非常重要。</p>
<p>链接标签的基本格式为：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220114232411036.png" alt="image-20220114232411036"></p>
<p>a就是a标签，href属性表示想要跳转的路径（有很多分类实现不同的功能），target为新建窗口位置（一般来说就是在当前页面打开还是新建窗口），在标签里面的就是我们想要点击的东西，可以是图片也可以是文字。</p>
<h2 id="页面链接">页面链接</h2>
<p>我先建一个新页面（也就是另一个HTML文件）：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220114234016738.png" alt="image-20220114234016738" style="zoom:50%;">
<p>然后在之前的页面中编写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;测试页面.html&quot;</span>&gt;</span>点我跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样在网页中就会有一个跳转标签：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220114234222167.png" alt="image-20220114234222167" style="zoom:80%;">
<p>点击便实现了跳转。</p>
<h2 id="网址链接">网址链接</h2>
<p>href链接路径中也可以直接填写网站链接，像是“<code>https://www.baidu.com</code>”,这样的话点击标签就直接跳转到了百度。</p>
<h2 id="锚链接">锚链接</h2>
<p>我更想叫他飞雷神链接（即基本原理为“设置标签”+“点击跳转到指定标签”）。</p>
<p>设置锚标签的语句是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;top&quot;</span>&gt;</span>顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span>（可不添加文字）</span><br></pre></td></tr></table></figure>
<p>跳转锚标签的语句是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#top&quot;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span>（也就是href属性中写#加上锚标签的名字）</span><br></pre></td></tr></table></figure>
<h2 id="功能性链接">功能性链接</h2>
<p>这种链接用于实现某一功能，比如点击联系我啊这类的，举个例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:1848228664@qq.com&quot;</span>&gt;</span>点击联系京介<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就会自动调用软件，向我发送邮件咯。</p>
<h1>行内元素与块元素</h1>
<p>这个单独成块的元素以及以行为单位的元素，这个在CSS中比较重要，这里稍作了解即可。</p>
<h1>列表标签</h1>
<p>列表标签就是辅助使得文章更加条理清晰的展示，也就是类似于文章分点这种功能。</p>
<h2 id="有序列表（order-list）">有序列表（order list）</h2>
<p>格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;ol&gt;  &lt;/ol&gt;</code>标签指的就是有序标签，在其中用<code>&lt;li&gt;   &lt;/li&gt;</code>进行分条。</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220115141301222.png" alt="image-20220115141301222" style="zoom:67%;">
<h2 id="无序标签（unorder-list）">无序标签（unorder list）</h2>
<p>格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>格式与有序标签相似，只是英文缩写不同而已。</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220115141721006.png" alt="image-20220115141721006" style="zoom:67%;">
<p>无序标签一般用于导航栏，书签之类的。</p>
<h2 id="自定义列表（defintion-list）">自定义列表（defintion list）</h2>
<p>格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>顺序<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>分类<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>python<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>c/c++<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>自定义标签指的是标签有列表分类，即可以用<code>&lt;dt&gt;&lt;/dt&gt;</code>对其下内容归纳一个类名。</p>
<p>一般用于网页底部的公司介绍等。</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220115142520683.png" alt="image-20220115142520683" style="zoom:80%;">
<h1>表格标签</h1>
<p>制作我们在网页中常见的网格</p>
<p>格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1px&quot;</span>&gt;</span> border属性是用于给表格加上裱框。</span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>1-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>1-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>1-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>先用table标签制作表格，在里面用tr标签代表行，在tr标签里用td标签代表每一列并添加内容。</p>
<p>在表格里我们经常会使用合并行或者合并项的操作，在td列标签添加属性colspan并添加合并多少列的参数就可以实现合并列，同理，在td列标签添加属性rowspan即可合并行。</p>
<p>表格也在css中占据重要位置，故HTML表格仅作了解。</p>
<h1>媒体标签</h1>
<p>例如视频元素：</p>
<p>格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>大家应该也都知道了src就是所谓的资源路径了，只需要把视频的地址放进去就行了，由于我没有比较适合拿来公开演示的视频，那么就请大家自己实验了，后面的controls与autoplay属性是实现添加视频控件和自动播放功能。</p>
<p>音频元素也是一样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以添加controls与autoplay等属性。</p>
<h1>页面结构分析</h1>
<table>
<thead>
<tr>
<th>元素名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>header</td>
<td>标题头部区域的内容(用于页面或页面中的-块区域)</td>
</tr>
<tr>
<td>footer</td>
<td>标记脚部区域的内容(用于整个页面或页面的一块区域)</td>
</tr>
<tr>
<td>section</td>
<td>Web页面中的一块独立区域</td>
</tr>
<tr>
<td>article</td>
<td>独立的文章内容</td>
</tr>
<tr>
<td>aside</td>
<td>相关内容或应用(常用于侧边栏)</td>
</tr>
<tr>
<td>nav</td>
<td>导航类辅助内容</td>
</tr>
</tbody>
</table>
<p>用这些标签去给网页内容分类，能够使得网站布局条理清晰。</p>
<h1>iframe内联框架</h1>
<p>即在网站中嵌入一个其他网站，比如在网站里嵌入其他网站的视频，功能等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">name</span>=<span class="string">&quot;框架&quot;</span> <span class="attr">width</span>=<span class="string">&quot;800px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1000px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>iframe内联框架本质上是构建一个内容框架，你可以在里面打开任何一个你想要打开的资源内容，如同上句所写，这时候你的网页将会有一个width=“800px” height=&quot;1000px&quot;的框架，里面打开的是src中的百度。</p>
<p>iframe内联框架也可以不需要src路径，在之间的链接标签中的target属性便可以指向框架的名字，这样的话跳转的内容将会在框架中呈现。</p>
<h1>表单语法</h1>
<p>我们在平时上网时，经常会注册或者登陆一些账号，比如这个界面：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220115223427076.png" alt="image-20220115223427076"></p>
<p>这些与我们提交的信息相关的叫做表单</p>
<p>了解一下表单的基本语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;我的第一个HTML.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        名字<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span><span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>表单标签是form，在form中构建你想要的表单元素，在form下的属性method决定了表单请求的方式，简单来说：get:不安全，但是效率高，而post正好相反。</p>
<p>最后的效果就如同所示，关于具体的表单请求可以在检查中的network中察看。</p>
<h2 id="文本框">文本框</h2>
<p>表单中重要的是input标签，虽然它的字面含义让人很容易想到输入框，但它的功能远不止这么简单，决定它的用途的是input标签里的type属性，举例为：</p>
<ol>
<li>text：普通文本输入框</li>
<li>password：密码输入框（输入的文字不可见）</li>
<li>submit：提交按钮</li>
<li>reset：重置按钮</li>
<li>radio：单选（同一组使用相同name进行约束，checked默认选择）</li>
<li>checkbox：多选框 （同一组有效）</li>
<li>button：按钮</li>
<li>……</li>
</ol>
<p>另外input标签还有其他属性，name用来命名，value设定初始值，maclength设定最大字符数，size设定文本框的长度。</p>
<h2 id="下拉框与文本域">下拉框与文本域</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zhi&quot;</span>&gt;</span>zhong<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zh&quot;</span> <span class="attr">selected</span>&gt;</span>mei<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zi&quot;</span>&gt;</span>ouoi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>select为下拉框标签，里面用option标签写每一个选项，option标签里的属性selected是默认选中的意思。</p>
<p>文本域为一串文本输入框：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;文本域&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>文件域可以上传文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;btn1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面那个上传按钮纯属装饰。</p>
<h2 id="输入验证">输入验证</h2>
<p>有邮件验证：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时输入的如果不是邮箱地址就会这样：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220115232631278.png" alt="image-20220115232631278" style="zoom:67%;">
<p>url验证：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;url&quot;</span><span class="attr">name</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>数字验证：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span><span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">min</span>=<span class="string">&quot;1&quot;</span><span class="attr">step</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="滑块">滑块</h2>
<p>把数字抽象为滑块来展示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>音量：</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span><span class="attr">name</span>=<span class="string">&quot;la&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span><span class="attr">min</span>=<span class="string">&quot;0&quot;</span><span class="attr">step</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220115233049179.png" alt="image-20220115233049179"></p>
<h2 id="搜索框">搜索框</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span><span class="attr">name</span>=<span class="string">&quot;search&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="表单的应用">表单的应用</h2>
<h3 id="只读（readonly）与禁用（disable）">只读（readonly）与禁用（disable）</h3>
<p>让输入框内容无法更改，在input标签中加入readonly属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">名字<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">readonly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>让选项框无法选择，在input标签中加入disable属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zhi&quot;</span> <span class="attr">disabled</span>&gt;</span>zhong<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zh&quot;</span> <span class="attr">selected</span>&gt;</span>mei<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zi&quot;</span>&gt;</span>ouoi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时在下拉框中已无法选择zhong。</p>
<h3 id="隐藏（hidden）">隐藏（hidden）</h3>
<p>使得某些元素隐藏，达到默认值的效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>密码<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span><span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">hidden</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样便会隐藏密码框，使用默认值123546。</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220116003850604.png" alt="image-20220116003850604" style="zoom:67%;">
<h3 id="点击文字进行输入">点击文字进行输入</h3>
<p>这是label标签的作用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;mark&quot;</span>&gt;</span>点我试试看<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将姓名输入框的id改为mark</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">名字<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mark&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样点击label就会进入姓名的输入了。</p>
<h1>表单的初级验证</h1>
<p>placeholder属性：输入框的灰色提示语句。</p>
<p>required属性：操作不能为空。</p>
<p>pattern属性：要求为正则表达式。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端入门</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE的部分要点</title>
    <url>/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/</url>
    <content><![CDATA[<h1>scanner</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">scanner.hasnextline()  <span class="comment">//判断是否还有输入</span></span><br></pre></td></tr></table></figure>
<p>next（）与nextLine（）的区别；</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208161159615.png" alt="image-20211208161159615"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sacanner.nextLine(); <span class="comment">//可以接受空白，以回车为结束。</span></span><br><span class="line">scanner.close();   <span class="comment">//关闭scanner</span></span><br></pre></td></tr></table></figure>
<h1>增强for循环</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x:数组名)&#123;</span><br><span class="line">  system.out.println(x);</span><br><span class="line">  <span class="comment">//遍历数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>给main函数传递参数</h1>
<p>找到包的路径下，在命令行中进行编译，运行。</p>
<h1>可变参数</h1>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208164227825.png" alt="image-20211208164227825"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>... i)</span></span>&#123;</span><br><span class="line"> system.out.println(i[]);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//此时i为可变参数，可输入多个值,i也就可能成为一个数组。</span></span><br></pre></td></tr></table></figure>
<h1>递归</h1>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208164910624.png" alt="image-20211208164910624"></p>
<h1>继承和多态</h1>
<p>静态方法是类的方法，非静态的方法是对象的方法。</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208211748858.png" alt="image-20211208211748858"></p>
<p>我们的person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我开动了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>student类继承person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">student</span> <span class="keyword">extends</span> <span class="title">person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生的事怎么能叫吃呢？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我要学习了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>text类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">texi1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        student  s1=<span class="keyword">new</span> student();</span><br><span class="line">        person s2=<span class="keyword">new</span> student();</span><br><span class="line">s1.eat();</span><br><span class="line">s2.eat();</span><br><span class="line">s1.learn();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208215628894.png" alt="image-20211208215628894"></p>
<h2 id="多态（只针对方法）：">多态（只针对方法）：</h2>
<p>同一方法可以根据发送对象的不同采取多种不同的行为方式，一个对象的实际类型是知道的，但指向对象的引用类型有很多，比如父类的引用指向了子类的对象。</p>
<p>执行方法先看类里面的静态方法（静态方法属于类的，不属于对象），再看对象实际类型对应的方法。</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208214431807.png" alt="image-20211208214431807"></p>
<h1>instanceof与类型转换</h1>
<p>instanceof会判断两个类的继承关系，兄弟关系则会报错。</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209175621741.png" alt="image-20211209175621741"></p>
<p><em>底类转高类不需要强制转换。</em></p>
<p><em>高类转底类需要进行强制转换</em></p>
<p>子类转换为父类可能会丢失一些方法（子类te’you）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object s1 = <span class="keyword">new</span> student(); </span><br><span class="line"><span class="comment">//底类转高类不需要强制转换</span></span><br><span class="line">person s2 = (student) s1;          <span class="comment">//高类转底类需要进行强制转换</span></span><br><span class="line">s2.eat();</span><br><span class="line">student s3 = (student) s2;</span><br><span class="line">s3.eat();</span><br><span class="line">s3.learn();</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209182350137.png" alt="image-20211209182350137"></p>
<blockquote>
<p>这里插入一个我突然看到的，对于对象和实例区别的一个例子：</p>
<p>父母口中的女朋友（对象），怀里搂着的她（实例）。</p>
<p>（精辟无敌）</p>
</blockquote>
<h1>抽象类与接口</h1>
<h2 id="抽象类">抽象类</h2>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209182856546.png" alt="image-20211209182856546"></p>
<blockquote>
<p>抽象类：给予类约束，让其他人帮我们实现。继承了抽象类的类必须重写抽象类所有的抽象方法（除非自己也是抽象类）。我们一般把他们叫做资本家与被压榨的苦力。</p>
</blockquote>
<p>生成一个抽象类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 资本家 </span>&#123;</span><br><span class="line">    <span class="comment">//来帮我写个方法,我只给需求，我就不写了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">ganfan</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以及一个苦力：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 被压榨的苦力 <span class="keyword">extends</span> 资本家 </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ganfan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我为老板冲锋陷阵！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        被压榨的苦力 苦力<span class="number">1</span> = <span class="keyword">new</span> 被压榨的苦力();</span><br><span class="line">        苦力<span class="number">1.</span>ganfan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209184432977.png" alt="image-20211209184432977"></p>
<h2 id="接口">接口</h2>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209184503107.png" alt="image-20211209184503107"></p>
<p>接口全是抽象方法还有静态常量，只有由别人实现。即接口全是要求，资本家自愧不如。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">service</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有对象皆抽象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> speed)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">get</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> age=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个类实现两个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">serviceimpl</span> <span class="keyword">implements</span> <span class="title">service</span>,<span class="title">get</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lost</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用接口实现多继承,接口不能被实例化~接口中没有构造方法。</p>
<h1>内部类</h1>
<h2 id="成员内部类">成员内部类</h2>
<p>定义一个内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外面的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">in</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是里面的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个内部对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        text t1 = <span class="keyword">new</span> text();</span><br><span class="line">        text.in in1 = t1.<span class="function">new <span class="title">in</span><span class="params">()</span></span>;</span><br><span class="line">        t1.out();</span><br><span class="line">        in1.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209190853396.png" alt="image-20211209190853396"></p>
<p><strong>内部类可以操纵外部类的私有属性，这是它的特点（毕竟是亲生的）。</strong></p>
<h2 id="静态内部类">静态内部类</h2>
<p>也就是定义内部类时加上static，需要时注意的是，如果内部类被静态化，那么这个静态内部类也许就不能访问外部类的私有属性了（静态内部类相当于预加载），除非该私有属性也是静态的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外面的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">in</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是里面的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="局部内部类">局部内部类</h2>
<p>在方法里定义的类（类如局部变量）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">in</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是里面的&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外面的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类">匿名内部类</h2>
<p>new出来直接用，没有名字初始类，不用将实例保存到类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        id=<span class="keyword">new</span> Scanner().nextInt();</span><br><span class="line">        <span class="comment">//没有创建scanner类.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>异常机制</h1>
<h2 id="异常">异常</h2>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209193513675.png" alt="image-20211209193513675"></p>
<p><strong>异常也是一种对象</strong></p>
<p>当遇到异常或者是错误时，Java会抛出异常对象，可以对其进行捕获处理（尤其是异常）。</p>
<h2 id="异常处理">异常处理</h2>
<h3 id="五个关键字">五个关键字</h3>
<p>try:尝试捕获异常的监控区。</p>
<p>catch：捕获异常（括号里为想要捕获的异常类型）。</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211210195637949.png" alt="image-20211210195637949"></p>
<p>finally：无论执不执行最后都要走的（一般用于善后工作）。</p>
<p>throw：主动抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException();</span><br></pre></td></tr></table></figure>
<p>throws：方法调用时抛出，</p>
<p>写个报错程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(b/a);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;有问题&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;<span class="comment">//善后处理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ctrl+alt+t可以快速构造代码块框架，包括try|catch语句。</p>
</blockquote>
<p>输出：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211210201559270.png" alt="image-20211210201559270"></p>
<h2 id="自定义异常">自定义异常</h2>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211210202529797.png" alt="image-20211210202529797"></p>
<p>比如数字大于10，我们设计的异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myexception</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> detali;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Myexception</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.detali=a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Myexception&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;detali=&quot;</span> + detali +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="number">11</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Myexception e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> Myexception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Myexception(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;正常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211210203653004.png" alt="image-20211210203653004"></p>
<h1>结束</h1>
<p>JavaSE大体部分就到此结束！</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-BOM</title>
    <url>/2022/01/28/JavaScript-BOM/</url>
    <content><![CDATA[<h1>浏览器对象模型（<strong>B</strong>rowser <strong>O</strong>bject <strong>M</strong>odel (BOM)）</h1>
<p>浏览器对象模型 (BOM) 使 JavaScript 有能力与浏览器&quot;对话&quot;，指的是js与我们面向的浏览器的对话，所有浏览器都支持 window 对象。它表示浏览器窗口。</p>
<p>所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。</p>
<p>全局变量是 window 对象的属性。</p>
<p>全局函数是 window 对象的方法。</p>
<p>HTML DOM 的 document 也是 window 对象的属性之一：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.document.getElementById(<span class="string">&quot;header&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>我们平时写的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;header&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>是与之相同的语句。</p>
<h1>Window 尺寸</h1>
<p>有三种方法能够确定浏览器窗口的尺寸。</p>
<p>对于Internet Explorer、Chrome、Firefox、Opera 以及 Safari：</p>
<ul>
<li>window.innerHeight - 浏览器窗口的内部高度(包括滚动条)</li>
<li>window.innerWidth - 浏览器窗口的内部宽度(包括滚动条)</li>
</ul>
<p>对于 ：</p>
<ul>
<li>document.documentElement.clientHeight</li>
<li>document.documentElement.clientWidth</li>
</ul>
<p>或者</p>
<ul>
<li>document.body.clientHeight</li>
<li>document.body.clientWidth</li>
</ul>
<p>故我们可以写出一个对于所有的浏览器通用的输出显示浏览器窗口的高度和宽度的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> w=<span class="built_in">window</span>.innerWidth</span><br><span class="line">      || <span class="built_in">document</span>.documentElement.clientWidth</span><br><span class="line">      || <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line"><span class="keyword">var</span> h=<span class="built_in">window</span>.innerHeight</span><br><span class="line">      || <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">      || <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">x=<span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">x.innerHTML=<span class="string">&quot;浏览器window宽度: &quot;</span> + w + <span class="string">&quot;, 高度: &quot;</span> + h + <span class="string">&quot;。&quot;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/28/JavaScript-BOM/image-20220128123251923.png" alt="image-20220128123251923"></p>
<p>但由于 Internet Explorer 浏览器已经不再被经常使用，所以很少能用到后面几个属性。</p>
<h1>其他 Window 方法</h1>
<p>一些其他方法：</p>
<ul>
<li>window.open() - 打开新窗口</li>
<li>window.close() - 关闭当前窗口</li>
<li>window.moveTo() - 移动当前窗口</li>
<li>window.resizeTo() - 调整当前窗口的尺寸</li>
</ul>
<h1>Window Screen</h1>
<p>window.screen 对象包含有关用户屏幕的信息。</p>
<ul>
<li>screen.availWidth - 可用的屏幕宽度</li>
<li>screen.availHeight - 可用的屏幕高度</li>
</ul>
<h1>Window Location</h1>
<p>window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。</p>
<p>例如：</p>
<ul>
<li>location.hostname 返回 web 主机的域名</li>
<li>location.pathname 返回当前页面的路径和文件名</li>
<li>location.port 返回 web 主机的端口 （80 或 443）</li>
<li>location.protocol 返回所使用的 web 协议（http: 或 https:）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(location.href);<span class="comment">//返回当前页面的url</span></span><br><span class="line"><span class="built_in">document</span>.write(location.pathname);<span class="comment">//返回URL 的路径名，也就是页面的相对路径</span></span><br></pre></td></tr></table></figure>
<h1>Window Location Assign</h1>
<p>location.assign() 方法可以加载新的文档。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newDoc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.location.assign(<span class="string">&quot;http://tosuke.gitee.io/&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用这个函数，页面将会加载<a href="http://tosuke.gitee.io/">京介的正牌博客 - 知识越多，代码越少 (gitee.io)</a>这个页面。</p>
<blockquote>
<p>还有一个与他很像的函数window.location.replace(url) ，都是相当于跳转新链接，不同之处在于：</p>
<p>window.location.assign(url) ： 加载 URL 指定的新的 HTML 文档。 就相当于一个链接，跳转到指定的url，当前页面会转为新页面内容，可以点击后退返回上一个页面。</p>
<p>window.location.replace(url) ： 通过加载 URL 指定的文档来替换当前文档 ，这个方法是替换当前窗口页面，前后两个页面共用一个窗口，所以是没有后退返回上一页的</p>
</blockquote>
<h1>Window History</h1>
<p>window.history 对象包含浏览器的要命的历史，所以js对他的访问也有一些限制（遗嘱：请务必清除我的所有浏览器数据）</p>
<p>首先是两个非常普通的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.back() - 与在浏览器点击后退按钮相同</span><br><span class="line">history.forward() - 与在浏览器中点击向前按钮相同</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除此之外可以用 <strong>history.go()</strong> 这个方法来实现向前，后退的功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.go(<span class="number">1</span>);<span class="comment">//向前一个页面 </span></span><br><span class="line">history.go(-<span class="number">1</span>); <span class="comment">//向后一个页面 </span></span><br><span class="line">history.go(<span class="number">0</span>); <span class="comment">//刷新当前页面页面 </span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1>Window Navigator</h1>
<p>window.navigator 对象包含有关访问者浏览器的信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">txt = <span class="string">&quot;&lt;p&gt;浏览器代号: &quot;</span> + navigator.appCodeName + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">txt+= <span class="string">&quot;&lt;p&gt;浏览器名称: &quot;</span> + navigator.appName + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">txt+= <span class="string">&quot;&lt;p&gt;浏览器版本: &quot;</span> + navigator.appVersion + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">txt+= <span class="string">&quot;&lt;p&gt;启用Cookies: &quot;</span> + navigator.cookieEnabled + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">txt+= <span class="string">&quot;&lt;p&gt;硬件平台: &quot;</span> + navigator.platform + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">txt+= <span class="string">&quot;&lt;p&gt;用户代理: &quot;</span> + navigator.userAgent + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">txt+= <span class="string">&quot;&lt;p&gt;用户代理语言: &quot;</span> + navigator.language + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;example&quot;</span>).innerHTML=txt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>来自 navigator 对象的信息具有误导性，不应该被用于检测浏览器版本，这是因为：</p>
<ul>
<li>navigator 数据可被浏览器使用者更改</li>
<li>一些浏览器对测试站点会识别错误</li>
<li>浏览器无法报告晚于浏览器发布的新操作系统</li>
</ul>
<h1>弹窗</h1>
<p>可以在 JavaScript 中创建三种消息框：警告框、确认框、提示框</p>
<h2 id="警告框">警告框</h2>
<p>警告框经常用于确保用户可以得到某些信息。</p>
<p>当警告框出现后，用户需要点击确定按钮才能继续进行操作。</p>
<p>警告框也就是我们一直再用的<strong>window.alert()</strong> 方法（可以不加上window对象）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">&quot;即将跳转&quot;</span>)；</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/28/JavaScript-BOM/image-20220128153501193.png" alt="image-20220128153501193"></p>
<p>即这样的警示框。</p>
<h2 id="确认框">确认框</h2>
<p>确认框通常用于验证是否接受用户操作。</p>
<p>当确认卡弹出时，用户可以点击 “确认” 或者 “取消” 来确定用户操作。</p>
<p>当你点击 “确认”, 确认框返回 true， 如果点击 “取消”, 确认框返回 false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r=confirm(<span class="string">&quot;按下按钮&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (r==<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		   <span class="built_in">window</span>.location.assign(<span class="string">&quot;http://tosuke.gitee.io/&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">		   alert(<span class="string">&quot;取消！&quot;</span>)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/28/JavaScript-BOM/image-20220128153932257.png" alt="image-20220128153932257"></p>
<h2 id="提示框">提示框</h2>
<p>提示框经常用于提示用户在进入页面前输入某个值。</p>
<p>当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操纵。</p>
<p>如果用户点击确认，那么返回值为输入的值。如果用户点击取消，那么返回值为 null。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.prompt(<span class="string">&quot;sometext&quot;</span>,<span class="string">&quot;defaultvalue&quot;</span>);<span class="comment">//语法</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=prompt(<span class="string">&quot;输入你的年龄！&quot;</span>,<span class="string">&quot;Tosuke&quot;</span>);</span><br><span class="line">	   <span class="keyword">if</span>(x!=<span class="literal">null</span>&amp;&amp;x!=<span class="string">&quot;&quot;</span>)</span><br><span class="line">	   &#123;</span><br><span class="line">		   alert(<span class="string">&quot;你好！&quot;</span>+x+<span class="string">&quot;天气不错呢！&quot;</span>);</span><br><span class="line">	   &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/28/JavaScript-BOM/image-20220128154608684.png" alt="image-20220128154608684"></p>
<h2 id="换行">换行</h2>
<p>弹窗使用 反斜杠 + “n”(\n) 来设置换行。</p>
<h1>计时事件</h1>
<p>JavaScript 一个设定的时间间隔之后来执行代码我们称之为计时事件.</p>
<h2 id="JavaScript-计时事件">JavaScript 计时事件</h2>
<p>通过使用 JavaScript，我们有能力做到在一个设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。我们称之为计时事件。</p>
<p>在 JavaScritp 中使用计时事件是很容易的，两个关键方法是:</p>
<ul>
<li>setInterval() - 间隔指定的毫秒数不停地执行指定的代码。</li>
<li>setTimeout() - 在指定的毫秒数后执行指定代码。</li>
</ul>
<p><strong>注意:</strong> setInterval() 和 setTimeout() 是 HTML DOM Window对象的两个方法。</p>
<h3 id="setInterval">setInterval()</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">&quot;Hello&quot;</span>)&#125;,<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>setInterval()有两个参数，第一个是需要循环执行的函数，第二个是循环的时间间隔。</p>
<p><strong>clearInterval() 方法</strong>用于停止 setInterval() 方法执行的函数代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">直接在<span class="built_in">clearInterval</span>() 中填上作为需要停止的<span class="built_in">setInterval</span></span><br></pre></td></tr></table></figure>
<h3 id="setTimeout">setTimeout()</h3>
<p>在指定的毫秒数后执行指定代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myVar= <span class="built_in">window</span>.setTimeout(<span class="string">&quot;javascript function&quot;</span>, milliseconds);</span><br></pre></td></tr></table></figure>
<p>与setInterval()是相同的参数结构，clearTimeout() 来停止setTimeout函数。</p>
<h1>Cookie</h1>
<h2 id="什么是-Cookie？">什么是 Cookie？</h2>
<p>Cookie 是一些数据, 存储于你电脑上的文本文件中。</p>
<p>当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。</p>
<p>Cookie 的作用就是用于解决 “如何记录客户端的用户信息”:</p>
<ul>
<li>当用户访问 web 页面时，他的名字可以记录在 cookie 中。</li>
<li>在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。</li>
</ul>
<p>Cookie 以名/值对形式存储：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">username=Tosuke</span><br></pre></td></tr></table></figure>
<p>当浏览器从服务器上请求 web 页面时， 属于该页面的 cookie 会被添加到该请求中。服务端通过这种方式来获取用户的信息。</p>
<h2 id="使用-JavaScript-创建Cookie">使用 JavaScript 创建Cookie</h2>
<p>JavaScript 可以使用 <strong>document.cookie</strong> 属性来创建 、读取、及删除 cookie。</p>
<p>JavaScript 中，创建 cookie 如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie=<span class="string">&quot;username=John Doe&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>使用path告诉浏览器cookie的路径，默认情况下，cookie属于当前页面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie=<span class="string">&quot;username=John Doe; path=/&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="使用-JavaScript-读取-Cookie">使用 JavaScript 读取 Cookie</h2>
<p>在 JavaScript 中, 可以使用以下代码来读取 cookie：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>document.cookie 将以字符串的方式返回所有的 cookie，类型格式： cookie1=value; cookie2=value; cookie3=value;</p>
</blockquote>
<h2 id="使用-JavaScript-修改-Cookie">使用 JavaScript 修改 Cookie</h2>
<p>在 JavaScript 中，修改 cookie 类似于创建 cookie，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie=<span class="string">&quot;username=John Smith; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>旧的 cookie 将被覆盖。</p>
<h2 id="使用-JavaScript-删除-Cookie">使用 JavaScript 删除 Cookie</h2>
<p>删除 cookie 非常简单。您只需要设置 expires 参数为以前的时间即可，如下所示，设置为 Thu, 01 Jan 1970 00:00:00 GMT:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;username=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>注意，当您删除时不必指定 cookie 的值。</p>
<h2 id="Cookie-字符串">Cookie 字符串</h2>
<p>document.cookie 属性看起来像一个普通的文本字符串，其实它不是。</p>
<p>即使您在 document.cookie 中写入一个完整的 cookie 字符串, 当您重新读取该 cookie 信息时，cookie 信息是以名/值对的形式展示的。</p>
<p>如果您设置了新的 cookie，旧的 cookie 不会被覆盖。 新 cookie 将添加到 document.cookie 中，所以如果您重新读取document.cookie</p>
<h2 id="设置-cookie-值的函数">设置 cookie 值的函数</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">cname,cvalue,exdays</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  d.setTime(d.getTime()+(exdays*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>));</span><br><span class="line">  <span class="keyword">var</span> expires = <span class="string">&quot;expires=&quot;</span>+d.toGMTString();<span class="comment">//设置过期时间</span></span><br><span class="line">  <span class="built_in">document</span>.cookie = cname + <span class="string">&quot;=&quot;</span> + cvalue + <span class="string">&quot;; &quot;</span> + expires;<span class="comment">//进行储存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数解析：</strong></p>
<p>以上的函数参数中，cookie 的名称为 cname，cookie 的值为 cvalue，并设置了 cookie 的过期时间 expires。</p>
<p>该函数设置了 cookie 名、cookie 值、cookie过期时间。</p>
<h2 id="获取-cookie-值的函数">获取 cookie 值的函数</h2>
<p>然后，我们创建一个函数用于返回指定 cookie 的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">cname</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = cname + <span class="string">&quot;=&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> ca = <span class="built_in">document</span>.cookie.split(<span class="string">&#x27;;&#x27;</span>);<span class="comment">//使用；进行分割操作</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;ca.length; i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> c = ca[i].trim();</span><br><span class="line">    <span class="keyword">if</span> (c.indexOf(name)==<span class="number">0</span>) <span class="keyword">return</span> c.substring(name.length,c.length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数解析：</strong></p>
<p>cookie 名的参数为 cname。</p>
<p>创建一个文本变量用于检索指定 cookie :cname + “=”。</p>
<p>使用分号来分割 document.cookie 字符串，并将分割后的字符串数组赋值给 ca (ca = document.cookie.split(‘;’))。</p>
<p>循环 ca 数组 (i=0;i&lt;ca.length;i++)，然后读取数组中的每个值，并去除前后空格 (c=ca[i].trim())。</p>
<p>如果找到 cookie(c.indexOf(name) == 0)，返回 cookie 的值 (c.substring(name.length,c.length)。</p>
<p>如果没有找到 cookie, 返回 “”。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端入门</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-Dom</title>
    <url>/2022/01/27/JavaScript-Dom/</url>
    <content><![CDATA[<h1>HTML DOM (文档对象模型)</h1>
<p>当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素。</p>
<p>HTML DOM 树的结构示意图（图片来自菜鸟编程）：</p>
<p><img src="/2022/01/27/JavaScript-Dom/image-20220127233523498.png" alt="image-20220127233523498"></p>
<p>通过js对dom的掌控，使得这些对象模型可以被动态的展示出来（类似于商品列表，一刷新一换）。</p>
<h1>查找 HTML 元素</h1>
<p>通过 JavaScript操作 HTML 元素需要先通过某种方式进行查找从而进行选择。</p>
<p>有三种方法来做这件事：</p>
<ul>
<li>通过 id 找到 HTML 元素</li>
<li>通过标签名找到 HTML 元素</li>
<li>通过类名找到 HTML 元素</li>
</ul>
<h2 id="通过-id-找到-HTML-元素">通过 id 找到 HTML 元素</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="built_in">document</span>.getElementById(<span class="string">&quot;id名&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="通过标签名找到-HTML-元素">通过标签名找到 HTML 元素</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="built_in">document</span>.getElementById(<span class="string">&quot;main&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> y=x.getElementsByTagName(<span class="string">&quot;p&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>本例查找 id=“main” 的元素，然后查找 id=“main” 元素中的所有 <code>&lt;p&gt;</code> 元素</p>
<h2 id="通过类名找到-HTML-元素">通过类名找到 HTML 元素</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;intro&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1>改变 HTML 输出流</h1>
<p>document.write() 可用于直接向 HTML 输出流写内容。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.write(<span class="built_in">Date</span>());<span class="comment">//该语句会直接向HTML输出流xie</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：绝对不要在文档(DOM)加载完成之后使用 document.write()。这会覆盖该文档。</strong></p>
</blockquote>
<h1>改变 HTML 内容</h1>
<p>document.getElementById(<em>id</em>).innerHTML=<em>新的改变</em></p>
<p>使用这个函数可以使得HTML元素的内容发生改变</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.getElementById(<span class="string">&quot;p1&quot;</span>).innerHTML=<span class="string">&quot;新文本!&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>这里改变了<code>&lt;p1&gt;</code>的内容。</p>
<h1>改变 HTML 属性</h1>
<p>document.getElementById(<em>id</em>).<em>attribute=新属性值</em></p>
<p>使用此函数改变HTML标签的属性。</p>
<p>例如改变图片的路径：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;smiley.gif&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.getElementById(<span class="string">&quot;image&quot;</span>).src=<span class="string">&quot;landscape.jpg&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1>改变 HTML 样式</h1>
<p>document.getElementById(<em>id</em>).style.<em>property</em>=<em>新样式</em></p>
<p>使用此函数改变HTML标签的样式。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.getElementById(<span class="string">&quot;p2&quot;</span>).style.color=<span class="string">&quot;blue&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.getElementById(<span class="string">&quot;p2&quot;</span>).style.fontFamily=<span class="string">&quot;Arial&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.getElementById(<span class="string">&quot;p2&quot;</span>).style.fontSize=<span class="string">&quot;larger&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>666<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1>使用事件</h1>
<p>HTML DOM 允许我们通过触发事件来执行代码，使 JavaScript 有能力对 HTML 事件做出反应。</p>
<p>比如以下事件：</p>
<ul>
<li>元素被点击。</li>
<li>页面加载完成。</li>
<li>输入框被修改。</li>
<li>当网页已加载时</li>
<li>当图像已加载时</li>
<li>当鼠标移动到元素上时</li>
<li>当输入字段被改变时</li>
<li>当提交 HTML 表单时</li>
<li>当用户触发按键时</li>
<li>……</li>
</ul>
<p>例如点击事件（onclick）调用一个js函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="function"><span class="keyword">function</span> <span class="title">changetext</span>(<span class="params">id</span>)</span></span></span></span><br><span class="line"><span class="function"><span class="javascript"><span class="xml"></span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    id.innerHTML=<span class="string">&quot;Ooops!&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onclick</span>=<span class="string">&quot;changetext(this)&quot;</span>&gt;</span>点击我!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>changetext将会在标题被点击时运行。</p>
<p><strong>onload 和 onunload 事件</strong></p>
<p>onload 和 onunload 事件会在用户进入或离开页面时被触发。</p>
<p>onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。</p>
<p>onload 和 onunload 事件可用于处理 cookie。</p>
<p><strong>onchange 事件</strong></p>
<p>onchange 事件常结合对输入字段的验证来使用，在字段被改变时调用。</p>
<p><strong>onmouseover 和 onmouseout 事件</strong></p>
<p>onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。</p>
<p><strong>onmousedown、onmouseup 以及 onclick 事件</strong></p>
<p>onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。首先当点击鼠标按钮时，会触发 onmousedown 事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件。</p>
<h1>EventListener（事件监听）</h1>
<p>用于捕获事件，当某事件触发后执行某函数。</p>
<p><em>element</em>.addEventListener(<em>event, function, useCapture</em>);</p>
<p>第一个参数是事件的类型 (如 “click” 或 “mousedown”).</p>
<p>第二个参数是事件触发后调用的函数。</p>
<p>第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。</p>
<blockquote>
<p>注意:不要使用 “on” 前缀。 例如，使用 “click” ,而不是使用 “onclick”。</p>
</blockquote>
<p>addEventListener() 方法允许向同一个元素添加多个事件，且不会覆盖已存在的事件</p>
<h2 id="关于传递参数">关于传递参数</h2>
<p>当传递参数值时，使用&quot;匿名函数&quot;调用带参数的函数，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; myFunction(p1, p2); &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="事件冒泡与事件捕获">事件冒泡与事件捕获</h2>
<p>事件传递有两种方式：冒泡与捕获。</p>
<p>事件传递定义了元素事件触发的顺序。 如果你将 </p><p> 元素插入到 <div> 元素中，用户点击 <p> 元素, 哪个元素的 “click” 事件先被触发呢？</p>
<p>在 <em>冒泡</em> 中，内部元素的事件会先被触发，然后再触发外部元素，即： </p><p> 元素的点击事件先触发，然后会触发 <div> 元素的点击事件。</div></p>
<p>在 <em>捕获</em> 中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即： <div> 元素的点击事件先触发 ，然后再触发 <p> 元素的点击事件。</p>
<p>addEventListener() 方法可以指定 “useCapture” 参数来设置传递类型：</p>
<h2 id="removeEventListener-方法">removeEventListener() 方法</h2>
<p>removeEventListener() 方法移除由 addEventListener() 方法添加的事件句柄。</p>
<h1>DOM 元素 (节点)</h1>
<p><strong>要创建新的 HTML 元素 (节点)需要先创建一个元素，然后在已存在的元素中添加它。</strong></p>
<p>以下代码是用于创建 </p><p> 元素:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> para = <span class="built_in">document</span>.createElement(<span class="string">&quot;p&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>为 </p><p> 元素创建一个新的文本节点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;这是一个新的段落。&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>将文本节点添加到 </p><p> 元素中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">para.appendChild(node);<span class="comment">//insertBefore() 方法可以将新元素添加到开始位置。</span></span><br></pre></td></tr></table></figure>
<p>最后，在一个已存在的元素中添加 p 元素。</p>
<p>查找已存在的元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>添加到已存在的元素中:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.appendChild(para);<span class="comment">////insertBefore() 方法可以将新元素添加到开始位置。</span></span><br></pre></td></tr></table></figure>
<h2 id="移除已存在的元素">移除已存在的元素</h2>
<p>在父元素中使用node.remove() 方法，parent.removeChild(child);。</p>
<h2 id="替换-HTML-元素">替换 HTML 元素</h2>
<p>我们可以使用 replaceChild() 方法来替换 HTML DOM 中的元素。</p>
<h1>HTMLCollection 对象</h1>
<p>getElementsByTagName() 方法返回 <code>HTMLCollection</code> 对象。</p>
<p>HTMLCollection 对象类似包含 HTML 元素的一个数组。</p>
<p>例如访问所以p元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">y = x[<span class="number">1</span>];<span class="comment">//用类似与数组的方式访问</span></span><br></pre></td></tr></table></figure>
<p>HTMLCollection 对象的 length 属性定义了集合中元素的数量。</p>
<h1>DOM 节点列表</h1>
<p><strong>NodeList</strong> 对象是一个从文档中获取的节点列表 (集合) 。</p>
<p>NodeList 对象类似HTMLCollection 对象。</p>
<p>一些旧版本浏览器中的方法（如：<strong>getElementsByClassName()</strong>）返回的是 NodeList 对象，而不是 HTMLCollection 对象。</p>
<p>所有浏览器的 <strong>childNodes</strong> 属性返回的是 NodeList 对象。</p>
<p>大部分浏览器的 <strong>querySelectorAll()</strong> 返回 NodeList 对象。</p>
<p>同样是访问所有p元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myNodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">y = myNodeList[<span class="number">1</span>];<span class="comment">//同样通过下标访问</span></span><br></pre></td></tr></table></figure>
<h2 id="NodeList-对象-length-属性">NodeList 对象 length 属性</h2>
<p>NodeList 对象 length 属性定义了节点列表中元素的数量。</p>
<h2 id="HTMLCollection-与-NodeList-的区别">HTMLCollection 与 NodeList 的区别</h2>
<p>HTMLCollection是 HTML 元素的集合。</p>
<p>NodeList 是一个文档节点的集合。</p>
<p>NodeList 与 HTMLCollection 有很多类似的地方。</p>
<p>NodeList 与 HTMLCollection 都与数组对象有点类似，可以使用索引 (0, 1, 2, 3, 4, …) 来获取元素。</p>
<p>NodeList 与 HTMLCollection 都有 length 属性。</p>
<p>HTMLCollection 元素可以通过 name，id 或索引来获取。</p>
<p>NodeList 只能通过索引来获取。</p>
<p>只有 NodeList 对象有包含属性节点和文本节点。</p>
<blockquote>
<p><strong>节点列表不是一个数组！</strong></p>
<p>节点列表看起来可能是一个数组，但其实不是。</p>
<p>你可以像数组一样，使用索引来获取元素。</p>
<p>节点列表无法使用数组的方法： valueOf(), pop(), push(), 或 join() 。</p>
</blockquote>
</div></p></div></p>]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/2021/12/21/Java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1>泛型的概念</h1>
<h1>泛型的好处</h1>
<h2 id="类型安全">类型安全</h2>
<h2 id="消除强制转换类型">消除强制转换类型</h2>
<h1>泛型的作用</h1>
<h2 id="编译期间检查">编译期间检查</h2>
<h1>泛型类</h1>
<p><img src="/2021/12/21/Java%E6%B3%9B%E5%9E%8B/image-20211221125349265.png" alt="image-20211221125349265"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript入门小识</title>
    <url>/2022/01/20/JavaScript%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/</url>
    <content><![CDATA[<h1>什么是JavaScript？</h1>
<p>JavaScript 是互联网上最流行的脚本语言，这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。</p>
<h1>引入JavaScript</h1>
<h3 id="1-内部引入">1.内部引入</h3>
<h3 id="script-标签"><code>&lt;script&gt;</code> 标签</h3>
<p>如需在 HTML 页面中插入 JavaScript，请使用 <code>&lt;script&gt;</code> 标签。</p>
<p><code>&lt;script&gt;</code>和 <code>&lt;/script&gt;</code>会告诉 JavaScript 在何处开始和结束，之间的代码行包含了 JavaScript:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">alert(<span class="string">&quot;我的第一个 JavaScript&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-外部引入">2.外部引入</h3>
<p>也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。</p>
<p>外部 JavaScript 文件的文件扩展名是 .js。</p>
<p>如需使用外部文件，请在  <code>&lt;script&gt;</code>标签的 “src” 属性中设置该 .js 文件，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;myScript.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="基本语法入门">基本语法入门</h2>
<h2 id="数据类型">数据类型</h2>
<p><strong>变量名不能用数字开头</strong></p>
<p>number：数字（不区分大小写）</p>
<p>字符串：‘abc’、“ann”</p>
<p>布尔值：true，false</p>
<p>逻辑运算:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&amp;&amp;  于</span><br><span class="line">|| 或</span><br><span class="line">！ 非</span><br></pre></td></tr></table></figure>
<p>比较运算符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">=</span><br><span class="line">== 等于（类型不算）</span><br><span class="line">=== 绝对等于（类型）</span><br></pre></td></tr></table></figure>
<p>在js中一般使用“===”</p>
<p><strong>注意</strong>：NaN（not a number）与所有值都不相等（包括自己）只能使用isNaN(NaN)来判断是否未NaN</p>
<p>null和undefind：未定义</p>
<p>数组：什么都装，不需要类型相同。尽量使用中括号表示数组</p>
<p>类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person&#123;</span><br><span class="line">name：“十大”,</span><br><span class="line"><span class="attr">age</span>: <span class="string">&#x27;10&#x27;</span></span><br><span class="line"><span class="attr">tag</span>: [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象成员用逗号隔开，最后一位不需要逗号。</p>
<p>用“.”来访问对象成员</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.name</span><br><span class="line">&gt;<span class="string">&quot;十大&quot;</span></span><br><span class="line">person.age</span><br><span class="line">&gt;<span class="number">10</span></span><br></pre></td></tr></table></figure>
<h2 id="严格检查模式">严格检查模式</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br></pre></td></tr></table></figure>
<h1>数据类型</h1>
<p>在 JavaScript 中有 6 种不同的数据类型：</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>object</li>
<li>function</li>
<li>symbol</li>
</ul>
<p>3 种对象类型：</p>
<ul>
<li>Object</li>
<li>Date</li>
<li>Array</li>
</ul>
<p>2 个不包含任何值的数据类型：</p>
<ul>
<li>null</li>
<li>undefined</li>
</ul>
<p><strong>你可以使用 typeof 操作符来查看 JavaScript 变量的数据类型。</strong></p>
<h2 id="constructor-属性">constructor 属性</h2>
<p><strong>constructor</strong> 属性返回所有 JavaScript 变量的构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;John&quot;</span>.constructor                 <span class="comment">// 返回函数 String()  &#123; [native code] &#125;</span></span><br><span class="line">(<span class="number">3.14</span>).constructor                 <span class="comment">// 返回函数 Number()  &#123; [native code] &#125;</span></span><br><span class="line"><span class="literal">false</span>.constructor                  <span class="comment">// 返回函数 Boolean() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="1、字符串">1、字符串</h2>
<p>1、正常的字符串使用单引号或者双引号包围</p>
<p>2、注意转义字符\</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">\<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<p>3、多行字符串编写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">`hello</span></span><br><span class="line"><span class="string">sad</span></span><br><span class="line"><span class="string">happy</span></span><br><span class="line"><span class="string">das`</span></span><br></pre></td></tr></table></figure>
<p>4、模板字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name=<span class="string">&quot;Tosuke&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> msg =<span class="string">`你好呀,<span class="subst">$&#123;name&#125;</span>;</span></span><br></pre></td></tr></table></figure>
<p>5、字符串的长度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.length</span><br></pre></td></tr></table></figure>
<p>6、字符串的可变性，不可变性</p>
<p><img src="/2022/01/20/JavaScript%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/image-20220120144032536.png" alt="image-20220120144032536"></p>
<p>7、大小写转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意，此为方法</span></span><br><span class="line">student.toUpperCase()</span><br><span class="line">student.toLowerCase()</span><br></pre></td></tr></table></figure>
<p>8、student.indexOf(‘t’)</p>
<p>9、substring</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">student.substring(<span class="number">1</span>)<span class="comment">//从第一个字符串截取到最后一个</span></span><br><span class="line">student.substring(<span class="number">1</span>,<span class="number">3</span>)<span class="comment">//[1,3)</span></span><br></pre></td></tr></table></figure>
<h2 id="2、数组">2、数组</h2>
<p>array可以包含任意类型的数据类型</p>
<p>1、长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr.length</span><br></pre></td></tr></table></figure>
<p>可以对长度数据进行修改，数组相应大小就会改变。（小心数据丢失！）</p>
<p>2、indexOf，通过元素获得下标索引</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.indexof(<span class="number">2</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>3、slice()</p>
<h2 id="JavaScript-类型转换">JavaScript 类型转换</h2>
<p>JavaScript 变量可以转换为新变量或其他数据类型：</p>
<ul>
<li>通过使用 JavaScript 函数</li>
<li>通过 JavaScript 自身自动转换</li>
</ul>
<h3 id="将数字转换为字符串">将数字转换为字符串</h3>
<p>全局方法 <strong>String()</strong> 可以将数字转换为字符串。</p>
<p>该方法可用于任何类型的数字，字母，变量，表达式（Number 方法 <strong>toString()</strong> 也是有同样的效果。）：</p>
<h1>JavaScript 正则表达式</h1>
<p>正则表达式是由一个字符序列形成的搜索模式。</p>
<p>当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。</p>
<p>正则表达式可以是一个简单的字符，或一个更复杂的模式。</p>
<p>正则表达式可用于所有文本搜索和文本替换的操作。</p>
<p><img src="/2022/01/20/JavaScript%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/image-20220127162021505.png" alt="image-20220127162021505"></p>
<h2 id="使用-test">使用 test()</h2>
<p>test() 方法是一个正则表达式方法。</p>
<p>test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。</p>
<table>
<thead>
<tr>
<th>[abc]</th>
<th>查找方括号之间的任何字符。</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0-9]</td>
<td>查找任何从 0 至 9 的数字。</td>
</tr>
<tr>
<td>(x|y)</td>
<td>查找任何以 | 分隔的选项。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">元字符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\d</td>
<td style="text-align:center">查找数字。</td>
</tr>
<tr>
<td style="text-align:left">\s</td>
<td style="text-align:center">查找空白字符。</td>
</tr>
<tr>
<td style="text-align:left">\b</td>
<td style="text-align:center">匹配单词边界。</td>
</tr>
<tr>
<td style="text-align:left">\uxxxx</td>
<td style="text-align:center">查找以十六进制数 xxxx 规定的 Unicode 字符。</td>
</tr>
</tbody>
</table>
<h2 id="使用-exec">使用 exec()</h2>
<p>exec() 方法是一个正则表达式方法。</p>
<p>exec() 方法用于检索字符串中的正则表达式的匹配。</p>
<p>该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p>
<h1>JavaScript 错误 - throw、try 和 catch</h1>
<hr>
<p><strong>try</strong> 语句测试代码块的错误。</p>
<p><strong>catch</strong> 语句处理错误。</p>
<p><strong>throw</strong> 语句创建自定义错误。</p>
<p><strong>finally</strong> 语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行。</p>
<p>该部分与Java依然极其相似：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...    <span class="comment">//异常的抛出</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    ...    <span class="comment">//异常的捕获与处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...    <span class="comment">//结束处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>JavaScript 调试</h1>
<p>我们浏览器启用调试工具一般是按下 F12 键，并在调试菜单中选择 “Console” 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="设置断点">设置断点</h2>
<p>在调试窗口中，你可以设置 JavaScript 代码的断点。</p>
<p>在每个断点上，都会停止执行 JavaScript 代码，以便于我们检查 JavaScript 变量的值。</p>
<p>在检查完毕后，可以重新执行代码（如播放按钮）。</p>
<h1>JavaScript 声明提升</h1>
<p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。</p>
<p>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p>
<p>意思是尽管设置变量时没有在这行代码之前声明它，而是在后面才声明时也是可以使用的（声明自动提升），不过大家还是得遵守先声明再使用的原则。</p>
<h1>JavaScript 严格模式(use strict)</h1>
<p>使用 “use strict” 指令<br>
“use strict” 指令在 JavaScript 1.8.5 (ECMAScript5) 中新增。</p>
<p>它不是一条语句，但是是一个字面量表达式，在 JavaScript 旧版本中会被忽略。</p>
<p>“use strict” 的目的是指定代码在严格条件下执行。</p>
<p>严格模式下你不能使用未声明的变量。</p>
<h2 id="表单验证">表单验证</h2>
<p>HTML 表单验证可以通过 JavaScript 来完成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TableTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x=<span class="built_in">document</span>.forms[<span class="string">&quot;myform&quot;</span>][<span class="string">&quot;fname&quot;</span>].value;</span><br><span class="line">  <span class="keyword">if</span>(x==<span class="literal">null</span>||x==<span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      alert(<span class="string">&quot;需要输入名字。&quot;</span>)；</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form name=<span class="string">&quot;myForm&quot;</span> action=<span class="string">&quot;demo_form.php&quot;</span> onsubmit=<span class="string">&quot;return validateForm()&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">名字: <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fname&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1>JavaScript this 关键字</h1>
<p>面向对象语言中 this 表示当前对象的一个引用。</p>
<p>但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。</p>
<ul>
<li>在方法中，this 表示该方法所属的对象。</li>
<li>如果单独使用，this 表示全局对象。</li>
<li>在函数中，this 表示全局对象。</li>
<li>在函数中，在严格模式下，this 是未定义的(undefined)。</li>
<li>在事件中，this 表示接收事件的元素。</li>
<li>类似 call() 和 apply() 方法可以将 this 引用到任何对象</li>
</ul>
<h1>JavaScript let 和 const</h1>
<h3 id="ECMAScript-2015-ECMAScript-6">ECMAScript 2015(ECMAScript 6)</h3>
<p>ES2015(ES6) 新增加了两个重要的 JavaScript 关键字: <strong>let</strong> 和 <strong>const</strong>。</p>
<p>let 声明的变量只在 let 命令所在的代码块内有效。</p>
<p>const 声明一个只读的常量，一旦声明，常量的值就不能改变。</p>
<p>在 ES6 之前，JavaScript 只有两种作用域： <strong>全局变量</strong> 与 <strong>函数内的局部变量</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">let 定义的代码只在这里生效。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>JavaScript JSON</h1>
<ul>
<li>JSON 英文全称 <strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation</li>
<li>JSON 是一种轻量级的数据交换格式</li>
<li>JSON是独立的语言</li>
<li>JSON 易于理解</li>
</ul>
<h2 id="JSON-语法规则">JSON 语法规则</h2>
<ul>
<li>数据为 键/值 对。</li>
<li>数据由逗号分隔。</li>
<li>大括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<h2 id="JSON-数据-一个名称对应一个值">JSON 数据 - 一个名称对应一个值</h2>
<p>JSON 数据格式为 键/值 对，就像 JavaScript 对象属性。</p>
<p>键/值对包括字段名称（在双引号中），后面一个冒号，然后是值：</p>
<p>“name”:“Runoob”</p>
<hr>
<h2 id="JSON-对象">JSON 对象</h2>
<p>JSON 对象保存在大括号内。</p>
<p>就像在 JavaScript 中, 对象可以保存多个 键/值 对：</p>
<p>{“name”:“Runoob”, “url”:“<a href="http://www.runoob.com">www.runoob.com</a>”}</p>
<hr>
<h2 id="JSON-数组">JSON 数组</h2>
<p>JSON 数组保存在中括号内。</p>
<p>就像在 JavaScript 中, 数组可以包含对象：</p>
<p>“sites”:[    {“name”:“Runoob”, “url”:“<a href="http://www.runoob.com">www.runoob.com</a>”},     {“name”:“Google”, “url”:“<a href="http://www.google.com">www.google.com</a>”},    {“name”:“Taobao”, “url”:“<a href="http://www.taobao.com">www.taobao.com</a>”} ]JSON 数据 - 一个名称对应一个值</p>
<p>JSON 数据格式为 键/值 对，就像 JavaScript 对象属性。</p>
<p>键/值对包括字段名称（在双引号中），后面一个冒号，然后是值：</p>
<p>“name”:“Runoob”</p>
<p>JSON 语法规则<br>
数据为 键/值 对。<br>
数据由逗号分隔。<br>
大括号保存对象<br>
方括号保存数组</p>
<hr>
<h2 id="JSON-对象-2">JSON 对象</h2>
<p>JSON 对象保存在大括号内。</p>
<p>就像在 JavaScript 中, 对象可以保存多个 键/值 对：</p>
<p>{“name”:“Runoob”, “url”:“<a href="http://www.runoob.com">www.runoob.com</a>”}</p>
<hr>
<h2 id="重要函数">重要函数</h2>
<p>用于转换json字符串与js对象</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/js/javascript-json-parse.html">JSON.parse()</a></td>
<td style="text-align:left">用于将一个 JSON 字符串转换为 JavaScript 对象。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/js/javascript-json-stringify.html">JSON.stringify()</a></td>
<td style="text-align:left">用于将 JavaScript 值转换为 JSON 字符串。</td>
</tr>
</tbody>
</table>
<h1>异步编程</h1>
<p>在前端编程中（甚至后端有时也是这样），我们在处理一些简短、快速的操作时，例如计算 1 + 1 的结果，往往在主线程中就可以完成。主线程作为一个线程，不能够同时接受多方面的请求。所以，当一个事件没有结束时，界面将无法处理其他请求。</p>
<p>现在有一个按钮，如果我们设置它的 onclick 事件为一个死循环，那么当这个按钮按下，整个网页将失去响应。</p>
<p>为了避免这种情况的发生，我们常常用子线程来完成一些可能消耗时间足够长以至于被用户察觉的事情，比如读取一个大文件或者发出一个网络请求。因为子线程独立于主线程，所以即使出现阻塞也不会影响主线程的运行。但是子线程有一个局限：一旦发射了以后就会与主线程失去同步，我们无法确定它的结束，如果结束之后需要处理一些事情，比如处理来自服务器的信息，我们是无法将它合并到主线程中去的。</p>
<p>为了解决这个问题，JavaScript 中的异步操作函数往往通过回调函数来实现异步任务的结果处理。</p>
<blockquote>
<p>值得一提的是，js里的同步与异步的概念是与我们现实生活中的同异步恰恰相反的。</p>
</blockquote>
<h2 id="回调函数">回调函数</h2>
<p>回调函数就是一个函数，它是在我们启动一个异步任务的时候就告诉它：等你完成了这个任务之后要干什么。这样一来主线程几乎不用关心异步任务的状态了，他自己会善始善终。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML=<span class="string">&quot;RUNOOB!&quot;</span>;</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>这是一个延时函数，将会在3000毫秒后执行。</p>
<h2 id="Promise">Promise</h2>
<p>Promise 是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;First&quot;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, <span class="number">4000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Third&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码实现了分三次输出字符串，第一次间隔 1 秒，第二次间隔 4 秒，第三次间隔 3 秒，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Run&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//这段程序会直接输出Run</span></span><br></pre></td></tr></table></figure>
<p>Promise 构造函数只有一个函数作为参数，叫做起始函数，起始函数有两个参数resolve 和 reject，其中调用 resolve 代表一切正常，reject 是出现异常时所调用的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) reject(<span class="string">&quot;Divide zero&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> resolve(a / b);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a / b = &quot;</span> + value);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;).finally(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;End&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段程序执行结果是:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a / b = <span class="number">0</span></span><br><span class="line">End</span><br></pre></td></tr></table></figure>
<hr>
<p>resolve() 中可以放置一个参数用于向下一个 then 传递一个值，then 中的函数也可以返回一个值传递给 then。但是，如果 then 中返回的是一个 Promise 对象，那么下一个 then 将相当于对这个返回的 Promise 进行操作，这一点从刚才的计时器的例子中可以看出来。</p>
<p>reject() 参数中一般会传递一个异常给之后的 catch 函数用于处理异常。</p>
<p>但是请注意以下两点：</p>
<ul>
<li>resolve 和 reject 的作用域只有起始函数，不包括 then 以及其他序列；</li>
<li>resolve 和 reject 并不能够使起始函数停止运行，别忘了 return。</li>
</ul>
<h3 id="Promise-函数">Promise 函数</h3>
<p>上述的 “计时器” 程序看上去比函数瀑布还要长，所以我们可以将它的核心部分写成一个 Promise 函数：</p>
<p>封装promise函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">delay, message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(message);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就可以放心大胆的实现程序功能了：</p>
<p>使用函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">print(<span class="number">1000</span>, <span class="string">&quot;First&quot;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> print(<span class="number">4000</span>, <span class="string">&quot;Second&quot;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    print(<span class="number">3000</span>, <span class="string">&quot;Third&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><em>这种返回值为一个 Promise 对象的函数称作 Promise 函数，它常常用于开发基于异步操作的库。</em></p>
<blockquote>
<p>下面是一些常见问题及解答的收录：</p>
<p><strong>Q: then、catch 和 finally 序列能否顺序颠倒？</strong></p>
<p>A: 可以，效果完全一样。但不建议这样做，最好按 then-catch-finally 的顺序编写程序。</p>
<p><strong>Q: 除了 then 块以外，其它两种块能否多次使用？</strong></p>
<p>A: 可以，finally 与 then 一样会按顺序执行，但是 catch 块只会执行第一个，除非 catch 块里有异常。所以最好只安排一个 catch 和 finally 块。</p>
<p><strong>Q: then 块如何中断？</strong></p>
<p>A: then 块默认会向下顺序执行，return 是不能中断的，可以通过 throw 来跳转至 catch 实现中断。</p>
<p><strong>Q: 什么时候适合用 Promise 而不是传统回调函数？</strong></p>
<p>A: 当需要多次顺序执行异步操作的时候，例如，如果想通过异步方法先后检测用户名和密码，需要先异步检测用户名，然后再异步检测密码的情况下就很适合 Promise。</p>
<p><strong>Q: Promise 是一种将异步转换为同步的方法吗？</strong></p>
<p>A: 完全不是。Promise 只不过是一种更良好的编程风格。</p>
<p><strong>Q: 什么时候我们需要再写一个 then 而不是在当前的 then 接着编程？</strong></p>
<p>A: 当你又需要调用一个异步任务的时候。</p>
</blockquote>
<h2 id="异步函数（async-function）">异步函数（async function）</h2>
<p>在之前的promise函数中，我们可以把接下来调用promise函数的过程变得更加简洁：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> print(<span class="number">1000</span>, <span class="string">&quot;First&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> print(<span class="number">4000</span>, <span class="string">&quot;Second&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> print(<span class="number">3000</span>, <span class="string">&quot;Third&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">asyncFunc();</span><br></pre></td></tr></table></figure>
<p>异步函数 async function 中可以使用 await 指令，await 指令后必须跟着一个 Promise，异步函数会在这个 Promise 运行中暂停，直到其运行结束再继续运行。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的I/O流</title>
    <url>/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/</url>
    <content><![CDATA[<h1>I/O框架</h1>
<h2 id="流的概念">流的概念</h2>
<p>流是内存与存储设备之间传输数据的通道，如果你学习过计算机组成原理或者是操作系统的话，那么你一定知道运行的程序是在内存中的，但程序需要的数据和程序想要写出的数据都保存在我们储存设备（比如磁盘）里的，所以这时候就需要一个进去和一个出来的通道，而这便是流的概念了。</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211215201600633.png" alt="image-20211215201600633"></p>
<h2 id="流的分类">流的分类</h2>
<p><strong>1、按方向分（主要）：</strong></p>
<p>· 输入流：存储设备-&gt;内存（input）</p>
<p>· 输出流：内存-&gt;存储设备（output）</p>
<p><strong>2、按单位分：</strong></p>
<p>· 字节流：以字节为单位，可以读写所有数据。</p>
<p>· 字符流：以字符为单位，只能读写文本数据。</p>
<p><strong>3、按功能分：</strong></p>
<p>· 节点流：具有实际传输数据的读写功能。</p>
<p>· 过滤流：在节点流的基础上增强功能。</p>
<h1>字节流</h1>
<p>字节流的父类（抽象类），我们来看看这些抽象类的一些方法：</p>
<p><strong>inputStream（输入字节流）</strong>：</p>
<p>1、public int read(){}</p>
<p>2、public int read(byte[] b){}</p>
<p>3、public int read(byte[] b,int off,int len){}</p>
<p><strong>OutputStream(输出字节流)：</strong></p>
<p>1、public void write(int n){}</p>
<p>2、public void write(byte[] b){}</p>
<p>3、public void write(byte[] b,int off,int len){}</p>
<h2 id="文件字节流">文件字节流</h2>
<p>文件字节流用于java程序与我们的电脑文件的数据交换。</p>
<p><strong>FileinputStream：</strong></p>
<p>1、public int read(read[] b)//从流中读取多个字节，将读到的内容存入b数组，返回实际读到的字节数；如果达到文件的尾部，则返回-1。</p>
<p><strong>FileOutputStream:</strong></p>
<p>1、public void write(byte[] b)//一次写多个字节，将b数组中所有的字节写入输出流。</p>
<h3 id="文件字节输入流">文件字节输入流</h3>
<p>下面我们来看看简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">       <span class="comment">//创建输入流并指定路径</span></span><br><span class="line">        FileInputStream fs = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;g:\\IOtest.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//尝试读取</span></span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">while</span> ((data=fs.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(data);</span><br><span class="line">        &#125;</span><br><span class="line">        fs.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创造文件g:\IOtest.txt以及输入内容：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219134520046.png" alt="image-20211219134520046"></p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219134601184.png" alt="image-20211219134601184"></p>
<p>输出：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219134629750.png" alt="image-20211219134629750"></p>
<p>这里需要注意的是：</p>
<p>1、我们使用的构造方法中的参数name代表的是我们电脑中文件的路径，所以得保证该路径有这个文件，不然就会报错。</p>
<p>2、采用的读取方法是read（），即每次只读取单个字节，所以我们需要循环输出语句while，并且由于结束条件是——“如果达到文件的尾部，则返回-1。”所以我们的data类型为int类型，这也导致了输出为所对应的ascii码值，但要是想解决也很好办，只需要输出时强制转换类型就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println((<span class="keyword">char</span>)data);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219134849648.png" alt="image-20211219134849648"></p>
<p>我们也可以一次读入多个字节，也就是使用byte数组来进行储存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">       <span class="comment">//创建输入流并指定路径</span></span><br><span class="line">        FileInputStream fs = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;g:\\IOtest.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//尝试读取</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>];</span><br><span class="line">       fs.read(buf);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        fs.read(buf);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        fs.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219135625281.png" alt="image-20211219135625281"></p>
<p>这里值得注意的是，每次调用read方法时，读入多少数据是由数组的大小决定的，会每次接着读取，直到最后数据不够。</p>
<h3 id="文件字节输出流">文件字节输出流</h3>
<p>我们依旧来写个例子吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">out</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileOutputStream fs = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;g:\\IOtest.txt&quot;</span>，<span class="keyword">true</span>);<span class="comment">//创建输出流对象,此处有一个重构，即第二个参数为true时，写入将接着前面的内容，不会重写覆盖。</span></span><br><span class="line">        fs.write(<span class="number">97</span>);</span><br><span class="line">        fs.write(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//本质上依然是转换成ascii码。</span></span><br><span class="line">        fs.write(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我把之前的文件已经清空。</p>
<p>输出：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219141244327.png" alt="image-20211219141244327"></p>
<p>看看文件内容：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219141325188.png" alt="image-20211219141325188"></p>
<p>当然，这种输入方式效率过于低下，我们依然可以采用数组的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">out</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileOutputStream fs = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;g:\\IOtest.txt&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        String sr=<span class="string">&quot;我是京介，请多指教！&quot;</span>;</span><br><span class="line">        fs.write(sr.getBytes());<span class="comment">//利用string转换为byte数组的方法；</span></span><br><span class="line">        fs.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219152607765.png" alt="image-20211219152607765"></p>
<p>看看文件：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219152635237.png" alt="image-20211219152635237"></p>
<p>大功告成！</p>
<h2 id="字节流复制">字节流复制</h2>
<p>输入流与输出流的配合，创造一个输入与输出，然后读一个写一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileLockInterruptionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fuzi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">        FileInputStream f1 = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;g:\\1.jpg&quot;</span>);</span><br><span class="line">        FileOutputStream f2 = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;g:\\2.jpg&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">while</span> ((count=f1.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            f2.write(count);</span><br><span class="line">        &#125;<span class="comment">//一边读一边写</span></span><br><span class="line">        f1.close();</span><br><span class="line">        f2.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;复制完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前的文件：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219153900302.png" alt="image-20211219153900302"></p>
<p>输出：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219153916320.png" alt="image-20211219153916320"></p>
<p>之后的文件夹：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219153949402.png" alt="image-20211219153949402"></p>
<p>这样我们就成功的复制了一张图片啦！</p>
<h2 id="字节缓冲流">字节缓冲流</h2>
<p>BufferedInputStream以及BufferedOutputStream为字节缓冲流，他们自己就已经拥有一个缓冲区，他们的作用是为其他的输入输出流套上一层缓冲的壳子，因为其他字节流（例如文件字节流）是内存与外存直接数据交流，所以效率很低，这时我们就可以用字节缓冲流来增进效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">huan</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileInputStream f1 = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;g:\\IOtest.txt&quot;</span>);</span><br><span class="line">        BufferedInputStream f2 = <span class="keyword">new</span> BufferedInputStream(f1);<span class="comment">//正是因为为其他流添加缓冲，所以参数是一个其他流，现在我们就用f2来代替f1执行功能。</span></span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">while</span> ((data=f2.read())!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(data+“ ”);</span><br><span class="line">        &#125;</span><br><span class="line">        f2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件还是我们那个老文件：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219162024335.png" alt="image-20211219162024335"></p>
<p>输出为：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219162107314.png" alt="一串熟悉的ascii码"></p>
<p>一串熟悉的ascii码。</p>
<p>在读取数据这一步时，其实是f2自己的缓冲区在进行读取，效率就高了许多。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs搭建简易web后端</title>
    <url>/2022/01/29/NodeJs%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93web%E5%90%8E%E7%AB%AF/</url>
    <content><![CDATA[<blockquote>
<p>更新于2022.1.29</p>
</blockquote>
<h1>什么是Nodejs？</h1>
<p>为了让JavaScript代码能够脱离浏览器独立进行运行，NodeJs便由此而生。JavaScript能够运行在浏览器的一大原因是浏览器内置了V8引擎，能够将JavaScript代码转换为机器语言，而NodeJs封装了v8引擎，本身由c++编写。也就可以正常运行。这样，JavaScript在电脑也可以正常运行。</p>
<p>此次我们要使用NodeJs制作一个简单的Web服务器。</p>
<h1>安装NodeJs</h1>
<p>网络下载安装包进行安装，此处不再赘述。</p>
<h1>认识https请求</h1>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>后端入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs学习</title>
    <url>/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/</url>
    <content><![CDATA[<h1>创建第一个应用</h1>
<p>在我们创建 Node.js 第一个 “Hello, World!” 应用前，让我们先了解下 Node.js 应用是由哪几部分组成的：</p>
<ol>
<li>**引入 required 模块：**我们可以使用 <strong>require</strong> 指令来载入 Node.js 模块。</li>
<li>**创建服务器：**服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。</li>
<li><strong>接收请求与响应请求</strong> 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。</li>
</ol>
<p>第一个应用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 HTTP 头部 </span></span><br><span class="line">    <span class="comment">// HTTP 状态值: 200 : OK</span></span><br><span class="line">    <span class="comment">// 内容类型: text/plain</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送响应数据 &quot;Hello World&quot;</span></span><br><span class="line">    response.end(<span class="string">&#x27;Hello World\n&#x27;</span>);</span><br><span class="line">&#125;).listen(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终端打印如下信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server running at http://127.0.0.1:8888/&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。</li>
<li>接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。</li>
</ul>
<h1>REPL(交互式解释器)</h1>
<p>Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Windows 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。</p>
<p>Node 自带了交互式解释器，可以执行以下任务：</p>
<ul>
<li><strong>读取</strong> - 读取用户输入，解析输入的 Javascript 数据结构并存储在内存中。</li>
<li><strong>执行</strong> - 执行输入的数据结构</li>
<li><strong>打印</strong> - 输出结果</li>
<li><strong>循环</strong> - 循环操作以上步骤直到用户两次按下 <strong>ctrl-c</strong> 按钮退出。</li>
</ul>
<p>Node 的交互式解释器可以很好的调试 Javascript 代码。</p>
<p>开始学习 REPL</p>
<p>我们可以输入以下命令来启动 Node 的终端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>
<p>注意，如果使用VScode编辑器的话，需要新建powershell终端，执行node命令，即可来到REPL界面。</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/image-20220427150117673.png" alt="image-20220427150117673"></p>
<h3 id="使用变量">使用变量</h3>
<p>你可以将数据存储在变量中，并在你需要的时候使用它。</p>
<p>变量声明需要使用 <strong>var</strong> 关键字，如果没有使用 var 关键字变量会直接打印出来。</p>
<p>使用 <strong>var</strong> 关键字的变量可以使用 console.log() 来输出变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; x = 10</span><br><span class="line">10</span><br><span class="line">&gt; var y = 10</span><br><span class="line">undefined</span><br><span class="line">&gt; x + y</span><br><span class="line">20</span><br><span class="line">&gt; console.log(&quot;Hello World&quot;)</span><br><span class="line">Hello World</span><br><span class="line">undefined</span><br><span class="line">&gt; console.log(&quot;Tosuke666&quot;)</span><br><span class="line">Tosuke666</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>
<h3 id="多行表达式">多行表达式</h3>
<p>Node REPL 支持输入多行表达式，这就有点类似 JavaScript。</p>
<blockquote>
<p>在表达式中换行，所出现的**…** 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。</p>
</blockquote>
<h3 id="下划线-变量">下划线(_)变量</h3>
<p>你可以使用下划线(_)获取上一个表达式的运算结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; var x = 10</span><br><span class="line">undefined</span><br><span class="line">&gt; var y = 20</span><br><span class="line">undefined</span><br><span class="line">&gt; x + y</span><br><span class="line">30</span><br><span class="line">&gt; var sum = _</span><br><span class="line">undefined</span><br><span class="line">&gt; console.log(sum)</span><br><span class="line">30</span><br><span class="line">undefined</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<h2 id="REPL-命令">REPL 命令</h2>
<ul>
<li><strong>ctrl + c</strong> - 退出当前终端。</li>
<li><strong>ctrl + c 按下两次</strong> - 退出 Node REPL。</li>
<li><strong>ctrl + d</strong> - 退出 Node REPL.</li>
<li><strong>向上/向下 键</strong> - 查看输入的历史命令</li>
<li><strong>tab 键</strong> - 列出当前命令</li>
<li><strong>.help</strong> - 列出使用命令</li>
<li><strong>.break</strong> - 退出多行表达式</li>
<li><strong>.clear</strong> - 退出多行表达式</li>
<li><strong>.save *filename*</strong> - 保存当前的 Node REPL 会话到指定文件</li>
<li><strong>.load *filename*</strong> - 载入当前 Node REPL 会话的文件内容。</li>
</ul>
<h1>Node.js 回调函数</h1>
<p>Node.js 异步编程的直接体现就是回调。</p>
<p>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。</p>
<p>回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。</p>
<p>例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。</p>
<p>回调函数一般作为函数的最后一个参数出现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo1(name, age, callback) &#123; &#125;</span><br><span class="line">function foo2(value, callback1, callback2) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>复习：<strong>回调函数</strong>是一种以<strong>参数形式</strong>传递给另一个<strong>函数</strong>的函数。</p>
<p>函数的设计有阻塞式与非阻塞式，阻塞式是一般的代码写法，一行一行代码的运行，遇到读取文件之类的代码便会等待程序读取文件，这样对高并发的任务来说很不友好。</p>
<p>但是运用回调函数我们便可以实现非阻塞代码：</p>
<p>创建一个文件 input.txt ，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tosuke666</span><br></pre></td></tr></table></figure>
<p>创建 main.js 文件, 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&#x27;input.txt&#x27;, function (err, data) &#123;</span><br><span class="line">    if (err) return console.error(err);</span><br><span class="line">    console.log(data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;程序执行结束!&quot;);</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">程序执行结束!</span><br><span class="line">Tosuke666</span><br></pre></td></tr></table></figure>
<p>可以看到，位于最后的函数反而要先于中间的函数执行，这是因为在回调函数读取文件的同时执行接下来的代码。</p>
<h1>EventEmitter-事件监听器</h1>
<p>刚开始听到事件监听的概念时，我脑海里总要浮现出一排排在地下室里面无表情死死地盯住电脑屏幕的监听者，而现在，nodeJS里面的EventEmitter就是指得这样一监听者。</p>
<p>nodejs里的一切行为（例如建立链接，读取文件）时都会触发事件，而这些对象都是events.EvenEmitter的实例。</p>
<p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</p>
<p>你可以通过require(“events”);来访问该模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 events 模块</span></span><br><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建 eventEmitter 对象</span></span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br></pre></td></tr></table></figure>
<p>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。</p>
<p>下面我们用一个简单的例子说明 EventEmitter 的用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//event.js 文件</span></span><br><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>).EventEmitter; </span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> EventEmitter(); </span><br><span class="line">event.on(<span class="string">&#x27;some_event&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;some_event 事件触发&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    event.emit(<span class="string">&#x27;some_event&#x27;</span>); </span><br><span class="line">&#125;, <span class="number">1000</span>); </span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p>运行这段代码，1 秒后控制台输出了 <strong>‘some_event 事件触发’</strong>。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p>
<p>再来看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #1</span></span><br><span class="line"><span class="keyword">var</span> listener1 = <span class="function"><span class="keyword">function</span> <span class="title">listener1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;监听器 listener1 执行。&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #2</span></span><br><span class="line"><span class="keyword">var</span> listener2 = <span class="function"><span class="keyword">function</span> <span class="title">listener2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;监听器 listener2 执行。&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，处理函数为 listener1 </span></span><br><span class="line">eventEmitter.addListener(<span class="string">&#x27;connection&#x27;</span>, listener1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，处理函数为 listener2</span></span><br><span class="line">eventEmitter.on(<span class="string">&#x27;connection&#x27;</span>, listener2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> eventListeners = eventEmitter.listenerCount(<span class="string">&#x27;connection&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(eventListeners + <span class="string">&quot; 个监听器监听连接事件。&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 connection 事件 </span></span><br><span class="line">eventEmitter.emit(<span class="string">&#x27;connection&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除监绑定的 listener1 函数</span></span><br><span class="line">eventEmitter.removeListener(<span class="string">&#x27;connection&#x27;</span>, listener1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;listener1 不再受监听。&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发连接事件</span></span><br><span class="line">eventEmitter.emit(<span class="string">&#x27;connection&#x27;</span>);</span><br><span class="line"></span><br><span class="line">eventListeners = eventEmitter.listenerCount(<span class="string">&#x27;connection&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(eventListeners + <span class="string">&quot; 个监听器监听连接事件。&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;程序执行完毕。&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码，执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">2 个监听器监听连接事件。</span><br><span class="line">监听器 listener1 执行。</span><br><span class="line">监听器 listener2 执行。</span><br><span class="line">listener1 不再受监听。</span><br><span class="line">监听器 listener2 执行。</span><br><span class="line">1 个监听器监听连接事件。</span><br><span class="line">程序执行完毕。</span><br></pre></td></tr></table></figure>
<p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p>
<p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p>
<p>接下来我们来具体看下 EventEmitter 的属性介绍：</p>
<h3 id="方法">方法</h3>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>addListener(event, listener)</strong> 为指定事件添加一个监听器到监听器数组的尾部。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>on(event, listener)</strong> 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。<code>server.on('connection', function (stream) &#123;  console.log('someone connected!'); &#125;);</code></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>once(event, listener)</strong> 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。<code>server.once('connection', function (stream) &#123;  console.log('Ah, we have our first user!'); &#125;);</code></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>removeListener(event, listener)</strong> 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。<code>var callback = function(stream) &#123;  console.log('someone connected!'); &#125;; server.on('connection', callback); // ... server.removeListener('connection', callback);</code></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>removeAllListeners([event])</strong> 移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>setMaxListeners(n)</strong> 默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于改变监听器的默认限制的数量。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>listeners(event)</strong> 返回指定事件的监听器数组。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>emit(event, [arg1], [arg2], […])</strong> 按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</td>
</tr>
</tbody>
</table>
<h3 id="类方法">类方法</h3>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>listenerCount(emitter, event)</strong> 返回指定事件的监听器数量。</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">events.EventEmitter.listenerCount(emitter, eventName) //已废弃，不推荐</span><br><span class="line">events.emitter.listenerCount(eventName) //推荐</span><br></pre></td></tr></table></figure>
<h3 id="事件">事件</h3>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">事件 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>newListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数该事件在添加新监听器时被触发。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>removeListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。</td>
</tr>
</tbody>
</table>
<h2 id="error-事件">error 事件</h2>
<p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p>
<p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p>
<p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var events = require(&#x27;events&#x27;); </span><br><span class="line">var emitter = new events.EventEmitter(); </span><br><span class="line">emitter.emit(&#x27;error&#x27;); </span><br></pre></td></tr></table></figure>
<h2 id="继承-EventEmitter">继承 EventEmitter</h2>
<p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p>
<p>为什么要这样做呢？原因有两点：</p>
<p>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。</p>
<p>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>
<h1>Stream(流)</h1>
<p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。</p>
<p>Node.js，Stream 有四种流类型：</p>
<ul>
<li><strong>Readable</strong> - 可读操作。</li>
<li><strong>Writable</strong> - 可写操作。</li>
<li><strong>Duplex</strong> - 可读可写操作.</li>
<li><strong>Transform</strong> - 操作被写入数据，然后读出结果。</li>
</ul>
<p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p>
<ul>
<li><strong>data</strong> - 当有数据可读时触发。</li>
<li><strong>end</strong> - 没有更多的数据可读时触发。</li>
<li><strong>error</strong> - 在接收和写入过程中发生错误时触发。</li>
<li><strong>finish</strong> - 所有数据已被写入到底层系统时触发。</li>
</ul>
<h2 id="从流中读取数据">从流中读取数据</h2>
<p>创建 input.txt 文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">欢迎访问京介的博客：https://tosuke.gitee.io/</span><br></pre></td></tr></table></figure>
<p>创建js文件如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> readstearm = fs.createReadStream(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">readstearm.setEncoding(<span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">readstearm.on(<span class="string">&#x27;data&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">word</span>)</span>&#123;</span><br><span class="line">data+=word;</span><br><span class="line">&#125;)</span><br><span class="line">readstearm.on(<span class="string">&#x27;end&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;文件中的内容是：&quot;</span>+data);</span><br><span class="line">&#125;)</span><br><span class="line">readstearm.on(<span class="string">&#x27;error&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.stack);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;有可能没有这个文件，请检查。&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;程序执行完毕。&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果有文件的，结果如下：</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/image-20220428151601986.png" alt="image-20220428151601986"></p>
<p>这是因为有文件内容可读取，响应了data事件。</p>
<p>如果没有这个文件（手动把input删了）：</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/image-20220428152251848.png" alt="image-20220428152251848"></p>
<p>这是因为没有文件可读，触发了error事件。</p>
<h2 id="写入流">写入流</h2>
<p>依然举例说明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&#x27;我是京介，欢迎访问我的博客。&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可以写入的流，写入到文件 output.txt 中</span></span><br><span class="line"><span class="keyword">var</span> writerStream = fs.createWriteStream(<span class="string">&#x27;output.txt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 utf8 编码写入数据</span></span><br><span class="line">writerStream.write(data,<span class="string">&#x27;UTF8&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记文件末尾</span></span><br><span class="line">writerStream.end();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理流事件 --&gt; finish、error</span></span><br><span class="line">writerStream.on(<span class="string">&#x27;finish&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;写入完成。&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">writerStream.on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(err.stack);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;程序执行完毕&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/image-20220428204337656.png" alt="image-20220428204337656"></p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/image-20220428204359281.png" alt="image-20220428204359281"></p>
<p>就这样我们的js把数据写入了“woc.txt”。</p>
<h2 id="管道流">管道流</h2>
<p>管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/bVcla61" alt="img"></p>
<p>如上面的图片所示，我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶使得水从一个桶流入另一个桶，这样就慢慢的实现了大文件的复制过程。</p>
<p>以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">//引入文件</span></span><br><span class="line"><span class="keyword">var</span> re = fs.createReadStream(<span class="string">&#x27;woc.txt&#x27;</span>);</span><br><span class="line"><span class="comment">//创建读取流（读取woc.txt）</span></span><br><span class="line"><span class="keyword">var</span> we = fs.createWriteStream(<span class="string">&#x27;new.txt&#x27;</span>);</span><br><span class="line"><span class="comment">//创建写出流（写入new.txt）</span></span><br><span class="line">re.pipe(we);</span><br><span class="line"><span class="comment">//用管道函数将读取流接根管子到写出流，这样就不用写事件函数了</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;程序执行完成&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>woc.txt内容为：</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/image-20220429110158682.png" alt="image-20220429110158682"></p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">程序执行完成</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/image-20220429110220215.png" alt="image-20220429110220215"></p>
<h2 id="链式流">链式流</h2>
<p>链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。</p>
<p>接下来我们就是用管道和链式来压缩和解压文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 input.txt 文件为 input.txt.gz</span></span><br><span class="line">fs.createReadStream(<span class="string">&#x27;input.txt&#x27;</span>)</span><br><span class="line">  .pipe(zlib.createGzip())</span><br><span class="line">  .pipe(fs.createWriteStream(<span class="string">&#x27;input.txt.gz&#x27;</span>));</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;文件压缩完成。&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ node compress.js </span><br><span class="line">文件压缩完成。</span><br></pre></td></tr></table></figure>
<p>执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。</p>
<p>接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解压 input.txt.gz 文件为 input.txt</span></span><br><span class="line">fs.createReadStream(<span class="string">&#x27;input.txt.gz&#x27;</span>)</span><br><span class="line">  .pipe(zlib.createGunzip())</span><br><span class="line">  .pipe(fs.createWriteStream(<span class="string">&#x27;input.txt&#x27;</span>));</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;文件解压完成。&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ node decompress.js </span><br><span class="line">文件解压完成。</span><br></pre></td></tr></table></figure>
<p>总之，管道流加上链式结构可以很方便的传输信息，pipe函数就像接了一根管子出去给参数流接收。</p>
<h1>模块系统</h1>
<p>为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。</p>
<p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。</p>
<h2 id="引入模块">引入模块</h2>
<p>引入模块非常简单，代码举例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="built_in">require</span>(<span class="string">&#x27;./hello&#x27;</span>);</span><br><span class="line">hello.test();</span><br></pre></td></tr></table></figure>
<p>代码 require(‘./hello’) 引入了当前目录下的 hello.js 文件（./ 为当前目录，node.js 默认后缀为 js）。并且使用了hello里的test函数，</p>
<p>Node.js 提供了 exports 和 require 两个对象，exports是向外导出，而require大家应该都很熟悉，向内获取。</p>
<p>require我们不再赘述，下面来创建我们刚刚引入的hello.js里的函数吧。</p>
<p>在hello.js中，我们用exports写下以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.world = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，hello.js里的world函数就可以在其他js文件里使用了，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 之前的例子中通过 require(‘./hello’) 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。</p>
<h2 id="对象封装到模块">对象封装到模块</h2>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hello.js </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> name; </span><br><span class="line">    <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>) </span>&#123; </span><br><span class="line">        name = thyName; </span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="built_in">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Hello &#x27;</span> + name); </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">module</span>.exports = Hello;</span><br></pre></td></tr></table></figure>
<p>这样就可以直接获得这个对象了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js </span></span><br><span class="line"><span class="keyword">var</span> Hello = <span class="built_in">require</span>(<span class="string">&#x27;./hello&#x27;</span>); </span><br><span class="line">hello = <span class="keyword">new</span> Hello(); </span><br><span class="line">hello.setName(<span class="string">&#x27;BYVoid&#x27;</span>); </span><br><span class="line">hello.sayHello(); </span><br></pre></td></tr></table></figure>
<p>模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。</p>
<h2 id="服务端的模块">服务端的模块</h2>
<p>Node.js 中自带了一个叫做 <strong>http</strong> 的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。</p>
<p>这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。</p>
<p>Node.js 的 require 方法中的文件查找策略如下：</p>
<p>由于 Node.js 中存在 4 类模块（原生模块和3种文件模块），尽管 require 方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示：</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/image-20220429114034069.png" alt="图片来自菜鸟教程"></p>
<h3 id="从文件模块缓存中加载">从文件模块缓存中加载</h3>
<p>尽管原生模块与文件模块的优先级不同，但是都会优先从文件模块的缓存中加载已经存在的模块。</p>
<h3 id="从原生模块加载">从原生模块加载</h3>
<p>原生模块的优先级仅次于文件模块缓存的优先级。require 方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个 http/http.js/http.node/http.json 文件，require(“http”) 都不会从这些文件中加载，而是从原生模块中加载。</p>
<p>原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。</p>
<h3 id="从文件加载">从文件加载</h3>
<p>当文件模块缓存中不存在，而且不是原生模块的时候，Node.js 会解析 require 方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。</p>
<p>require方法接受以下几种参数的传递：</p>
<ul>
<li>http、fs、path等，原生模块。</li>
<li>./mod或…/mod，相对路径的文件模块。</li>
<li>/pathtomodule/mod，绝对路径的文件模块。</li>
<li>mod，非原生模块的文件模块。</li>
</ul>
<blockquote>
<p>不建议同时使用 exports 和 module.exports。</p>
<p>如果先使用 exports 对外暴露属性或方法，再使用 module.exports 暴露对象，会使得 exports 上暴露的属性或者方法失效</p>
</blockquote>
<h1>函数</h1>
<p>在 JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。</p>
<h2 id="1、函数也能作为参数">1、函数也能作为参数</h2>
<p>我们看下面的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">someFunction, value</span>) </span>&#123;</span><br><span class="line">  someFunction(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义时就是参数为一个函数，第二的参数作为第一个函数的参数。</span></span><br><span class="line">execute(say, <span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码中，我们把 say 函数作为 execute 函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！</p>
<p>这样一来， say 就变成了execute 中的本地变量 someFunction ，execute 可以通过调用 someFunction() （带括号的形式）来使用 say 函数。</p>
<p>当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。</p>
<h2 id="HTTP服务器工作">HTTP服务器工作</h2>
<p>带着这些知识，我们再来看看回顾一下之前的启用HTTP服务器的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span>&#125;);</span><br><span class="line">  response.write(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;).listen(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>
<p>现在它看上去应该清晰了很多：我们向 createServer 函数传递了一个匿名函数。</p>
<p>用这样的代码也可以达到同样的目的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span>&#125;);</span><br><span class="line">  response.write(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>
<p>这样就不是匿名函数了，会看起来麻烦一点。</p>
<h1>全局对象</h1>
<p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p>
<p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p>
<p>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p>
<blockquote>
<p><strong>注意：</strong> 最好不要使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险（引用错变量）。</p>
</blockquote>
<h2 id="filename">__filename</h2>
<p><strong>__filename</strong> 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。</p>
<h2 id="dirname">__dirname</h2>
<p><strong>__dirname</strong> 表示当前执行脚本所在的目录。</p>
<h2 id="setTimeout-cb-ms">setTimeout(cb, ms)</h2>
<p><strong>setTimeout(cb, ms)</strong> 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。</p>
<p>返回一个代表定时器的句柄值。</p>
<h3 id="实例">实例</h3>
<p>创建文件 main.js ，代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log( <span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两秒后执行以上函数</span></span><br><span class="line"><span class="built_in">setTimeout</span>(printHello, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
<p>执行 main.js 文件，代码如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>
<h2 id="clearTimeout-t">clearTimeout(t)</h2>
<p><strong>clearTimeout( t )</strong> 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。 参数 <strong>t</strong> 是通过 setTimeout() 函数创建的定时器。</p>
<h3 id="实列">实列</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log( <span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两秒后执行以上函数</span></span><br><span class="line"><span class="built_in">setInterval</span>(printHello, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
<p>结果是它每隔两分钟就会打印一次hello，world！直到按下 <strong>ctrl + c</strong>。</p>
<h2 id="console">console</h2>
<p>console是我们经常使用的全局变量，console.log想必大家经常使用。</p>
<p>console 用于提供控制台标准输出，它是由 Internet Explorer 的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的实施标准。</p>
<p>Node.js 沿用了这个标准，提供与习惯行为一致的 console 对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。</p>
<h3 id="console-方法">console 方法</h3>
<p>以下为 console 对象的方法:</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>console.log([data][, …])</strong> 向标准输出流打印字符并以换行符结束。该方法接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong><a href="http://console.info">console.info</a>([data][, …])</strong> 该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>console.error([data][, …])</strong> 输出错误消息的。控制台在出现错误时会显示是红色的叉子。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>console.warn([data][, …])</strong> 输出警告消息。控制台出现有黄色的惊叹号。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>console.dir(obj[, options])</strong> 用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>console.time(label)</strong> 输出时间，表示计时开始。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>console.timeEnd(label)</strong> 结束时间，表示计时结束。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>console.trace(message[, …])</strong> 当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数里面加入 console.trace 就行了。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><strong>console.assert(value[, message][, …])</strong> 用于判断某个表达式或变量是否为真，接收两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。</td>
</tr>
</tbody>
</table>
<h2 id="process">process</h2>
<p>process 是一个全局变量，即 global 对象的属性。</p>
<p>它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。下面将会介绍 process 对象的一些最常用的成员方法。</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">事件 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>exit</strong> 当进程准备退出时触发。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>beforeExit</strong> 当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 ‘beforeExit’ 的监听器可以异步调用，这样 node 就会继续执行。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>uncaughtException</strong> 当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>Signal 事件</strong> 当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。</td>
</tr>
</tbody>
</table>
<p>process.exit()函数用结束当前进程。参数为0为正常结束，参数为1是表示由于某种故障而结束进程。</p>
<p>以下为退出状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">名称 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>Uncaught Fatal Exception</strong> 有未捕获异常，并且没有被域或 uncaughtException 处理函数处理。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>Unused</strong> 保留，由 Bash 预留用于内置误用</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>Internal JavaScript Parse Error</strong> JavaScript的源码启动 Node 进程时引起解析错误。非常罕见，仅会在开发 Node 时才会有。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>Internal JavaScript Evaluation Failure</strong> JavaScript 的源码启动 Node 进程，评估时返回函数失败。非常罕见，仅会在开发 Node 时才会有。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>Fatal Error</strong> V8 里致命的不可恢复的错误。通常会打印到 stderr ，内容为： FATAL ERROR</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>Non-function Internal Exception Handler</strong> 未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>Internal Exception Handler Run-Time Failure</strong> 未捕获的异常， 并且异常处理函数处理时自己抛出了异常。例如，如果 process.on(‘uncaughtException’) 或 domain.on(‘error’) 抛出了异常。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>Unused</strong> 保留，在以前版本的 Node.js 中，退出码 8 有时表示未捕获的异常。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><strong>Invalid Argument</strong> 可能是给了未知的参数，或者给的参数没有值。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><strong>Internal JavaScript Run-Time Failure</strong> JavaScript的源码启动 Node 进程时抛出错误，非常罕见，仅会在开发 Node 时才会有。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><strong>Invalid Debug Argument</strong> 设置了参数–debug 和/或 --debug-brk，但是选择了错误端口。</td>
</tr>
<tr>
<td style="text-align:left">128</td>
<td style="text-align:left"><strong>Signal Exits</strong> 如果 Node 接收到致命信号，比如SIGKILL 或 SIGHUP，那么退出代码就是128 加信号代码。这是标准的 Unix 做法，退出信号代码放在高位。</td>
</tr>
</tbody>
</table>
<h3 id="Process-属性">Process 属性</h3>
<p>Process 提供了很多有用的属性，便于我们更好的控制系统的交互：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号.</th>
<th style="text-align:left">属性 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>stdout</strong> 标准输出流。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>stderr</strong> 标准错误流。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>stdin</strong> 标准输入流。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>argv</strong> argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>execPath</strong> 返回执行当前脚本的 Node 二进制文件的绝对路径。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>execArgv</strong> 返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>env</strong> 返回一个对象，成员为当前 shell 的环境变量</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>exitCode</strong> 进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><strong>version</strong> Node 的版本，比如v0.10.18。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><strong>versions</strong> 一个属性，包含了 node 的版本和依赖.</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><strong>config</strong> 一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 ./configure 脚本生成的 “config.gypi” 文件相同。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><strong>pid</strong> 当前进程的进程号。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><strong>title</strong> 进程名，默认值为&quot;node&quot;，可以自定义该值。</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><strong>arch</strong> 当前 CPU 的架构：‘arm’、‘ia32’ 或者 ‘x64’。</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><strong>platform</strong> 运行程序所在的平台系统 ‘darwin’, ‘freebsd’, ‘linux’, ‘sunos’ 或 ‘win32’</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left"><strong>mainModule</strong> require.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。</td>
</tr>
</tbody>
</table>
<p>试用一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出到终端</span></span><br><span class="line">process.stdout.write(<span class="string">&quot;Hello World!&quot;</span> + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过参数读取</span></span><br><span class="line">process.argv.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">val, index, array</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(index + <span class="string">&#x27;: &#x27;</span> + val);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 获取执行路径</span></span><br><span class="line"><span class="built_in">console</span>.log(process.execPath);</span><br><span class="line"><span class="comment">// 平台信息</span></span><br><span class="line"><span class="built_in">console</span>.log(process.platform);</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">0: node</span><br><span class="line">1: /web/www/node/main.js</span><br><span class="line">/usr/local/node/0.10.36/bin/node</span><br><span class="line">darwin</span><br></pre></td></tr></table></figure>
<h3 id="方法参考手册（了解）">方法参考手册（了解）</h3>
<p>Process 提供了很多有用的方法，便于我们更好的控制系统的交互：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>abort()</strong> 这将导致 node 触发 abort 事件。会让 node 退出并生成一个核心文件。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>chdir(directory)</strong> 改变当前工作进程的目录，如果操作失败抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>cwd()</strong> 返回当前进程的工作目录</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>exit([code])</strong> 使用指定的 code 结束进程。如果忽略，将会使用 code 0。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>getgid()</strong> 获取进程的群组标识（参见 getgid(2)）。获取到的是群组的数字 id，而不是名字。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>setgid(id)</strong> 设置进程的群组标识（参见 setgid(2)）。可以接收数字 ID 或者群组名。如果指定了群组名，会阻塞等待解析为数字 ID 。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>getuid()</strong> 获取进程的用户标识(参见 getuid(2))。这是数字的用户 id，不是用户名。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>setuid(id)</strong> 设置进程的用户标识（参见setuid(2)）。接收数字 ID或字符串名字。如果指定了群组名，会阻塞等待解析为数字 ID 。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><strong>getgroups()</strong> 返回进程的群组 ID 数组。POSIX 系统没有保证一定有，但是 node.js 保证有。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><strong>setgroups(groups)</strong> 设置进程的群组 ID。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><strong>initgroups(user, extra_group)</strong> 读取 /etc/group ，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><strong>kill(pid[, signal])</strong> 发送信号给进程. pid 是进程id，并且 signal 是发送的信号的字符串描述。信号名是字符串，比如 ‘SIGINT’ 或 ‘SIGHUP’。如果忽略，信号会是 ‘SIGTERM’。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><strong>memoryUsage()</strong> 返回一个对象，描述了 Node 进程所用的内存状况，单位为字节。</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><strong>nextTick(callback)</strong> 一旦当前事件循环结束，调用回调函数。</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><strong>umask([mask])</strong> 设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask 参数有效，返回旧的掩码。否则，返回当前掩码。</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left"><strong>uptime()</strong> 返回 Node 已经运行的秒数。</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left"><strong>hrtime()</strong> 返回当前进程的高分辨时间，形式为 [seconds, nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。 你可以将之前的结果传递给当前的 process.hrtime() ，会返回两者间的时间差，用来基准和测量时间间隔。</td>
</tr>
</tbody>
</table>
<h1>Buffer(缓冲区)</h1>
<p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。</p>
<p>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。</p>
<p>在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p>
<h2 id="Buffer-与字符编码">Buffer 与字符编码</h2>
<p>Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。</p>
<blockquote>
<p><em>建议使用</em> <strong>Buffer.from()</strong> <em>接口去创建Buffer对象。</em></p>
<p><strong>用法:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Buffer.from( object, encoding )</span><br></pre></td></tr></table></figure>
<p>**参数：**该方法接受上述和以下所述的两个参数：</p>
<ul>
<li>**object:**此参数可以包含字符串，缓冲区，数组或arrayBuffer。</li>
<li>**encoding:**如果对象是字符串，则用于指定其编码。它是可选参数。其默认值为utf8。</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = Buffer.from(<span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;ascii&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 72756e6f6f62</span></span><br><span class="line"><span class="built_in">console</span>.log(buf.toString(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 cnVub29i</span></span><br><span class="line"><span class="built_in">console</span>.log(buf.toString(<span class="string">&#x27;base64&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>返回为字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Buffer.toString( encoding, start, end )</span><br></pre></td></tr></table></figure>
<p>**参数：**该方法接受上述和以下所述的三个参数：</p>
<ul>
<li>**encoding:**缓冲区数据字符必须被编码的格式。默认值为“ utf8”。</li>
<li>**start:**必须从其开始编码的缓冲区数据的起始索引。其默认值为0。</li>
<li>**end:**缓冲区数据的最后一个索引，必须对其进行编码。其默认值为Buffer.length。</li>
</ul>
<p>**返回值：**它根据指定的字符编码将解码后的字符串从缓冲区返回到字符串。</p>
<p><strong>Node.js 目前支持的字符编码包括：</strong></p>
<ul>
<li><strong>ascii</strong> - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。</li>
<li><strong>utf8</strong> - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。</li>
<li><strong>utf16le</strong> - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</li>
<li><strong>ucs2</strong> - <strong>utf16le</strong> 的别名。</li>
<li><strong>base64</strong> - Base64 编码。</li>
<li><strong>latin1</strong> - 一种把 <strong>Buffer</strong> 编码成一字节编码的字符串的方式。</li>
<li><strong>binary</strong> - <strong>latin1</strong> 的别名。</li>
<li><strong>hex</strong> - 将每个字节编码为两个十六进制字符。</li>
</ul>
<h2 id="创建buffer类">创建buffer类</h2>
<p>一般我们常用的为以下三种：</p>
<ul>
<li>
<p><strong>Buffer.alloc(size[, fill[, encoding]])：</strong> 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0</p>
</li>
<li>
<p><strong>Buffer.allocUnsafe(size)：</strong> 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据</p>
</li>
<li>
<p><strong>Buffer.from(arrayBuffer[, byteOffset[, length]])：</strong> 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。</p>
<p>总结来说： Buffer.from()从字符串或者数组创建一个buffer, Buffer.alloc()是创建一个指定大小的buffer。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个长度为 10、且用 0 填充的 Buffer（默认情况）。</span></span><br><span class="line"><span class="keyword">const</span> buf1 = Buffer.alloc(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个长度为 10、且用 0x1 填充的 Buffer（给定值fill）。 </span></span><br><span class="line"><span class="keyword">const</span> buf2 = Buffer.alloc(<span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个长度为 10、且未初始化的 Buffer。</span></span><br><span class="line"><span class="comment">// 这个方法比调用 Buffer.alloc() 更快，</span></span><br><span class="line"><span class="comment">// 但返回的 Buffer 实例可能包含旧数据，</span></span><br><span class="line"><span class="comment">// 因此需要使用 fill() 或 write() 重写。</span></span><br><span class="line"><span class="keyword">const</span> buf3 = Buffer.allocUnsafe(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer（十六进制）。</span></span><br><span class="line"><span class="keyword">const</span> buf4 = Buffer.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer（十六进制的ascll码）。</span></span><br><span class="line"><span class="keyword">const</span> buf5 = Buffer.from(<span class="string">&#x27;tést&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含 Latin-1 （编码格式）字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。</span></span><br><span class="line"><span class="keyword">const</span> buf6 = Buffer.from(<span class="string">&#x27;tést&#x27;</span>, <span class="string">&#x27;latin1&#x27;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般创建可接纳的缓冲区时最后的一个参数为编码格式。</p>
</blockquote>
</li>
</ul>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/image-20220503230842393.png" alt="image-20220503230842393"></p>
<p>结果为：</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/image-20220503230904283.png" alt="image-20220503230904283"></p>
<p>我们反手来到一个十六进制ascll码转字符串的网站，将我们的buf1的内容来揭秘一下：</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/image-20220503231030197.png" alt="image-20220503231030197"></p>
<h2 id="关于buffer的操作">关于buffer的操作</h2>
<h3 id="写入缓冲区">写入缓冲区</h3>
<p>写入 Node 缓冲区的语法如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">buf.write(string[, offset[, length]][, encoding])</span><br></pre></td></tr></table></figure>
<h3 id="参数">参数</h3>
<p>参数描述如下：</p>
<ul>
<li><strong>string</strong> - 写入缓冲区的字符串。</li>
<li><strong>offset</strong> - 缓冲区开始写入的索引值，默认为 0 。</li>
<li><strong>length</strong> - 写入的字节数，默认为 buffer.length</li>
<li><strong>encoding</strong> - 使用的编码。默认为 ‘utf8’ 。</li>
</ul>
<p>根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。</p>
<p>写入函数返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。</p>
<h3 id="将-Buffer-转换为-JSON-对象">将 Buffer 转换为 JSON 对象</h3>
<p>将 Node Buffer 转换为 JSON 对象的函数语法格式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">buf.toJSON()</span><br></pre></td></tr></table></figure>
<p>该函数会直接返回一个json对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = Buffer.from([<span class="number">0x1</span>, <span class="number">0x2</span>, <span class="number">0x3</span>, <span class="number">0x4</span>, <span class="number">0x5</span>]);</span><br><span class="line"><span class="keyword">const</span> json = <span class="built_in">JSON</span>.stringify(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: &#123;&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(json);</span><br><span class="line"><span class="comment">//顺便回顾一下json的解析</span></span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">JSON</span>.parse(json, <span class="function">(<span class="params">key, value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> value &amp;&amp; value.type === <span class="string">&#x27;Buffer&#x27;</span> ?</span><br><span class="line">    Buffer.from(value.data) :</span><br><span class="line">    value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: &lt;Buffer 01 02 03 04 05&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(copy);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="缓冲区合并">缓冲区合并</h3>
<p>Node 缓冲区合并的语法如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Buffer.concat(list[, totalLength])</span><br></pre></td></tr></table></figure>
<h3 id="参数-2">参数</h3>
<p>参数描述如下：</p>
<ul>
<li><strong>list</strong> - 用于合并的 Buffer 对象数组列表。</li>
<li><strong>totalLength</strong> - 指定合并后Buffer对象的总长度。</li>
</ul>
<h3 id="返回值">返回值</h3>
<p>返回一个多个成员合并的新 Buffer 对象。</p>
<h3 id="拷贝缓冲区">拷贝缓冲区</h3>
<h3 id="语法">语法</h3>
<p>Node 缓冲区拷贝语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</span><br></pre></td></tr></table></figure>
<h3 id="参数-3">参数</h3>
<p>参数描述如下：</p>
<ul>
<li><strong>targetBuffer</strong> - 要拷贝的 Buffer 对象。</li>
<li><strong>targetStart</strong> - 数字, 可选, 默认: 0</li>
<li><strong>sourceStart</strong> - 数字, 可选, 默认: 0</li>
<li><strong>sourceEnd</strong> - 数字, 可选, 默认: buffer.length</li>
</ul>
<h2 id="缓冲区长度">缓冲区长度</h2>
<h3 id="语法-2">语法</h3>
<p>Node 缓冲区长度计算语法如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">buf.length;</span><br></pre></td></tr></table></figure>
<h3 id="返回值-2">返回值</h3>
<p>返回 Buffer 对象所占据的内存长度。</p>
<h1>文件系统</h1>
<p>Node.js 提供一组类似 UNIX（POSIX）标准的文件操作API。 Node 导入文件系统模块(fs)语法如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>在流的那一节我们就已经用到了fs模块，并且用fs创建了输出流以及写入流。</p>
<h2 id="异步和同步">异步和同步</h2>
<p>Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。</p>
<p>异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。</p>
<p>建议大家使用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。</p>
<p>举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步读取</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;input.txt&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;异步读取: &quot;</span> + data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步读取</span></span><br><span class="line"><span class="keyword">var</span> data = fs.readFileSync(<span class="string">&#x27;input.txt&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;同步读取: &quot;</span> + data.toString());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;程序执行完毕。&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>input文件为stream那时的文件。</p>
<p>结果执行如下：</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/image-20220501171800358.png" alt="image-20220501171800358"></p>
<p>你会发现是代码在下的同步读取在前，因为异步在读取代码时不会阻塞代码，会继续向下执行。</p>
<p>接下来，让我们来具体了解下 Node.js 文件系统的方法。</p>
<hr>
<h2 id="打开文件">打开文件</h2>
<h3 id="语法-3">语法</h3>
<p>以下为在异步模式下打开文件的语法格式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.open(path, flags[, mode], callback)</span><br></pre></td></tr></table></figure>
<h3 id="参数-4">参数</h3>
<p>参数使用说明如下：</p>
<ul>
<li><strong>path</strong> - 文件的路径。</li>
<li><strong>flags</strong> - 文件打开的行为。具体值详见下文。</li>
<li><strong>mode</strong> - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。</li>
<li><strong>callback</strong> - 回调函数，带有两个参数如：callback(err, fd)。</li>
</ul>
<p>flags 参数可以是以下值：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Flag</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">r</td>
<td style="text-align:left">以读取模式打开文件。如果文件不存在抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">r+</td>
<td style="text-align:left">以读写模式打开文件。如果文件不存在抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">rs</td>
<td style="text-align:left">以同步的方式读取文件。</td>
</tr>
<tr>
<td style="text-align:left">rs+</td>
<td style="text-align:left">以同步的方式读取和写入文件。</td>
</tr>
<tr>
<td style="text-align:left">w</td>
<td style="text-align:left">以写入模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td style="text-align:left">wx</td>
<td style="text-align:left">类似 ‘w’，但是如果文件路径存在，则文件写入失败。</td>
</tr>
<tr>
<td style="text-align:left">w+</td>
<td style="text-align:left">以读写模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td style="text-align:left">wx+</td>
<td style="text-align:left">类似 ‘w+’， 但是如果文件路径存在，则文件读写失败。</td>
</tr>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">以追加模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td style="text-align:left">ax</td>
<td style="text-align:left">类似 ‘a’， 但是如果文件路径存在，则文件追加失败。</td>
</tr>
<tr>
<td style="text-align:left">a+</td>
<td style="text-align:left">以读取追加模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td style="text-align:left">ax+</td>
<td style="text-align:left">类似 ‘a+’， 但是如果文件路径存在，则文件读取追加失败。获取文件信息</td>
</tr>
</tbody>
</table>
<h2 id="获取文件信息">获取文件信息</h2>
<h3 id="语法-4">语法</h3>
<p>以下为通过异步模式获取文件信息的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fs.stat(path, callback)</span><br></pre></td></tr></table></figure>
<h3 id="参数-5">参数</h3>
<p>参数使用说明如下：</p>
<ul>
<li><strong>path</strong> - 文件路径。</li>
<li><strong>callback</strong> - 回调函数，带有两个参数如：(err, stats), <strong>stats</strong> 是 fs.Stats 对象。</li>
</ul>
<p>fs.stat(path)执行后，会将stats类的实例返回给其回调函数。可以通过stats类中的提供方法判断文件的相关属性。例如判断是否为文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.stat(<span class="string">&#x27;/Users/liuht/code/itbilu/demo/fs.js&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(stats.isFile());         <span class="comment">//true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>stats类中的方法有：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">stats.isFile()</td>
<td style="text-align:left">如果是文件返回 true，否则返回 false。</td>
</tr>
<tr>
<td style="text-align:left">stats.isDirectory()</td>
<td style="text-align:left">如果是目录返回 true，否则返回 false。</td>
</tr>
<tr>
<td style="text-align:left">stats.isBlockDevice()</td>
<td style="text-align:left">如果是块设备返回 true，否则返回 false。</td>
</tr>
<tr>
<td style="text-align:left">stats.isCharacterDevice()</td>
<td style="text-align:left">如果是字符设备返回 true，否则返回 false。</td>
</tr>
<tr>
<td style="text-align:left">stats.isSymbolicLink()</td>
<td style="text-align:left">如果是软链接返回 true，否则返回 false。</td>
</tr>
<tr>
<td style="text-align:left">stats.isFIFO()</td>
<td style="text-align:left">如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。</td>
</tr>
<tr>
<td style="text-align:left">stats.isSocket()</td>
<td style="text-align:left">如果是 Socket 返回 true，否则返回 false。</td>
</tr>
</tbody>
</table>
<p>我们可以使用这些方法来查看文件的一些情况。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;准备打开文件！&quot;</span>);</span><br><span class="line">fs.stat(<span class="string">&#x27;input.txt&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(stats);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;读取文件信息成功！&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 检测文件类型</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;是否为文件(isFile) ? &quot;</span> + stats.isFile());</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;是否为目录(isDirectory) ? &quot;</span> + stats.isDirectory());    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">准备打开文件！</span><br><span class="line">&#123; <span class="attr">dev</span>: <span class="number">16777220</span>,</span><br><span class="line">  <span class="attr">mode</span>: <span class="number">33188</span>,</span><br><span class="line">  <span class="attr">nlink</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">uid</span>: <span class="number">501</span>,</span><br><span class="line">  <span class="attr">gid</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">rdev</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">blksize</span>: <span class="number">4096</span>,</span><br><span class="line">  <span class="attr">ino</span>: <span class="number">40333161</span>,</span><br><span class="line">  <span class="attr">size</span>: <span class="number">61</span>,</span><br><span class="line">  <span class="attr">blocks</span>: <span class="number">8</span>,</span><br><span class="line">  <span class="attr">atime</span>: Mon Sep <span class="number">07</span> <span class="number">2015</span> <span class="number">17</span>:<span class="number">43</span>:<span class="number">55</span> GMT+<span class="number">0800</span> (CST),</span><br><span class="line">  <span class="attr">mtime</span>: Mon Sep <span class="number">07</span> <span class="number">2015</span> <span class="number">17</span>:<span class="number">22</span>:<span class="number">35</span> GMT+<span class="number">0800</span> (CST),</span><br><span class="line">  <span class="attr">ctime</span>: Mon Sep <span class="number">07</span> <span class="number">2015</span> <span class="number">17</span>:<span class="number">22</span>:<span class="number">35</span> GMT+<span class="number">0800</span> (CST) &#125;</span><br><span class="line">  <span class="comment">//这里就是我们stats类里面的属性了</span></span><br><span class="line">读取文件信息成功！</span><br><span class="line">是否为文件(isFile) ? <span class="literal">true</span></span><br><span class="line">是否为目录(isDirectory) ? <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="写入文件">写入文件</h2>
<h3 id="语法-5">语法</h3>
<p>以下为异步模式下写入文件的语法格式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.writeFile(file, data[, options], callback)</span><br></pre></td></tr></table></figure>
<p>writeFile 直接打开文件默认是 <strong>w</strong> 模式，所以如果文件存在，该方法写入的内容会覆盖旧的文件内容。</p>
<h3 id="参数-6">参数</h3>
<p>参数使用说明如下：</p>
<ul>
<li><strong>file</strong> - 文件名或文件描述符。</li>
<li><strong>data</strong> - 要写入文件的数据，可以是 String(字符串) 或 Buffer(缓冲) 对象。</li>
<li><strong>options</strong> - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 ‘w’</li>
<li><strong>callback</strong> - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。</li>
</ul>
<h2 id="读取文件">读取文件</h2>
<h3 id="语法-6">语法</h3>
<p>以下为异步模式下读取文件的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fs.read(fd, buffer, offset, length, position, callback)</span><br></pre></td></tr></table></figure>
<p>该方法使用了文件描述符来读取文件。</p>
<h3 id="参数-7">参数</h3>
<p>参数使用说明如下：</p>
<ul>
<li><strong>fd</strong> - 通过 fs.open() 方法（function的第二个参数表示文件）返回的文件描述符。</li>
<li><strong>buffer</strong> - 数据写入的缓冲区。</li>
<li><strong>offset</strong> - 缓冲区写入的写入偏移量。</li>
<li><strong>length</strong> - 要从文件中读取的字节数。</li>
<li><strong>position</strong> - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。</li>
<li><strong>callback</strong> - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。</li>
</ul>
<h3 id="实例-2">实例</h3>
<p>input.txt 文件内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tosuke666</span><br></pre></td></tr></table></figure>
<p>接下来我们创建 file.js 文件，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line">var buf = new Buffer.alloc(1024);</span><br><span class="line"></span><br><span class="line">console.log(&quot;准备打开已存在的文件！&quot;);</span><br><span class="line">fs.open(&#x27;input.txt&#x27;, &#x27;r+&#x27;, function(err, fd) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;文件打开成功！&quot;);</span><br><span class="line">   console.log(&quot;准备读取文件：&quot;);</span><br><span class="line">   fs.read(fd, buf, 0, buf.length, 0, function(err, bytes)&#123;</span><br><span class="line">      if (err)&#123;</span><br><span class="line">         console.log(err);</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(bytes + &quot;  字节被读取&quot;);</span><br><span class="line">      </span><br><span class="line">      // 仅输出读取的字节</span><br><span class="line">      if(bytes &gt; 0)&#123;</span><br><span class="line">         console.log(buf.slice(0, bytes).toString());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">准备打开已存在的文件！</span><br><span class="line">文件打开成功！</span><br><span class="line">准备读取文件：</span><br><span class="line">42  字节被读取</span><br><span class="line">Tosuke666</span><br></pre></td></tr></table></figure>
<h2 id="关闭文件">关闭文件</h2>
<h3 id="语法-7">语法</h3>
<p>以下为异步模式下关闭文件的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fs.close(fd, callback)</span><br></pre></td></tr></table></figure>
<p>该方法使用了文件描述符来读取文件。</p>
<h3 id="参数-8">参数</h3>
<p>参数使用说明如下：</p>
<ul>
<li><strong>fd</strong> - 通过 fs.open() 方法返回的文件描述符。</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
<h1>GET/POST请求</h1>
<p>在很多场景中，我们的服务器都需要跟用户的浏览器打交道，如表单提交。</p>
<p>表单提交到服务器一般都使用 GET/POST 请求。</p>
<h2 id="获取GET请求内容">获取GET请求内容</h2>
<p>由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此你可以手动解析后面的内容作为GET请求的参数。</p>
<p>node.js 中 url 模块中的 parse 函数提供了这个功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain; charset=utf-8&#x27;</span>&#125;);</span><br><span class="line">    <span class="comment">//这部分调用了url解析和util，展现了更多调试信息。</span></span><br><span class="line">    res.end(util.inspect(url.parse(req.url, <span class="literal">true</span>)));</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>这时候我们访问http://localhost:3000/user?name=京介的正牌呃&amp;url=www.tosuke.top</p>
<p>就能得到这个请求的详细信息：</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/image-20220503235242447.png" alt="image-20220503235242447"></p>
<h3 id="获取-URL-的参数">获取 URL 的参数</h3>
<p>我们可以使用 url.parse 方法来解析 URL 中的参数。</p>
<p>格式：<strong>url.parse(urlString , boolean , boolean)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">urlString指传入一个url地址的字符串</span><br><span class="line"></span><br><span class="line">第二个参数（可省）传入一个布尔值，默认为false，为true时，返回的url对象中，query的属性为一个对象。</span><br><span class="line"></span><br><span class="line">第三个参数（可省）传入一个布尔值，默认为false，为true时，额，我也不知道有什么不同，可以去看看API。</span><br></pre></td></tr></table></figure>
<p>parse这个方法可以将一个url的字符串解析并返回一个url的对象。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//只传入一个参数的情况。</span><br><span class="line">url.parse(&quot;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回值：</span><br><span class="line">&#123;</span><br><span class="line">  protocol: &#x27;http:&#x27;,</span><br><span class="line">  slashes: true,</span><br><span class="line">  auth: &#x27;user:pass&#x27;,</span><br><span class="line">  host: &#x27;host.com:8080&#x27;,</span><br><span class="line">  port: &#x27;8080&#x27;,</span><br><span class="line">  hostname: &#x27;host.com&#x27;,</span><br><span class="line">  hash: &#x27;#hash&#x27;,</span><br><span class="line">  search: &#x27;?query=string&#x27;,</span><br><span class="line">  query: &#x27;query=string&#x27;,</span><br><span class="line">  pathname: &#x27;/p/a/t/h&#x27;,</span><br><span class="line">  path: &#x27;/p/a/t/h?query=string&#x27;,</span><br><span class="line">  href: &#x27;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&#x27;</span><br><span class="line"> &#125;</span><br><span class="line">没有设置第二个参数为true时，query属性为一个字符串类型</span><br></pre></td></tr></table></figure>
<p>又再说：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//传入两个参数，第二个参数为true</span><br><span class="line">url.parse(&quot;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&quot;,true);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回值：</span><br><span class="line"> &#123;</span><br><span class="line">  protocol: &#x27;http:&#x27;,</span><br><span class="line">  slashes: true,</span><br><span class="line">  auth: &#x27;user:pass&#x27;,</span><br><span class="line">  host: &#x27;host.com:8080&#x27;,</span><br><span class="line">  port: &#x27;8080&#x27;,</span><br><span class="line">  hostname: &#x27;host.com&#x27;,</span><br><span class="line">  hash: &#x27;#hash&#x27;,</span><br><span class="line">  search: &#x27;?query=string&#x27;,</span><br><span class="line">  query: &#123; query: &#x27;string&#x27; &#125;,</span><br><span class="line">  pathname: &#x27;/p/a/t/h&#x27;,</span><br><span class="line">  path: &#x27;/p/a/t/h?query=string&#x27;,</span><br><span class="line">  href: &#x27;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&#x27;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>将第二个参数设置为true时，query属性为 “名称/值”对的集合,即json格式，这样我们就可以直接来参数来使用。</p>
<p>利用url的parse解析，我们之前的服务器可以变成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain; charset=utf-8&#x27;</span>&#125;);</span><br><span class="line">    <span class="keyword">var</span> params = url.parse(req.url,<span class="literal">true</span>).query;</span><br><span class="line">    res.write(<span class="string">&quot;网站名：&quot;</span> + params.name);</span><br><span class="line">    res.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    res.write(<span class="string">&quot;网站 URL：&quot;</span> + params.url);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>当我们依然用之前的链接访问时：</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/image-20220504001007908.png" alt="image-20220504001007908"></p>
<h2 id="获取-POST-请求内容">获取 POST 请求内容</h2>
<p>POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。</p>
<p>比如上传文件，而很多时候我们可能并不需要理会请求体的内容，<strong>恶意的POST请求会大大消耗服务器的资源</strong>，所以 node.js 默认是不会解析请求体的，当你需要的时候，需要手动来做。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 定义了一个post变量，用于暂存请求体的信息</span></span><br><span class="line">    <span class="keyword">var</span> post = <span class="string">&#x27;&#x27;</span>;     </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中</span></span><br><span class="line">    req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;    </span><br><span class="line">        post += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。</span></span><br><span class="line">    req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">        post = querystring.parse(post);</span><br><span class="line">        res.end(util.inspect(post));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>querystring.parse()方法能把一个URL查询字符串(str)解析成一个键值对的集合，就是把例如a=40&amp;&amp;b=30转换成{a:40,b:30}</p>
<p>get请求用url.parse(req.url,true)把例如127.0.0.1:8000/back?a=40&amp;&amp;b=30解析成对象 true 代表把参数转换成对象，url.parse(req.url,true).query 这个属性里就是参数a=40&amp;&amp;b=30，有true了 这个属性就变成了对象{a:40,b:30}。</p>
</blockquote>
<p>以下实例表单通过 POST 提交并输出数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"><span class="comment">//提交的页面</span></span><br><span class="line"><span class="keyword">var</span> postHTML = </span><br><span class="line">  <span class="string">&#x27;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程 Node.js 实例&lt;/title&gt;&lt;/head&gt;&#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;&lt;body&gt;&#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;&lt;form method=&quot;post&quot;&gt;&#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;网站名： &lt;input name=&quot;name&quot;&gt;&lt;br&gt;&#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;网站 URL： &lt;input name=&quot;url&quot;&gt;&lt;br&gt;&#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;&lt;input type=&quot;submit&quot;&gt;&#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;&lt;/form&gt;&#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;&lt;/body&gt;&lt;/html&gt;&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> body = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    body += chunk;</span><br><span class="line">  &#125;);</span><br><span class="line">  req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">    body = querystring.parse(body);</span><br><span class="line">    <span class="comment">// 设置响应头部信息及编码</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html; charset=utf8&#x27;</span>&#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(body.name &amp;&amp; body.url) &#123; <span class="comment">// 输出提交的数据</span></span><br><span class="line">        res.write(<span class="string">&quot;网站名：&quot;</span> + body.name);</span><br><span class="line">        res.write(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">        res.write(<span class="string">&quot;网站 URL：&quot;</span> + body.url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 输出表单</span></span><br><span class="line">        res.write(postHTML);</span><br><span class="line">    &#125;</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>这里我们涉及了 res.write函数与 res.end函数,我们来了解一下：</p>
<h2 id="res-end">res.end()</h2>
<p>作为服务器的响应，res.end()在GET请求与POST请求中都有用到，res.end是不允许输出多行的，我们多复制几个进行输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);  <span class="comment">// 得到内置模块,引入NodeJS的内置http模块</span></span><br><span class="line"><span class="comment">// 创建服务器，使用createServer方法</span></span><br><span class="line"><span class="comment">// createServer方法中有一个回调函数，req参数表示的是请求，res的参数表示的是响应</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">  res.end(<span class="string">&quot;Hello world&quot;</span>); <span class="comment">// 输出</span></span><br><span class="line">  res.end(<span class="string">&quot;Hello world&quot;</span>); <span class="comment">// 输出</span></span><br><span class="line">  res.end(<span class="string">&quot;Hello world&quot;</span>); <span class="comment">// 输出</span></span><br><span class="line">  res.end(<span class="string">&quot;Hello world&quot;</span>); <span class="comment">// 输出</span></span><br><span class="line">  res.end(<span class="string">&quot;Hello world&quot;</span>); <span class="comment">// 输出</span></span><br><span class="line">  res.end(<span class="string">&quot;Hello world&quot;</span>); <span class="comment">// 输出</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 监听，默认的端口是80（Apache），所以我们用3000端口</span></span><br><span class="line">server.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;监听3000端口&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>浏览器中只输出一行结果</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/2532425-20211018160203851-1785304447.png" alt="img"></p>
<p>res.end也不能输入非字符串</p>
<p>此时我们输出一个数字就回报错，查看报错信息，提醒我们不能输出number类型</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/2532425-20211018160328858-527775063.png" alt="img"></p>
<p>res.end是可以结合HTML标签显示的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">res.end(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;); // 输出</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/2532425-20211018160452298-936868776.png" alt="img"></p>
<h2 id="res-write">res.write()</h2>
<p>如果要使用res.write最后必须要有res.end，否则浏览器处于请求状态</p>
<p>多条语句输出使用的是res.write，并且也结合HTML标签进行使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);  <span class="comment">// 得到内置模块,引入NodeJS的内置http模块</span></span><br><span class="line"><span class="comment">// 创建服务器，使用createServer方法</span></span><br><span class="line"><span class="comment">// createServer方法中有一个回调函数，req参数表示的是请求，res的参数表示的是响应</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">  res.write(<span class="string">&quot;&lt;p&gt;hello world&lt;/p&gt;&quot;</span>); <span class="comment">// 输出</span></span><br><span class="line">  res.write(<span class="string">&quot;&lt;p&gt;hello world&lt;/p&gt;&quot;</span>); <span class="comment">// 输出</span></span><br><span class="line">  res.write(<span class="string">&quot;&lt;p&gt;hello world&lt;/p&gt;&quot;</span>); <span class="comment">// 输出</span></span><br><span class="line">  res.end(<span class="string">&quot;输出完毕&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 监听，默认的端口是80（Apache），所以我们用3000端口</span></span><br><span class="line">server.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;监听3000端口&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此时我们看到浏览器会输出</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/2532425-20211018161018423-1689875944.png" alt="img"></p>
<p>此时出现乱码是因为我们没哟设置字符集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">res.setHeader(&quot;Content-type&quot;,&quot;text/html;charset=utf8&quot;);</span><br></pre></td></tr></table></figure>
<p>设置字符集之后查看</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/2532425-20211018161218022-600251965.png" alt="img"></p>
<p>如果此时我们没有res.end()，我们会看到浏览器会一直处于请求状态</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/2532425-20211018161324092-864999841.png" alt="img"></p>
<p>和res.end一样不能输入非字符串的内容。</p>
<h1>Web 模块</h1>
<h2 id="什么是-Web-服务器？">什么是 Web 服务器？</h2>
<p>Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，Web服务器的基本功能就是提供Web信息浏览服务。它只需支持HTTP协议、HTML文档格式及URL，与客户端的网络浏览器配合。</p>
<p>大多数 web 服务器都支持服务端的脚本语言（php、python、ruby）等，并通过脚本语言从数据库获取数据，将结果返回给客户端浏览器。</p>
<p>目前最主流的三个Web服务器是Apache、Nginx、IIS。</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/image-20220504142642141.png" alt="image-20220504142642141"></p>
<ul>
<li><strong>Client</strong> - 客户端，一般指浏览器，浏览器可以通过 HTTP 协议向服务器请求数据。</li>
<li><strong>Server</strong> - 服务端，一般指 Web 服务器，可以接收客户端请求，并向客户端发送响应数据。</li>
<li><strong>Business</strong> - 业务层， 通过 Web 服务器处理应用程序，如与数据库交互，逻辑运算，调用外部程序等。</li>
<li><strong>Data</strong> - 数据层，一般由数据库组成。</li>
</ul>
<h2 id="使用-Node-创建-Web-服务器">使用 Node 创建 Web 服务器</h2>
<p>Node.js 提供了 http 模块，http 模块主要用于搭建 HTTP 服务端和客户端，使用 HTTP 服务器或客户端功能必须调用 http 模块，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>以下是演示一个最基本的 HTTP 服务器架构(使用 8080 端口)，创建 server.js 文件，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line">http.createServer( <span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;  </span><br><span class="line">   <span class="comment">// 解析请求，包括文件名</span></span><br><span class="line">   <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 输出请求的文件名</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;Request for &quot;</span> + pathname + <span class="string">&quot; received.&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 从文件系统中读取请求的文件内容</span></span><br><span class="line">   fs.readFile(pathname.substr(<span class="number">1</span>), <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(err);</span><br><span class="line">         <span class="comment">// HTTP 状态码: 404 : NOT FOUND</span></span><br><span class="line">         <span class="comment">// Content Type: text/html</span></span><br><span class="line">         response.writeHead(<span class="number">404</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span>&#125;);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;             </span><br><span class="line">         <span class="comment">// HTTP 状态码: 200 : OK</span></span><br><span class="line">         <span class="comment">// Content Type: text/html</span></span><br><span class="line">         response.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span>&#125;);    </span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 响应文件内容</span></span><br><span class="line">         response.write(data.toString());        </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//  发送响应数据</span></span><br><span class="line">      response.end();</span><br><span class="line">   &#125;);   </span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 控制台会输出以下信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server running at http://127.0.0.1:8080/&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>这便是利用了文件系统的一个完整的服务器。</p>
<p>在服务器同目录下创立服务器的响应html文件index.html:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后我们访问http://127.0.0.1:8080/index.html就能得到服务器返回的HTML页面了。</p>
<p>这里就不得不提一下在下在尝试这个实例时，我路径/index.html始终找不到：</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/image-20220505113403222.png" alt="疯狂404"></p>
<p>在下调试了很久，替换了几个提示过时的函数，手打重写函数什么的都不行。</p>
<p>最后我突然想到，默默的换了个端口号：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>好的。。大功告成。。给各位提个醒吧，记得排除端口占用问题：</p>
<p><img src="/2022/05/15/Node.js%E2%80%94%E6%94%B9%E5%8F%98JavaScript%E7%9A%84%E5%91%BD%E8%BF%90/image-20220505113731666.png" alt="image-20220505113731666"></p>
<h2 id="使用-Node-创建-Web-客户端">使用 Node 创建 Web 客户端</h2>
<p>Node 创建 Web 客户端需要引入 http 模块，创建 client.js 文件，代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 用于请求的选项</span></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">   <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">   <span class="attr">port</span>: <span class="string">&#x27;8080&#x27;</span>,</span><br><span class="line">   <span class="attr">path</span>: <span class="string">&#x27;/index.html&#x27;</span>  </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 处理响应的回调函数</span></span><br><span class="line"><span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">   <span class="comment">// 不断更新数据</span></span><br><span class="line">   <span class="keyword">var</span> body = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">   response.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      body += data;</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   response.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 数据接收完成</span></span><br><span class="line">      <span class="built_in">console</span>.log(body);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向服务端发送请求</span></span><br><span class="line"><span class="keyword">var</span> req = http.request(options, callback);</span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure>
<p>这个大家了解一下就好。</p>
<h1>路由</h1>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习</title>
    <url>/2022/04/18/Python-TM%E4%BA%BA%E4%BA%BA%E9%83%BD%E5%9C%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1>Python-学习过程</h1>
<h1>前言</h1>
<p>总所周知，在这个信息时代，编程正变得越来越热门，不管你是什么人，年龄多大，是什么专业的都能在编程界里形形色色的语言中找到最适合你的一门语言，在这其中有一门语言因为其特殊的天赋成功成为了众人眼中的香饽饽，没错，我说的就是这个python，它极低的入门门槛和较强的编程思维能力成为了不是计算机专业来学习编程的首要选择，这时要是我这个计算机专业的同学都还不了解python的话，那还怎么向我那其他专业的朋友们装逼（不是）呢？</p>
<h1>python的安装</h1>
<p>python的安装并不复杂，在官网下载然后安装是最好的选择，因为它能将python的path环境一并帮你解决，文本编辑器的话我还是使用的vscode（主要是不想用太多软件），vscode的话还要去拓展中下载python的拓展程序才行：</p>
<p><img src="/2022/04/18/Python-TM%E4%BA%BA%E4%BA%BA%E9%83%BD%E5%9C%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80/image-20220413155202711.png" alt="image-20220413155202711"></p>
<p>官网地址在此：<a href="https://www.python.org/downloads/windows/">Windows小伙伴直达</a></p>
<blockquote>
<p>有没有安装上python？安装完python后，调出命令行，输入“python”，如果出现&gt;&gt;&gt;则为安装完全成功</p>
</blockquote>
<h1>变量</h1>
<p>变量是指向指向值的一个标签，就像名字一样，我给值取一个变量名，就像我妈给我取名字，此后只要有人喊“喂！京介！”，我就会知道那是在叫我，因为这个名字是指向我的。</p>
<h2 id="变量名的规范">变量名的规范</h2>
<p>就像人名有着各种好坏和要求（上不上的了户口），变量名也需要一定的规则，其为：</p>
<ol>
<li>变量名只能含有英文、数字和下划线，且不能以数字开头</li>
<li>变量名不能有空格</li>
<li>不能将关键字设为变量名（比如一个人不能叫吃饭，不然以后说吃饭就不知道是在叫你还是说去吃饭）</li>
<li>变量名应该简洁并具有一定描述性（比如：name、age、class等等）</li>
<li>最好不用小写l与大写O，因为他们看起来很像1和0（不是吗）</li>
</ol>
<h2 id="变量名的检查">变量名的检查</h2>
<p>许多天资聪慧的程序员（比如我）都经常为这个细小的问题花费数十个小时，最后发现仅仅是大小写失误或者少写了一个字符，所以养成好的习惯非常重要，试着从一开始就按照上面的变量名规范来命名变量吧。</p>
<h1>字符串</h1>
<p>基础的数据类型，所谓字符串就是一系列的字符（对，就是每个字和符号），python将引号括起来的都叫做字符串，这个引号可以是单引号、双引号。</p>
<p>例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message=<span class="string">&quot;我是‘京介’，请多指教！&quot;</span></span><br></pre></td></tr></table></figure>
<p>那这里我就定义了一个字符串，指向这句字符串的变量是message，大家可能注意到了字符串里还有单引号，这是因为python只会把最外面的双引号或者是单引号看作是字符串的边界，所以我们可以在字符串里随心所欲的使用引号。</p>
<h2 id="输出函数print（）">输出函数print（）</h2>
<p>print是python的一个函数，它将print后面的括号里的内容打印在控制台或者终端。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message=<span class="string">&quot;Tosuke&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>
<h2 id="字符串方法">字符串方法</h2>
<p>在任一字符串后使用“.”（点）即可访问属于字符串的方法，就是对指定的字符串进行一些变化等动作的方法，部分方法列举如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message=<span class="string">&quot;tosuke&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message.title())</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScrpt与JS的区别学习</title>
    <url>/2022/07/30/TypeScrpt%E4%B8%8EJS%E7%9A%84%E5%8C%BA%E5%88%AB%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1>前言</h1>
<p>刚刚磨完Javascript的我正打算学习Vue时却发现JS已经过时了，现在的前端的逻辑语法（尤其是Vue）已经被一种更加完美的语言所代替了——也就是最新的Typescript，故友说：学习是不能停下来的，对此我表示认同。</p>
<h1>安装</h1>
<p>这个不用多说了，npm包安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure>
<p>安装完成后我们可以使用 <strong>tsc</strong> 命令来执行 TypeScript 的相关代码，以下是查看版本号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tsc -v</span><br><span class="line">Version 3.2.2</span><br></pre></td></tr></table></figure>
<p>注意，TS是JS的一个超集，本质上运行还是转换成的JS，这个tsc就是干这个的。</p>
<h1>基础语法</h1>
<p>TypeScript 程序由以下几个部分组成：</p>
<ul>
<li>模块</li>
<li>函数</li>
<li>变量</li>
<li>语句和表达式</li>
<li>注释</li>
</ul>
<p>举例</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hello : <span class="built_in">string</span> = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(hello)</span><br></pre></td></tr></table></figure>
<p>以上代码首先通过 <strong>tsc</strong> 命令编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tsc Runoob.ts</span><br></pre></td></tr></table></figure>
<p>然后转换成了这样的一种js代码后就可以用nodejs运行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(hello);</span><br></pre></td></tr></table></figure>
<p>通过对比我们发现TS与JS在这个程序的区别在于：</p>
<p>1、JS用的是var属于函数作用域，TS使用的是ES6以来的声明方式。</p>
<p>2、TS的声明还有一个重要特点就是声明类型，这一点类似于传统编程语言，因为要方便后期开发的话，类型的事先声明是很重要的，这也是TS（type类型）名字的由来，是个重要的改变。</p>
<p>整个流程如下图所示：</p>
<p><img src="/2022/07/30/TypeScrpt%E4%B8%8EJS%E7%9A%84%E5%8C%BA%E5%88%AB%E5%AD%A6%E4%B9%A0/image-20220729114117001.png" alt="image-20220729114117001"></p>
<h3 id="空白和换行">空白和换行</h3>
<p>TypeScript 会忽略程序中出现的空格、制表符和换行符。</p>
<p>空格、制表符通常用来缩进代码，使代码易于阅读和理解。</p>
<h3 id="TypeScript-区分大小写">TypeScript 区分大小写</h3>
<p>TypeScript 区分大写和小写字符。</p>
<h3 id="分号是可选的">分号是可选的</h3>
<p>每行指令都是一段语句，可以使用分号或不使用， 分号在 TypeScript 中是可选的，建议使用。</p>
<p>以下代码都是合法的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&quot;Runoob&quot;)</span><br><span class="line">console.log(&quot;Google&quot;);</span><br></pre></td></tr></table></figure>
<p>如果语句写在同一行则一定需要使用分号来分隔，否则会报错，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&quot;Runoob&quot;);console.log(&quot;Google&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="TypeScript-注释">TypeScript 注释</h3>
<p>这点与一般编程语言一致：</p>
<ul>
<li><strong>单行注释 ( // )</strong> − 在 // 后面的文字都是注释内容。</li>
<li><strong>多行注释 (/* */)</strong> − 这种注释可以跨越多行。</li>
</ul>
<h1>TS基础类型</h1>
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">关键字</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">任意类型</td>
<td style="text-align:left">any</td>
<td style="text-align:center">声明为 any 的变量可以赋予任意类型的值。</td>
</tr>
<tr>
<td style="text-align:left">数字类型</td>
<td style="text-align:left">number</td>
<td style="text-align:center">双精度 64 位浮点值。它可以用来表示整数和分数。</td>
</tr>
<tr>
<td style="text-align:left">字符串类型</td>
<td style="text-align:left">string</td>
<td style="text-align:center">一个字符系列，使用单引号（<strong>'</strong>）或双引号（<strong>&quot;</strong>）来表示字符串类型。反引号（<strong>`</strong>）来定义多行文本和内嵌表达式。</td>
</tr>
<tr>
<td style="text-align:left">布尔类型</td>
<td style="text-align:left">boolean</td>
<td style="text-align:center">表示逻辑值：true 和 false。</td>
</tr>
<tr>
<td style="text-align:left">数组类型</td>
<td style="text-align:left">无</td>
<td style="text-align:center">声明变量为数组。<code>// 在元素类型后面加上[] let arr: number[] = [1, 2]; // 或者使用数组泛型 let arr: Array&lt;number&gt; = [1, 2];</code></td>
</tr>
<tr>
<td style="text-align:left">元组</td>
<td style="text-align:left">无</td>
<td style="text-align:center">元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。<code>let x: [string, number]; x = ['Runoob', 1];    // 运行正常 x = [1, 'Runoob'];    // 报错 console.log(x[0]);    // 输出 Runoob</code></td>
</tr>
<tr>
<td style="text-align:left">枚举</td>
<td style="text-align:left">enum</td>
<td style="text-align:center">枚举类型用于定义数值集合。<code>enum Color &#123;Red, Green, Blue&#125;; let c: Color = Color.Blue; console.log(c);    // 输出 2</code></td>
</tr>
<tr>
<td style="text-align:left">void</td>
<td style="text-align:left">void</td>
<td style="text-align:center">用于标识方法返回值的类型，表示该方法没有返回值。<code>function hello(): void &#123;    alert(&quot;Hello Runoob&quot;); &#125;</code></td>
</tr>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">null</td>
<td style="text-align:center">表示对象值缺失。</td>
</tr>
<tr>
<td style="text-align:left">undefined</td>
<td style="text-align:left">undefined</td>
<td style="text-align:center">用于初始化变量为一个未定义的值</td>
</tr>
<tr>
<td style="text-align:left">never</td>
<td style="text-align:left">never</td>
<td style="text-align:center">never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。</td>
</tr>
</tbody>
</table>
<p>**注意：**TypeScript 和 JavaScript 没有整数类型。</p>
<h1>变量声明</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var [变量名] : [类型] = 值;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var uname:string = &quot;&quot;;</span><br></pre></td></tr></table></figure>
<p>声明变量的类型，但没有初始值，变量值会设置为 undefined：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var [变量名] : [类型];</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var uname:string;</span><br></pre></td></tr></table></figure>
<p>声明变量并初始值，但不设置类型，该变量可以是任意类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var [变量名] = 值;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var uname = &quot;Tosuke&quot;;</span><br></pre></td></tr></table></figure>
<p>TypeScript 遵循强类型，如果将不同的类型赋值给变量会编译错误，如下实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var num:number = &quot;hello&quot;     // 这个代码会编译错误</span><br></pre></td></tr></table></figure>
<p>TS的运算符、条件语句、循环与JS基本一致</p>
<h1>对象类型</h1>
<p>对象的类型要是定义当然只能让我们自己定义，比如在设置一个对象时,还是与我们之前的定义变量类似，即为“：+类型”，像这样：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> student:IStudent = &#123;</span><br><span class="line"><span class="attr">ID</span>:<span class="number">1111111</span>,</span><br><span class="line"><span class="attr">name</span>:<span class="string">&quot;Tosuke&quot;</span>,</span><br><span class="line"><span class="attr">sex</span>:<span class="string">&#x27;man&#x27;</span>,</span><br><span class="line"><span class="attr">meta</span>:&#123;</span><br><span class="line"><span class="attr">isHanson</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">isNB</span>:<span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">age</span>:<span class="number">21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个IStudent类型TS当然没有，需要我们自己去实现，用interface、键值对的方式定义我们自己的类型，也可以同时进行约束：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IStudent&#123;</span><br><span class="line"><span class="keyword">readonly</span> ID:<span class="built_in">number</span>;       <span class="comment">//readonly是将该值设置为只读</span></span><br><span class="line">sex:<span class="string">&#x27;man&#x27;</span>|<span class="string">&#x27;woman&#x27;</span>|<span class="string">&#x27;other&#x27;</span>;</span><br><span class="line">age:<span class="built_in">number</span>;</span><br><span class="line">meta:&#123;</span><br><span class="line"><span class="attr">isHanson</span>:<span class="built_in">boolean</span>;</span><br><span class="line">isNB:<span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line">age?:<span class="built_in">number</span>;   <span class="comment">//添加问号是属性可选</span></span><br><span class="line">[key:<span class="built_in">string</span>]:<span class="built_in">any</span>       <span class="comment">//任意属性，相当于想要添加自己另外一些键值对的约束。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>函数</h1>
<h2 id="函数的类型">函数的类型</h2>
<p>对于函数，TS当然也有自己的想法（毕竟Type都打在脸上了），还是先来一段JS代码给大伙瞧瞧：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">retrun x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在TS有两个点需要声明类型，参数与返回值：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x:<span class="built_in">number</span>,y:<span class="built_in">number</span></span>):<span class="title">number</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者采用当下流行的ES6的箭头函数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add:<span class="function">(<span class="params">x:<span class="built_in">number</span>,y:<span class="built_in">number</span></span>)=&gt;</span><span class="built_in">number</span>=<span class="function">(<span class="params">x+y</span>)=&gt;</span>x+y</span><br></pre></td></tr></table></figure>
<p>每次这样写一定很麻烦，所以函数也可以使用interface（接口）来定义函数的类型，和对象相差不大：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Add&#123;</span><br><span class="line">(x:<span class="built_in">number</span>,<span class="attr">y</span>:<span class="built_in">number</span>):<span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以像JS一样写代码了，不过多了一步标记函数类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>:<span class="title">Add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数的重载">函数的重载</h2>
<p>这就是TS规定类型的好处之一了，假设我们有一个grtdate的函数，它的参数为一个type和一个time，type决定了它的返回值的类型，而time可以留空，代表计时的开始，默认为当前时间。我们可以重载函数，依据type的不同严格规定返回值的类型，以避免错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getdate(type:string|date,time?:string):string|date</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2入门</title>
    <url>/2022/05/15/Vue2.x/</url>
    <content><![CDATA[<h1>Vue2.x入门</h1>
<p>在了解过webpack后，我们开始学习最重要的Vue框架（不容易啊）。</p>
<h1>安装环境</h1>
<p>因为我们Vue中有一些文件是无法直接读取的，像是微信的wxml，wxss等，我们需要把它们全部打包成js文件才行正常运行。</p>
<p>在命令行中运行npm安装webpack：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install webpack -g</span><br></pre></td></tr></table></figure>
<p>带g是全局安装。</p>
<p>接着安装Vue依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install vue-cli -g</span><br></pre></td></tr></table></figure>
<p>接着我们开始初始化我们的Vue项目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue init webpack-simple tosuketest1</span><br></pre></td></tr></table></figure>
<p>tosuketest1是这个项目的名称，注意，项目名称只能使用英文。</p>
<p>接着是一串信息确认，直接回车或者填入相关信息后我们就创建好了我们的第一个Vue项目：</p>
<p><img src="/2022/05/15/Vue2.x/image-20220512104041803.png" alt="image-20220512104041803"></p>
<p>这时系统创建了一个以我们项目名字的文件夹，根据Vue的提示，我们需要进入到我们项目名字的文件夹，由于是在当前文件夹下创建的项目文件夹，所以我们直接用cd+文件夹名称的指令进入即可。</p>
<p>成功进入到项目文件夹后我们还要安装Vue的全部依赖，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>安装好后我们的项目文件夹就是这样的：</p>
<p><img src="/2022/05/15/Vue2.x/blog/source/image-20220512104936884.png" alt="image-20220512104936884"></p>
<p>观察一下，不仅有模块文件夹、源文件夹、html、包说明json，还有我们才学习过的babel以及webpack。</p>
<p>运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>
<p>即可在浏览器中看见我们的Vue初始化页面：</p>
<p><img src="/2022/05/15/Vue2.x/image-20220512105353041.png" alt="image-20220512105353041"></p>
<h1>Vue 项目打包</h1>
<p>打包 Vue 项目使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>
<p>执行完成后，会在 Vue 项目下生成一个 <strong>dist</strong> 目录，一般包含 index.html 文件及 static 目录，static 目录包含了静态文件 js、css 以及图片目录 images。</p>
<h1>Vue项目结构</h1>
<p><img src="/2022/05/15/Vue2.x/image-20220512110528960.png" alt="image-20220512110528960"></p>
<table>
<thead>
<tr>
<th style="text-align:left">目录/文件</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">build</td>
<td style="text-align:left">项目构建(webpack)相关代码</td>
</tr>
<tr>
<td style="text-align:left">config</td>
<td style="text-align:left">配置目录，包括端口号等。我们初学可以使用默认的。</td>
</tr>
<tr>
<td style="text-align:left">node_modules</td>
<td style="text-align:left">npm 加载的项目依赖模块</td>
</tr>
<tr>
<td style="text-align:left">src</td>
<td style="text-align:left">这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：assets: 放置一些图片，如logo等。components: 目录里面放了一个组件文件，可以不用。App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。main.js: 项目的核心文件。</td>
</tr>
<tr>
<td style="text-align:left">static</td>
<td style="text-align:left">静态资源目录，如图片、字体等。</td>
</tr>
<tr>
<td style="text-align:left">test</td>
<td style="text-align:left">初始测试目录，可删除</td>
</tr>
<tr>
<td style="text-align:left">.xxxx文件</td>
<td style="text-align:left">这些是一些配置文件，包括语法配置，git配置等。</td>
</tr>
<tr>
<td style="text-align:left">index.html</td>
<td style="text-align:left">首页入口文件，你可以添加一些 meta 信息或统计代码啥的。</td>
</tr>
<tr>
<td style="text-align:left">package.json</td>
<td style="text-align:left">项目配置文件。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://README.md">README.md</a></td>
<td style="text-align:left">项目的说明文档，markdown 格式</td>
</tr>
</tbody>
</table>
<p>我们打开src下面的App.vue文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;./assets/logo.png&quot;&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;Essential Links&lt;/h2&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;https://vuejs.org&quot; target=&quot;_blank&quot;&gt;Core Docs&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;https://forum.vuejs.org&quot; target=&quot;_blank&quot;&gt;Forum&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;https://chat.vuejs.org&quot; target=&quot;_blank&quot;&gt;Community Chat&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;https://twitter.com/vuejs&quot; target=&quot;_blank&quot;&gt;Twitter&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;h2&gt;Ecosystem&lt;/h2&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;http://router.vuejs.org/&quot; target=&quot;_blank&quot;&gt;vue-router&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;http://vuex.vuejs.org/&quot; target=&quot;_blank&quot;&gt;vuex&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;http://vue-loader.vuejs.org/&quot; target=&quot;_blank&quot;&gt;vue-loader&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;https://github.com/vuejs/awesome-vue&quot; target=&quot;_blank&quot;&gt;awesome-vue&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;app&#x27;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#x27;Welcome to Your Vue.js App&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &#x27;Avenir&#x27;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1, h2 &#123;</span><br><span class="line">  font-weight: normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ul &#123;</span><br><span class="line">  list-style-type: none;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">li &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  margin: 0 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a &#123;</span><br><span class="line">  color: #42b983;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总的来说，template 写 html，script写 js，style写样式。</p>
<p>那知道是这样排布的之后，我们就可以来分析一下这个代码了。</p>
<p>首先，template里面的内容很容易分析，先是一个div容器，里面依次是logo图片、msg的标题、Essential Links的标题，接着就是一堆链接。</p>
<p>script里导出了一个返回msg的函数，供上面的标题使用，所以我们要是修改一下这个msg的内容：</p>
<p><img src="/2022/05/15/Vue2.x/image-20220512112309682.png" alt="image-20220512112309682"></p>
<p>然后我们运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>
<p>我们会发现页面也就发生改变了：</p>
<p><img src="/2022/05/15/Vue2.x/image-20220512112411633.png" alt="image-20220512112411633"></p>
<p>接着分析，style里有一些对app这个div的一些样式修改。</p>
<p>这就是这个最基本的vue文件。</p>
<h1>Vue模板语法</h1>
<p>每个 Vue 应用都需要通过实例化 Vue 来实现。</p>
<p>语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  // 选项</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>下面我们来举一个例子来说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;vue_det&quot;&gt;</span><br><span class="line">    &lt;h1&gt;site : &#123;&#123;site&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;url : &#123;&#123;url&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123;details()&#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &#x27;#vue_det&#x27;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            site: &quot;京介的正牌博客&quot;,</span><br><span class="line">            url: &quot;tosuke.gitee.io&quot;,</span><br><span class="line">            alexa: &quot;10000&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            details: function() &#123;</span><br><span class="line">                return  this.site + &quot; - 京介666&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到，首先在 Vue 构造器中有一个el 参数，他代表的是DOM元素的id，在上面的例子中我们的el指的就是那个div容器，这意味着我们接下来的改动全部在以上指定的 div 内，div 外部不受影响。</p>
<p>接下来我们看看如何定义数据对象。</p>
<p><strong>data</strong> 用于定义属性，实例中有三个属性分别为：site、url、alexa，当然你可以在添加一些自己要用的属性。</p>
<p><strong>methods</strong> 用于定义的函数，可以通过 return 来返回函数值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>用于输出对象属性和函数返回值，也就是文本插值。</p>
<p>当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，html 视图将也会产生相应的变化。</p>
<p>这样的话，我们的网页就可以做到实时动态的内容刷新了。</p>
<p>除了数据属性，Vue 实例还提供了一些有用的实例属性与方法。它们都有前缀 $，以便与用户定义的属性区分开来。</p>
<h2 id="插值">插值</h2>
<h3 id="文本">文本</h3>
<p>数据绑定最常见的形式就是使用 （双大括号）的文本插值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Html">Html</h3>
<p>使用 <strong>v-html</strong> 指令用于输出 html 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div v-html=&quot;message&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#x27;&lt;h1&gt;京介的正牌博客&lt;/h1&gt;&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>就是将你的文本值用HTML的格式来作对应的解析，例如上面的代码：</p>
<p><img src="/2022/05/15/Vue2.x/image-20220512171825902.png" alt="image-20220512171825902"></p>
<p>很显然我这行代码已经被解释为了HTML的标题，字体有明显的加粗，<strong>v-html</strong> 指令本质上是js，只能在标签的属性里用。</p>
<h3 id="属性">属性</h3>
<p>HTML 属性绑定应使用 v-bind 指令。</p>
<p>Vue官方提供了一个简写方式 <strong>:bind</strong>，对比如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p><strong>绑定HTML Class</strong></p>
<p>我们可以给v-bind:class 一个对象，以动态地切换class。注意：v-bind:class指令可以与普通的class特性共存</p>
<p>在HTML代码的部分，我们假如这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul class=&quot;box&quot; v-bind:class=&quot;&#123;‘textColor‘:isColor, ‘textSize‘:isSize&#125;&quot;&gt;</span><br><span class="line">    &lt;li&gt;就是第一&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;这是第二&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>我们预先设置好一下几种css样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> dashed <span class="number">#f0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.textColor</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#f00</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#eef</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.textSize</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后再实例化绑定一个vue实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm= <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:‘.box‘,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">isColor</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">isSize</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<p><img src="/2022/05/15/Vue2.x/image-20220513111003797.png" alt="image-20220513111003797"></p>
<p>这是因为，我们将textcolor和textsize的属性绑定到了box的上面，并且通过vue里的data来确认是否使用，像是上面的那个例子里我们将isColor和isSize都设置为了true，如果我们设置为false，则效果也会随之改变。</p>
<p>例如我们将isColor设置为false，结果为：</p>
<p><img src="/2022/05/15/Vue2.x/image-20220513111707054.png" alt="image-20220513111707054"></p>
<p>而且你会看到，你对代码的更改将会实时的响应到网页中。</p>
<p><strong>v-build也可以直接绑定数据里的一个对象</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123;classobject&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>就是第一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>js里面就随之更改为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm= <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:‘.box‘,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">classObject</span>:&#123;</span><br><span class="line">            ‘textColor‘:<span class="literal">true</span>,</span><br><span class="line">            ‘textSize‘:<span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>v-build绑定的花样还有很多，比如：可以把一个数组传给v-bind:class，以应用一个class列表、根据条件切换列表中的class，可以用三目运算等等。</p>
<h3 id="表达式">表达式</h3>
<p>Vue.js 都提供了完全的 JavaScript 表达式支持。</p>
<p>即我们的文本插件里也可以使用JS表达式。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;<span class="number">5</span>+<span class="number">5</span>&#125;&#125;<span class="comment">//代表10</span></span><br><span class="line">&#123;&#123;meg.split(<span class="string">&#x27;&#x27;</span>)&#125;&#125;<span class="comment">//用‘’来切割meg（VUE实例来设置这个meg）</span></span><br></pre></td></tr></table></figure>
<h2 id="指令">指令</h2>
<p>指令是带有 v- 前缀的特殊属性。</p>
<p>指令用于在表达式的值改变时，将某些行为应用到 DOM 上，意为向DOM添加一些属性，以方便控制。比如v-build、v-html、v-if等等都是指令。v-build、v-html我们已经了解过了，接下来我们来试试v-if：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;seen&quot;</span>&gt;</span>现在你看到我了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">seen</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>v-if 指令将根据表达式 seen 的值(true 或 false )来决定是否插入 p 元素。如seen为true我们就可以看见p元素，如果是false则不行。</p>
<p>另一个例子是 v-on 指令，它用于监听 DOM 事件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="参数">参数</h3>
<p>参数在指令后以冒号指明。例如， v-bind 指令被用来响应地更新 HTML 属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>智能物联协会<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">    </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">new</span> Vue(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">url</span>: <span class="string">&#x27;tocode.cc&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这样，我们智能物联协会官网的链接tocode.cc就作为参数href绑定在了标签上，有同学可能会有这样的疑问：我们是傻*吗？明明是a标签，还需要用v-bind来绑定个屁啊，我直接：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>智能物联协会<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然这样写直接就404了，在这里说明的是，我们使用v-bind是为了使url可变，使用了v-bind是为了绑定这个属性从而使得从js中返回我们的url。</p>
<h3 id="修饰符">修饰符</h3>
<p>修饰符是以半角句号 <strong>.</strong> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，<strong>.prevent</strong> 修饰符告诉 <strong>v-on</strong> 指令对于触发的事件调用 <strong>event.preventDefault()</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实际上，一如其名，修饰符用于修饰指令，即让指令做一些适应性改变。</p>
<h2 id="用户输入">用户输入</h2>
<p>在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定。</p>
<p><strong>v-model</strong> 指令用来在 input、select、textarea、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。</p>
<p>按钮的事件我们可以使用 v-on 监听事件，并对用户的输入进行响应。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">new</span> Vue(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">message</span>: <span class="string">&#x27;京介的正牌博客&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>上面的例子是说，message默认是京介的正牌博客，但是一旦用户进行输入数值，message就会随时进行更改绑定：</p>
<p><img src="/2022/05/15/Vue2.x/image-20220514214429865.png" alt="image-20220514214429865"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>XML-HTML走上不同道路的亲兄弟</title>
    <url>/2022/04/11/XML-HTML%E8%B5%B0%E4%B8%8A%E4%B8%8D%E5%90%8C%E9%81%93%E8%B7%AF%E7%9A%84%E4%BA%B2%E5%85%84%E5%BC%9F/</url>
    <content><![CDATA[<h1>Xml-可扩展标记语言-概述</h1>
<h2 id="用途">用途</h2>
<p>1、XML 的设计宗旨是传输数据，而不是显示数据。毕竟显示数据是HTML干的活。</p>
<p>2、xml只是一个文件，他需要软件的运行来显现内容（不像HTML可以直接打开）。</p>
<p>3、同样都是标记语言，xml的标签由你自己决定。</p>
<p><strong>XML 把数据从 HTML 分离</strong></p>
<p>如果你需要在 HTML 文档中显示动态数据，那么每当数据改变时将花费大量的时间来编辑 HTML。</p>
<p>通过 XML，数据能够存储在独立的 XML 文件中。这样您就可以专注于使用 HTML/CSS 进行显示和布局，并确保修改底层数据不再需要对 HTML 进行任何的改变。</p>
<p>通过使用几行 JavaScript 代码，您就可以读取一个外部 XML 文件，并更新您的网页的数据内容。</p>
<p><strong>XML 简化数据传输</strong></p>
<p>对开发人员来说，其中一项最费时的挑战一直是在互联网上的不兼容系统之间交换数据。</p>
<p>由于可以通过各种不兼容的应用程序来读取数据，以 XML 交换数据降低了这种复杂性。</p>
<h1>XML 树结构</h1>
<p>xml的数据具有出色的自我描述性，</p>
<p>XML 文档必须包含<strong>根元素</strong>。该元素是所有其他元素的父元素。</p>
<p>XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。</p>
<p>所有的元素都可以有子元素：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">subchild</span>&gt;</span></span><br><span class="line">            .....</span><br><span class="line">        <span class="tag">&lt;/<span class="name">subchild</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>父、子以及同胞等术语用于描述元素之间的关系。父元素拥有子元素。相同层级上的子元素成为同胞（兄弟或姐妹）。</p>
<p>所有的元素都可以有文本内容和属性（类似 HTML 中）。</p>
<p>例如：这是几本不同属性的书</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;COOKING&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Everyday Italian<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>Giada De Laurentiis<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>30.00<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;CHILDREN&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;WEB&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>Erik T. Ray<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2003<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>良好的层级结构使得xml更易于阅读。</p>
<h1>xml语法</h1>
<p><strong>XML 文档必须有根元素</strong></p>
<p>像是上面的例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">subchild</span>&gt;</span></span><br><span class="line">            .....</span><br><span class="line">        <span class="tag">&lt;/<span class="name">subchild</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>root即为根元素。</p>
<h2 id="XML-声明">XML 声明</h2>
<p>XML 声明文件的可选部分，如果存在需要放在文档的第一行，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>version代表xml版本，encoding代表编码格式。</p>
<h2 id="所有的-XML-元素都必须有一个关闭标签">所有的 XML 元素都必须有一个关闭标签</h2>
<p>在 HTML 中，某些元素不必有一个关闭标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;This is a paragraph.</span><br><span class="line">&lt;br&gt;</span><br></pre></td></tr></table></figure>
<p>在 XML 中，省略关闭标签是非法的。所有元素都<strong>必须</strong>有关闭标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;This is a paragraph.&lt;/p&gt;</span><br><span class="line">&lt;br /&gt;</span><br></pre></td></tr></table></figure>
<p>由于声明本身不属于xml文档的一部分，所以它不需要关闭标签。</p>
<h2 id="XML-标签对大小写敏感">XML 标签对大小写敏感</h2>
<p>XML 标签对大小写敏感。标签 <Letter> 与标签 <letter> 是不同的。</letter></Letter></p>
<p>必须使用相同的大小写来编写打开标签和关闭标签：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Message</span>&gt;</span>这是错误的<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span>这是正确的<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="XML-必须正确嵌套">XML 必须正确嵌套</h2>
<p>在 HTML 中，常会看到没有正确嵌套的元素：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>This text is bold and italic<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 XML 中，所有元素都<strong>必须</strong>彼此正确地嵌套：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>This text is bold and italic<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的实例中，正确嵌套的意思是：由于 <i> 元素是在 <b> 元素内打开的，那么它必须在 <b> 元素内关闭。</b></b></i></p>
<blockquote>
<p>由于xml是作为数据传输文件而存在的，所以语法要求比以展现为功能的HTML要严格许多。</p>
</blockquote>
<h2 id="XML-属性值必须加引号">XML 属性值必须加引号</h2>
<p>与 HTML 类似，XML 元素也可拥有属性（名称/值的对）。</p>
<p>在 XML 中，XML 的属性值必须加引号。</p>
<p>请研究下面的两个 XML 文档。 第一个是错误的，第二个是正确的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span> <span class="attr">date</span>=<span class="string">12/11/2007</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span> <span class="attr">date</span>=<span class="string">&quot;12/11/2007&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在第一个文档中的错误是，note 元素中的 date 属性没有加引号。</p>
<h2 id="实体引用">实体引用</h2>
<p>在 XML 中，一些字符拥有特殊的意义。</p>
<p>如果您把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。</p>
<p>这样会产生 XML 错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;</span><br></pre></td></tr></table></figure>
<p>为了避免这个错误，请用<strong>实体引用</strong>来代替 “&lt;” 字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt;</span><br></pre></td></tr></table></figure>
<p>在 XML 中，有 5 个预定义的实体引用(<strong>实际应用时注意添加分号！</strong>)：</p>
<table>
<thead>
<tr>
<th>&amp;lt</th>
<th>&lt;</th>
<th>less than</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;gt</td>
<td>&gt;</td>
<td>greater than</td>
</tr>
<tr>
<td>&amp;amp</td>
<td>&amp;</td>
<td>ampersand</td>
</tr>
<tr>
<td>&amp;apos</td>
<td>’</td>
<td>apostrophe</td>
</tr>
<tr>
<td>&amp;quot</td>
<td>&quot;</td>
<td>quotation mark</td>
</tr>
</tbody>
</table>
<p>在 XML 中，只有字符 “&lt;” 和 “&amp;” 是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。</p>
<p>(1)属性值用双引号 <strong>&quot;</strong> 或单引号 <strong>’</strong> 分隔，如果属性值中有单引号，则用双引号分隔；如果有双引号，则用单引号分隔。那么如果属性值中既有单引号还有双引号怎么办？这种要使用实体（转义字符，类似于html中的空格符），XML 有 5 个预定义的实体字符，如下：</p>
<p><img src="/2022/04/11/XML-HTML%E8%B5%B0%E4%B8%8A%E4%B8%8D%E5%90%8C%E9%81%93%E8%B7%AF%E7%9A%84%E4%BA%B2%E5%85%84%E5%BC%9F/blog/source/20160526222841679.png" alt="img"></p>
<p>(2)一个元素可以有多个属性，它的基本格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;元素名 属性名1=&quot;属性值1&quot; 属性名2=&quot;属性值2&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>(3)特定的属性名称在同一个元素标记中只能出现一次</p>
<p>(4)属性值不能包括 &lt;,&gt;,&amp;，如果一定要包含，也要使用实体</p>
<h2 id="XML-中的注释">XML 中的注释</h2>
<p>在 XML 中编写注释的语法与 HTML 的语法很相似。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- This is a comment --&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="在-XML-中，空格会被保留">在 XML 中，空格会被保留</h2>
<p>HTML 会把多个连续的空格字符裁减（合并）为一个：</p>
<table>
<thead>
<tr>
<th>HTML:</th>
<th><code>Hello           Tove</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>输出结果:</td>
<td>Hello Tove</td>
</tr>
</tbody>
</table>
<p>在 XML 中，文档中的空格不会被删减。</p>
<h2 id="XML-以-LF-存储换行">XML 以 LF 存储换行</h2>
<h1>XML 元素</h1>
<p>XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。</p>
<p>一个元素可以包含：</p>
<ul>
<li>其他元素</li>
<li>文本</li>
<li>属性</li>
<li>或混合以上所有…</li>
</ul>
<h2 id="XML-命名规则">XML 命名规则</h2>
<p>XML 元素必须遵循以下命名规则：</p>
<ul>
<li>名称可以包含字母、数字以及其他的字符</li>
<li>名称不能以数字或者标点符号开始</li>
<li>名称不能以字母 xml（或者 XML、Xml 等等）开始</li>
<li>名称不能包含空格</li>
</ul>
<p>可使用任何名称，没有保留的字词。</p>
<h2 id="最佳命名习惯">最佳命名习惯</h2>
<p>使名称具有描述性。使用下划线的名称也很不错：&lt;first_name&gt;、&lt;last_name&gt;。</p>
<p>名称应简短和简单，比如：&lt;book_title&gt;，而不是：&lt;the_title_of_the_book&gt;。</p>
<p>避免 “-” 字符。如果您按照这样的方式进行命名：“first-name”，一些软件会认为您想要从 first 里边减去 name。</p>
<p>避免 “.” 字符。如果您按照这样的方式进行命名：“<a href="http://first.name">first.name</a>”，一些软件会认为 “name” 是对象 “first” 的属性。</p>
<p>避免 “:” 字符。冒号会被转换为命名空间来使用。</p>
<h2 id="XML-元素是可扩展的">XML 元素是可扩展的</h2>
<p>XML 元素是可扩展，以携带更多的信息。</p>
<p>请看下面的 XML 实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>让我们设想一下，我们创建了一个应用程序，可将 <to>、<from> 以及 <body> 元素从 XML 文档中提取出来，并产生以下的输出：</body></from></to></p>
<p><strong>MESSAGE</strong></p>
<p><strong>To:</strong> Tove</p>
<p><strong>From:</strong> JaniDon’t forget me this weekend!</p>
<p>想象一下，XML 文档的作者添加的一些额外信息：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">date</span>&gt;</span>2008-01-10<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么这个应用程序会中断或崩溃吗？</p>
<p>不会。这个应用程序仍然可以找到 XML 文档中的 <to>、<from> 以及 <body> 元素，并产生同样的输出。</body></from></to></p>
<p>XML 的优势之一，就是可以在不中断应用程序的情况下进行扩展。</p>
<h1>XML 属性</h1>
<p>XML元素具有属性，类似 HTML。</p>
<p>属性（Attribute）提供有关元素的额外信息。决定元素的一些其他性质。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;demo.html&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于标签的一些重要的属性的改变。</p>
<h2 id="XML-属性必须加引号">XML 属性必须加引号</h2>
<p>属性值必须被引号包围，不过单引号和双引号均可使用。比如一个人的性别，person 元素可以这样写：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span> <span class="attr">sex</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="XML-元素-vs-属性">XML 元素 vs. 属性</h2>
<p>请看这些实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span> <span class="attr">sex</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">firstname</span>&gt;</span>Anna<span class="tag">&lt;/<span class="name">firstname</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lastname</span>&gt;</span>Smith<span class="tag">&lt;/<span class="name">lastname</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sex</span>&gt;</span>female<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">firstname</span>&gt;</span>Anna<span class="tag">&lt;/<span class="name">firstname</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lastname</span>&gt;</span>Smith<span class="tag">&lt;/<span class="name">lastname</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在第一个实例中，sex 是一个属性。在第二个实例中，sex 是一个元素。这两个实例都提供相同的信息。</p>
<p>没有什么规矩可以告诉我们什么时候该使用属性，而什么时候该使用元素。我的经验是在 HTML 中，属性用起来很便利，但是在 XML 中，您应该尽量避免使用属性。如果信息感觉起来很像数据，那么请使用元素吧。</p>
<h2 id="避免-XML-属性">避免 XML 属性</h2>
<p>因使用属性而引起的一些问题：</p>
<ul>
<li>属性不能包含多个值（元素可以）</li>
<li>属性不能包含树结构（元素可以）</li>
<li>属性不容易扩展（为未来的变化）</li>
</ul>
<p>属性难以阅读和维护。请尽量使用元素来描述数据。而仅仅使用属性来提供与数据无关的信息。</p>
<p>不要做这样的蠢事（这不是 XML 应该被使用的方式）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span> <span class="attr">day</span>=<span class="string">&quot;10&quot;</span> <span class="attr">month</span>=<span class="string">&quot;01&quot;</span> <span class="attr">year</span>=<span class="string">&quot;2008&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">to</span>=<span class="string">&quot;Tove&quot;</span> <span class="attr">from</span>=<span class="string">&quot;Jani&quot;</span> <span class="attr">heading</span>=<span class="string">&quot;Reminder&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">body</span>=<span class="string">&quot;Don&#x27;t forget me this weekend!&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样令人看着就头大的xml不利于阅读与维护。</p>
</blockquote>
<h1>XML 验证</h1>
<p>拥有正确语法的 XML 被称为&quot;形式良好&quot;的 XML。</p>
<p>通过 DTD 验证的XML是&quot;合法&quot;的 XML。</p>
<p>式良好&quot;的 XML 文档拥有正确的语法。</p>
<p>在前面的章节描述的语法规则：</p>
<ul>
<li>XML 文档必须有一个根元素</li>
<li>XML元素都必须有一个关闭标签</li>
<li>XML 标签对大小写敏感</li>
<li>XML 元素必须被正确的嵌套</li>
<li>XML 属性值必须加引号</li>
</ul>
<h1>查看 XML 文件</h1>
<p>他们被浏览器打开后是这个样子的：</p>
<p><img src="/2022/04/11/XML-HTML%E8%B5%B0%E4%B8%8A%E4%B8%8D%E5%90%8C%E9%81%93%E8%B7%AF%E7%9A%84%E4%BA%B2%E5%85%84%E5%BC%9F/blog/source/image-20220408173721335.png" alt="image-20220408173721335"></p>
<p>与Html那样专注与展现不同，xml打开是以这样的数据模式打开。并没有HTML的&lt;p&gt;那样指定为可以被浏览器理解为段落并进行相关展示。</p>
<h1>使用 CSS 显示 XML</h1>
<p>下面是 XML 文件的一小部分。第二行把 XML 文件链接到 CSS 文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;cd_catalog.css&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">CATALOG</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">CD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TITLE</span>&gt;</span>Empire Burlesque<span class="tag">&lt;/<span class="name">TITLE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ARTIST</span>&gt;</span>Bob Dylan<span class="tag">&lt;/<span class="name">ARTIST</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">COUNTRY</span>&gt;</span>USA<span class="tag">&lt;/<span class="name">COUNTRY</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">COMPANY</span>&gt;</span>Columbia<span class="tag">&lt;/<span class="name">COMPANY</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PRICE</span>&gt;</span>10.90<span class="tag">&lt;/<span class="name">PRICE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">YEAR</span>&gt;</span>1985<span class="tag">&lt;/<span class="name">YEAR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">CD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">CD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TITLE</span>&gt;</span>Hide your heart<span class="tag">&lt;/<span class="name">TITLE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ARTIST</span>&gt;</span>Bonnie Tyler<span class="tag">&lt;/<span class="name">ARTIST</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">COUNTRY</span>&gt;</span>UK<span class="tag">&lt;/<span class="name">COUNTRY</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">COMPANY</span>&gt;</span>CBS Records<span class="tag">&lt;/<span class="name">COMPANY</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PRICE</span>&gt;</span>9.90<span class="tag">&lt;/<span class="name">PRICE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">YEAR</span>&gt;</span>1988<span class="tag">&lt;/<span class="name">YEAR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">CD</span>&gt;</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="tag">&lt;/<span class="name">CATALOG</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二行代码连接了一个CSS文件，就可以按照CSS对xml文件进行格式化。</p>
<p>使用 CSS 格式化 XML 不是常用的方法。</p>
<p>W3C 推荐使用 XSLT。</p>
<h1>使用 XSLT 显示 XML</h1>
<p>通过使用 XSLT，您可以把 XML 文档转换成 HTML 格式。</p>
<h2 id="在服务器上通过-XSLT-转换-XML">在服务器上通过 XSLT 转换 XML</h2>
<p>在上面的实例中，当浏览器读取 XML 文件时，XSLT 转换是由浏览器完成的。</p>
<p>在使用 XSLT 来转换 XML 时，不同的浏览器可能会产生不同结果。为了减少这种问题，可以在服务器上进行 XSLT 转换。</p>
<h1>XMLHttpRequest 对象</h1>
<h2 id="XMLHttpRequest-对象">XMLHttpRequest 对象</h2>
<p>XMLHttpRequest 对象用于在后台与服务器交换数据。</p>
<p>XMLHttpRequest 对象是<strong>开发者的梦想</strong>，因为您能够：</p>
<ul>
<li>在不重新加载页面的情况下更新网页</li>
<li>在页面已加载后从服务器请求数据</li>
<li>在页面已加载后从服务器接收数据</li>
<li>在后台向服务器发送数据</li>
</ul>
<h2 id="创建一个-XMLHttpRequest-对象">创建一个 XMLHttpRequest 对象</h2>
<p>所有现代浏览器（IE7+、Firefox、Chrome、Safari 和 Opera）都有内建的 XMLHttpRequest 对象。</p>
<p>创建 XMLHttpRequest 对象的语法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlhttp=new XMLHttpRequest();</span><br></pre></td></tr></table></figure>
<h1>XML Parser</h1>
<p>所有现代浏览器都有内建的 XML 解析器。</p>
<p>XML 解析器把 XML 文档转换为 XML DOM 对象 - 可通过 JavaScript 操作的对象。</p>
<h2 id="解析-XML-文档">解析 XML 文档</h2>
<p>下面的代码片段把 XML 文档解析到 XML DOM 对象中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span><br><span class="line">&#123;<span class="comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span><br><span class="line">xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">// code for IE6, IE5</span></span><br><span class="line">xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;books.xml&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">xmlhttp.send();</span><br><span class="line">xmlDoc=xmlhttp.responseXML;</span><br></pre></td></tr></table></figure>
<h2 id="解析-XML-字符串">解析 XML 字符串</h2>
<p>下面的代码片段把 XML 字符串解析到 XML DOM 对象中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">txt=&quot;<span class="tag">&lt;<span class="name">bookstore</span>&gt;</span><span class="tag">&lt;<span class="name">book</span>&gt;</span>&quot;;</span><br><span class="line">txt=txt+&quot;<span class="tag">&lt;<span class="name">title</span>&gt;</span>Everyday Italian<span class="tag">&lt;/<span class="name">title</span>&gt;</span>&quot;;</span><br><span class="line">txt=txt+&quot;<span class="tag">&lt;<span class="name">author</span>&gt;</span>Giada De Laurentiis<span class="tag">&lt;/<span class="name">author</span>&gt;</span>&quot;;</span><br><span class="line">txt=txt+&quot;<span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span>&quot;;</span><br><span class="line">txt=txt+&quot;<span class="tag">&lt;/<span class="name">book</span>&gt;</span><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span>&quot;;</span><br><span class="line"></span><br><span class="line">if (window.DOMParser)</span><br><span class="line">&#123;</span><br><span class="line">parser=new DOMParser();</span><br><span class="line">xmlDoc=parser.parseFromString(txt,&quot;text/xml&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else // Internet Explorer</span><br><span class="line">&#123;</span><br><span class="line">xmlDoc=new ActiveXObject(&quot;Microsoft.XMLDOM&quot;);</span><br><span class="line">xmlDoc.async=false;</span><br><span class="line">xmlDoc.loadXML(txt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跨域访问">跨域访问</h2>
<p>出于安全方面的原因，现代的浏览器不允许跨域的访问。</p>
<p>这意味着，网页以及它试图加载的 XML 文件，都必须位于相同的服务器上。</p>
<h1>XML DOM</h1>
<p>相信很多人知道Html的Dom操作（文档对象模型）</p>
<p>XML DOM则定义了访问和操作 XML 文档的标准方法。</p>
<p>XML DOM 把 XML 文档作为树结构来查看。</p>
<p>所有元素可以通过 DOM 树来访问。可以修改或删除它们的内容，并创建新的元素。元素，它们的文本，以及它们的属性，都被认为是节点。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>W3Schools Internal Note<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>To:<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;to&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>From:<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;from&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>Message:<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span></span><br><span class="line"><span class="javascript">&#123;<span class="comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span></span><br><span class="line"><span class="javascript">xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">else</span></span></span><br><span class="line"><span class="javascript">&#123;<span class="comment">// code for IE6, IE5</span></span></span><br><span class="line"><span class="javascript">xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;note.xml&quot;</span>,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">xmlhttp.send();</span></span><br><span class="line"><span class="javascript">xmlDoc=xmlhttp.responseXML;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&quot;to&quot;</span>).innerHTML=</span></span><br><span class="line"><span class="javascript">xmlDoc.getElementsByTagName(<span class="string">&quot;to&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&quot;from&quot;</span>).innerHTML=</span></span><br><span class="line"><span class="javascript">xmlDoc.getElementsByTagName(<span class="string">&quot;from&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&quot;message&quot;</span>).innerHTML=</span></span><br><span class="line"><span class="javascript">xmlDoc.getElementsByTagName(<span class="string">&quot;body&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，即使 XML 文件只包含一个 <to> 元素，您仍然必须指定数组索引 [0]。这是因为 getElementsByTagName() 方法返回一个数组。</to></p>
</blockquote>
<h1>HTML 页面显示 XML 数据</h1>
<hr>
<h2 id="在-HTML-页面中显示-XML-数据">在 HTML 页面中显示 XML 数据</h2>
<p>在下面的实例中，我们打开一个 XML 文件（“<a href="https://www.runoob.com/try/xml/cd_catalog.xml">cd_catalog.xml</a>”），然后遍历每个 CD 元素，并显示HTML 表格中的 ARTIST 元素和 TITLE 元素的值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span></span><br><span class="line"><span class="javascript">&#123;<span class="comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span></span><br><span class="line"><span class="javascript">xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">else</span></span></span><br><span class="line"><span class="javascript">&#123;<span class="comment">// code for IE6, IE5</span></span></span><br><span class="line"><span class="javascript">xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;cd_catalog.xml&quot;</span>,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">xmlhttp.send();</span></span><br><span class="line"><span class="javascript">xmlDoc=xmlhttp.responseXML;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;table border=&#x27;1&#x27;&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> x=xmlDoc.getElementsByTagName(<span class="string">&quot;CD&quot;</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;x.length;i++)</span></span><br><span class="line"><span class="javascript">&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(x[i].getElementsByTagName(<span class="string">&quot;ARTIST&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(x[i].getElementsByTagName(<span class="string">&quot;TITLE&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;/td&gt;&lt;/tr&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;/table&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Xml-可扩展标记语言</title>
    <url>/2022/04/18/Xml/</url>
    <content><![CDATA[<h1>Xml-可扩展标记语言-概述</h1>
<h2 id="用途">用途</h2>
<p>1、XML 的设计宗旨是传输数据，而不是显示数据。毕竟显示数据是HTML干的活。</p>
<p>2、xml只是一个文件，他需要软件的运行来显现内容（不像HTML可以直接打开）。</p>
<p>3、同样都是标记语言，xml的标签由你自己决定。</p>
<p><strong>XML 把数据从 HTML 分离</strong></p>
<p>如果你需要在 HTML 文档中显示动态数据，那么每当数据改变时将花费大量的时间来编辑 HTML。</p>
<p>通过 XML，数据能够存储在独立的 XML 文件中。这样您就可以专注于使用 HTML/CSS 进行显示和布局，并确保修改底层数据不再需要对 HTML 进行任何的改变。</p>
<p>通过使用几行 JavaScript 代码，您就可以读取一个外部 XML 文件，并更新您的网页的数据内容。</p>
<p><strong>XML 简化数据传输</strong></p>
<p>对开发人员来说，其中一项最费时的挑战一直是在互联网上的不兼容系统之间交换数据。</p>
<p>由于可以通过各种不兼容的应用程序来读取数据，以 XML 交换数据降低了这种复杂性。</p>
<h1>XML 树结构</h1>
<p>xml的数据具有出色的自我描述性，</p>
<p>XML 文档必须包含<strong>根元素</strong>。该元素是所有其他元素的父元素。</p>
<p>XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。</p>
<p>所有的元素都可以有子元素：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">subchild</span>&gt;</span></span><br><span class="line">            .....</span><br><span class="line">        <span class="tag">&lt;/<span class="name">subchild</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>父、子以及同胞等术语用于描述元素之间的关系。父元素拥有子元素。相同层级上的子元素成为同胞（兄弟或姐妹）。</p>
<p>所有的元素都可以有文本内容和属性（类似 HTML 中）。</p>
<p>例如：这是几本不同属性的书</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;COOKING&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Everyday Italian<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>Giada De Laurentiis<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>30.00<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;CHILDREN&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;WEB&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>Erik T. Ray<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2003<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>良好的层级结构使得xml更易于阅读。</p>
<h1>xml语法</h1>
<p><strong>XML 文档必须有根元素</strong></p>
<p>像是上面的例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">subchild</span>&gt;</span></span><br><span class="line">            .....</span><br><span class="line">        <span class="tag">&lt;/<span class="name">subchild</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>root即为根元素。</p>
<h2 id="XML-声明">XML 声明</h2>
<p>XML 声明文件的可选部分，如果存在需要放在文档的第一行，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>version代表xml版本，encoding代表编码格式。</p>
<h2 id="所有的-XML-元素都必须有一个关闭标签">所有的 XML 元素都必须有一个关闭标签</h2>
<p>在 HTML 中，某些元素不必有一个关闭标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;This is a paragraph.</span><br><span class="line">&lt;br&gt;</span><br></pre></td></tr></table></figure>
<p>在 XML 中，省略关闭标签是非法的。所有元素都<strong>必须</strong>有关闭标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;This is a paragraph.&lt;/p&gt;</span><br><span class="line">&lt;br /&gt;</span><br></pre></td></tr></table></figure>
<p>由于声明本身不属于xml文档的一部分，所以它不需要关闭标签。</p>
<h2 id="XML-标签对大小写敏感">XML 标签对大小写敏感</h2>
<p>XML 标签对大小写敏感。标签 <Letter> 与标签 <letter> 是不同的。</letter></Letter></p>
<p>必须使用相同的大小写来编写打开标签和关闭标签：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Message</span>&gt;</span>这是错误的<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span>这是正确的<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="XML-必须正确嵌套">XML 必须正确嵌套</h2>
<p>在 HTML 中，常会看到没有正确嵌套的元素：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>This text is bold and italic<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 XML 中，所有元素都<strong>必须</strong>彼此正确地嵌套：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>This text is bold and italic<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的实例中，正确嵌套的意思是：由于 <i> 元素是在 <b> 元素内打开的，那么它必须在 <b> 元素内关闭。</b></b></i></p>
<blockquote>
<p>由于xml是作为数据传输文件而存在的，所以语法要求比以展现为功能的HTML要严格许多。</p>
</blockquote>
<h2 id="XML-属性值必须加引号">XML 属性值必须加引号</h2>
<p>与 HTML 类似，XML 元素也可拥有属性（名称/值的对）。</p>
<p>在 XML 中，XML 的属性值必须加引号。</p>
<p>请研究下面的两个 XML 文档。 第一个是错误的，第二个是正确的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span> <span class="attr">date</span>=<span class="string">12/11/2007</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span> <span class="attr">date</span>=<span class="string">&quot;12/11/2007&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在第一个文档中的错误是，note 元素中的 date 属性没有加引号。</p>
<h2 id="实体引用">实体引用</h2>
<p>在 XML 中，一些字符拥有特殊的意义。</p>
<p>如果您把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。</p>
<p>这样会产生 XML 错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;</span><br></pre></td></tr></table></figure>
<p>为了避免这个错误，请用<strong>实体引用</strong>来代替 “&lt;” 字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt;</span><br></pre></td></tr></table></figure>
<p>在 XML 中，有 5 个预定义的实体引用(<strong>实际应用时注意添加分号！</strong>)：</p>
<table>
<thead>
<tr>
<th>&amp;lt</th>
<th>&lt;</th>
<th>less than</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;gt</td>
<td>&gt;</td>
<td>greater than</td>
</tr>
<tr>
<td>&amp;amp</td>
<td>&amp;</td>
<td>ampersand</td>
</tr>
<tr>
<td>&amp;apos</td>
<td>’</td>
<td>apostrophe</td>
</tr>
<tr>
<td>&amp;quot</td>
<td>&quot;</td>
<td>quotation mark</td>
</tr>
</tbody>
</table>
<p>在 XML 中，只有字符 “&lt;” 和 “&amp;” 是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。</p>
<p>(1)属性值用双引号 <strong>&quot;</strong> 或单引号 <strong>’</strong> 分隔，如果属性值中有单引号，则用双引号分隔；如果有双引号，则用单引号分隔。那么如果属性值中既有单引号还有双引号怎么办？这种要使用实体（转义字符，类似于html中的空格符），XML 有 5 个预定义的实体字符，如下：</p>
<p><img src="/2022/04/18/Xml/blog/source/20160526222841679.png" alt="img"></p>
<p>(2)一个元素可以有多个属性，它的基本格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;元素名 属性名1=&quot;属性值1&quot; 属性名2=&quot;属性值2&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>(3)特定的属性名称在同一个元素标记中只能出现一次</p>
<p>(4)属性值不能包括 &lt;,&gt;,&amp;，如果一定要包含，也要使用实体</p>
<h2 id="XML-中的注释">XML 中的注释</h2>
<p>在 XML 中编写注释的语法与 HTML 的语法很相似。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- This is a comment --&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="在-XML-中，空格会被保留">在 XML 中，空格会被保留</h2>
<p>HTML 会把多个连续的空格字符裁减（合并）为一个：</p>
<table>
<thead>
<tr>
<th>HTML:</th>
<th><code>Hello           Tove</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>输出结果:</td>
<td>Hello Tove</td>
</tr>
</tbody>
</table>
<p>在 XML 中，文档中的空格不会被删减。</p>
<h2 id="XML-以-LF-存储换行">XML 以 LF 存储换行</h2>
<h1>XML 元素</h1>
<p>XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。</p>
<p>一个元素可以包含：</p>
<ul>
<li>其他元素</li>
<li>文本</li>
<li>属性</li>
<li>或混合以上所有…</li>
</ul>
<h2 id="XML-命名规则">XML 命名规则</h2>
<p>XML 元素必须遵循以下命名规则：</p>
<ul>
<li>名称可以包含字母、数字以及其他的字符</li>
<li>名称不能以数字或者标点符号开始</li>
<li>名称不能以字母 xml（或者 XML、Xml 等等）开始</li>
<li>名称不能包含空格</li>
</ul>
<p>可使用任何名称，没有保留的字词。</p>
<h2 id="最佳命名习惯">最佳命名习惯</h2>
<p>使名称具有描述性。使用下划线的名称也很不错：&lt;first_name&gt;、&lt;last_name&gt;。</p>
<p>名称应简短和简单，比如：&lt;book_title&gt;，而不是：&lt;the_title_of_the_book&gt;。</p>
<p>避免 “-” 字符。如果您按照这样的方式进行命名：“first-name”，一些软件会认为您想要从 first 里边减去 name。</p>
<p>避免 “.” 字符。如果您按照这样的方式进行命名：“<a href="http://first.name">first.name</a>”，一些软件会认为 “name” 是对象 “first” 的属性。</p>
<p>避免 “:” 字符。冒号会被转换为命名空间来使用。</p>
<h2 id="XML-元素是可扩展的">XML 元素是可扩展的</h2>
<p>XML 元素是可扩展，以携带更多的信息。</p>
<p>请看下面的 XML 实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>让我们设想一下，我们创建了一个应用程序，可将 <to>、<from> 以及 <body> 元素从 XML 文档中提取出来，并产生以下的输出：</body></from></to></p>
<p><strong>MESSAGE</strong></p>
<p><strong>To:</strong> Tove</p>
<p><strong>From:</strong> JaniDon’t forget me this weekend!</p>
<p>想象一下，XML 文档的作者添加的一些额外信息：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">date</span>&gt;</span>2008-01-10<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么这个应用程序会中断或崩溃吗？</p>
<p>不会。这个应用程序仍然可以找到 XML 文档中的 <to>、<from> 以及 <body> 元素，并产生同样的输出。</body></from></to></p>
<p>XML 的优势之一，就是可以在不中断应用程序的情况下进行扩展。</p>
<h1>XML 属性</h1>
<p>XML元素具有属性，类似 HTML。</p>
<p>属性（Attribute）提供有关元素的额外信息。决定元素的一些其他性质。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;demo.html&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于标签的一些重要的属性的改变。</p>
<h2 id="XML-属性必须加引号">XML 属性必须加引号</h2>
<p>属性值必须被引号包围，不过单引号和双引号均可使用。比如一个人的性别，person 元素可以这样写：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span> <span class="attr">sex</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="XML-元素-vs-属性">XML 元素 vs. 属性</h2>
<p>请看这些实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span> <span class="attr">sex</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">firstname</span>&gt;</span>Anna<span class="tag">&lt;/<span class="name">firstname</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lastname</span>&gt;</span>Smith<span class="tag">&lt;/<span class="name">lastname</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sex</span>&gt;</span>female<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">firstname</span>&gt;</span>Anna<span class="tag">&lt;/<span class="name">firstname</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lastname</span>&gt;</span>Smith<span class="tag">&lt;/<span class="name">lastname</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在第一个实例中，sex 是一个属性。在第二个实例中，sex 是一个元素。这两个实例都提供相同的信息。</p>
<p>没有什么规矩可以告诉我们什么时候该使用属性，而什么时候该使用元素。我的经验是在 HTML 中，属性用起来很便利，但是在 XML 中，您应该尽量避免使用属性。如果信息感觉起来很像数据，那么请使用元素吧。</p>
<h2 id="避免-XML-属性">避免 XML 属性</h2>
<p>因使用属性而引起的一些问题：</p>
<ul>
<li>属性不能包含多个值（元素可以）</li>
<li>属性不能包含树结构（元素可以）</li>
<li>属性不容易扩展（为未来的变化）</li>
</ul>
<p>属性难以阅读和维护。请尽量使用元素来描述数据。而仅仅使用属性来提供与数据无关的信息。</p>
<p>不要做这样的蠢事（这不是 XML 应该被使用的方式）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span> <span class="attr">day</span>=<span class="string">&quot;10&quot;</span> <span class="attr">month</span>=<span class="string">&quot;01&quot;</span> <span class="attr">year</span>=<span class="string">&quot;2008&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">to</span>=<span class="string">&quot;Tove&quot;</span> <span class="attr">from</span>=<span class="string">&quot;Jani&quot;</span> <span class="attr">heading</span>=<span class="string">&quot;Reminder&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">body</span>=<span class="string">&quot;Don&#x27;t forget me this weekend!&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样令人看着就头大的xml不利于阅读与维护。</p>
</blockquote>
<h1>XML 验证</h1>
<p>拥有正确语法的 XML 被称为&quot;形式良好&quot;的 XML。</p>
<p>通过 DTD 验证的XML是&quot;合法&quot;的 XML。</p>
<p>式良好&quot;的 XML 文档拥有正确的语法。</p>
<p>在前面的章节描述的语法规则：</p>
<ul>
<li>XML 文档必须有一个根元素</li>
<li>XML元素都必须有一个关闭标签</li>
<li>XML 标签对大小写敏感</li>
<li>XML 元素必须被正确的嵌套</li>
<li>XML 属性值必须加引号</li>
</ul>
<h1>查看 XML 文件</h1>
<p>他们被浏览器打开后是这个样子的：</p>
<p><img src="/2022/04/18/Xml/image-20220408173721335.png" alt="image-20220408173721335"></p>
<p>与Html那样专注与展现不同，xml打开是以这样的数据模式打开。并没有HTML的&lt;p&gt;那样指定为可以被浏览器理解为段落并进行相关展示。</p>
<h1>使用 CSS 显示 XML</h1>
<p>下面是 XML 文件的一小部分。第二行把 XML 文件链接到 CSS 文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;cd_catalog.css&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">CATALOG</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">CD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TITLE</span>&gt;</span>Empire Burlesque<span class="tag">&lt;/<span class="name">TITLE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ARTIST</span>&gt;</span>Bob Dylan<span class="tag">&lt;/<span class="name">ARTIST</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">COUNTRY</span>&gt;</span>USA<span class="tag">&lt;/<span class="name">COUNTRY</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">COMPANY</span>&gt;</span>Columbia<span class="tag">&lt;/<span class="name">COMPANY</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PRICE</span>&gt;</span>10.90<span class="tag">&lt;/<span class="name">PRICE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">YEAR</span>&gt;</span>1985<span class="tag">&lt;/<span class="name">YEAR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">CD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">CD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TITLE</span>&gt;</span>Hide your heart<span class="tag">&lt;/<span class="name">TITLE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ARTIST</span>&gt;</span>Bonnie Tyler<span class="tag">&lt;/<span class="name">ARTIST</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">COUNTRY</span>&gt;</span>UK<span class="tag">&lt;/<span class="name">COUNTRY</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">COMPANY</span>&gt;</span>CBS Records<span class="tag">&lt;/<span class="name">COMPANY</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PRICE</span>&gt;</span>9.90<span class="tag">&lt;/<span class="name">PRICE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">YEAR</span>&gt;</span>1988<span class="tag">&lt;/<span class="name">YEAR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">CD</span>&gt;</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="tag">&lt;/<span class="name">CATALOG</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二行代码连接了一个CSS文件，就可以按照CSS对xml文件进行格式化。</p>
<p>使用 CSS 格式化 XML 不是常用的方法。</p>
<p>W3C 推荐使用 XSLT。</p>
<h1>使用 XSLT 显示 XML</h1>
<p>通过使用 XSLT，您可以把 XML 文档转换成 HTML 格式。</p>
<h2 id="在服务器上通过-XSLT-转换-XML">在服务器上通过 XSLT 转换 XML</h2>
<p>在上面的实例中，当浏览器读取 XML 文件时，XSLT 转换是由浏览器完成的。</p>
<p>在使用 XSLT 来转换 XML 时，不同的浏览器可能会产生不同结果。为了减少这种问题，可以在服务器上进行 XSLT 转换。</p>
<h1>XMLHttpRequest 对象</h1>
<h2 id="XMLHttpRequest-对象">XMLHttpRequest 对象</h2>
<p>XMLHttpRequest 对象用于在后台与服务器交换数据。</p>
<p>XMLHttpRequest 对象是<strong>开发者的梦想</strong>，因为您能够：</p>
<ul>
<li>在不重新加载页面的情况下更新网页</li>
<li>在页面已加载后从服务器请求数据</li>
<li>在页面已加载后从服务器接收数据</li>
<li>在后台向服务器发送数据</li>
</ul>
<h2 id="创建一个-XMLHttpRequest-对象">创建一个 XMLHttpRequest 对象</h2>
<p>所有现代浏览器（IE7+、Firefox、Chrome、Safari 和 Opera）都有内建的 XMLHttpRequest 对象。</p>
<p>创建 XMLHttpRequest 对象的语法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlhttp=new XMLHttpRequest();</span><br></pre></td></tr></table></figure>
<h1>XML Parser</h1>
<p>所有现代浏览器都有内建的 XML 解析器。</p>
<p>XML 解析器把 XML 文档转换为 XML DOM 对象 - 可通过 JavaScript 操作的对象。</p>
<h2 id="解析-XML-文档">解析 XML 文档</h2>
<p>下面的代码片段把 XML 文档解析到 XML DOM 对象中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span><br><span class="line">&#123;<span class="comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span><br><span class="line">xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">// code for IE6, IE5</span></span><br><span class="line">xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;books.xml&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">xmlhttp.send();</span><br><span class="line">xmlDoc=xmlhttp.responseXML;</span><br></pre></td></tr></table></figure>
<h2 id="解析-XML-字符串">解析 XML 字符串</h2>
<p>下面的代码片段把 XML 字符串解析到 XML DOM 对象中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">txt=&quot;<span class="tag">&lt;<span class="name">bookstore</span>&gt;</span><span class="tag">&lt;<span class="name">book</span>&gt;</span>&quot;;</span><br><span class="line">txt=txt+&quot;<span class="tag">&lt;<span class="name">title</span>&gt;</span>Everyday Italian<span class="tag">&lt;/<span class="name">title</span>&gt;</span>&quot;;</span><br><span class="line">txt=txt+&quot;<span class="tag">&lt;<span class="name">author</span>&gt;</span>Giada De Laurentiis<span class="tag">&lt;/<span class="name">author</span>&gt;</span>&quot;;</span><br><span class="line">txt=txt+&quot;<span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span>&quot;;</span><br><span class="line">txt=txt+&quot;<span class="tag">&lt;/<span class="name">book</span>&gt;</span><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span>&quot;;</span><br><span class="line"></span><br><span class="line">if (window.DOMParser)</span><br><span class="line">&#123;</span><br><span class="line">parser=new DOMParser();</span><br><span class="line">xmlDoc=parser.parseFromString(txt,&quot;text/xml&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else // Internet Explorer</span><br><span class="line">&#123;</span><br><span class="line">xmlDoc=new ActiveXObject(&quot;Microsoft.XMLDOM&quot;);</span><br><span class="line">xmlDoc.async=false;</span><br><span class="line">xmlDoc.loadXML(txt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跨域访问">跨域访问</h2>
<p>出于安全方面的原因，现代的浏览器不允许跨域的访问。</p>
<p>这意味着，网页以及它试图加载的 XML 文件，都必须位于相同的服务器上。</p>
<h1>XML DOM</h1>
<p>相信很多人知道Html的Dom操作（文档对象模型）</p>
<p>XML DOM则定义了访问和操作 XML 文档的标准方法。</p>
<p>XML DOM 把 XML 文档作为树结构来查看。</p>
<p>所有元素可以通过 DOM 树来访问。可以修改或删除它们的内容，并创建新的元素。元素，它们的文本，以及它们的属性，都被认为是节点。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>W3Schools Internal Note<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>To:<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;to&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>From:<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;from&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>Message:<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span></span><br><span class="line"><span class="javascript">&#123;<span class="comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span></span><br><span class="line"><span class="javascript">xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">else</span></span></span><br><span class="line"><span class="javascript">&#123;<span class="comment">// code for IE6, IE5</span></span></span><br><span class="line"><span class="javascript">xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;note.xml&quot;</span>,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">xmlhttp.send();</span></span><br><span class="line"><span class="javascript">xmlDoc=xmlhttp.responseXML;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&quot;to&quot;</span>).innerHTML=</span></span><br><span class="line"><span class="javascript">xmlDoc.getElementsByTagName(<span class="string">&quot;to&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&quot;from&quot;</span>).innerHTML=</span></span><br><span class="line"><span class="javascript">xmlDoc.getElementsByTagName(<span class="string">&quot;from&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&quot;message&quot;</span>).innerHTML=</span></span><br><span class="line"><span class="javascript">xmlDoc.getElementsByTagName(<span class="string">&quot;body&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，即使 XML 文件只包含一个 <to> 元素，您仍然必须指定数组索引 [0]。这是因为 getElementsByTagName() 方法返回一个数组。</to></p>
</blockquote>
<h1>HTML 页面显示 XML 数据</h1>
<hr>
<h2 id="在-HTML-页面中显示-XML-数据">在 HTML 页面中显示 XML 数据</h2>
<p>在下面的实例中，我们打开一个 XML 文件（“<a href="https://www.runoob.com/try/xml/cd_catalog.xml">cd_catalog.xml</a>”），然后遍历每个 CD 元素，并显示HTML 表格中的 ARTIST 元素和 TITLE 元素的值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span></span><br><span class="line"><span class="javascript">&#123;<span class="comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span></span><br><span class="line"><span class="javascript">xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">else</span></span></span><br><span class="line"><span class="javascript">&#123;<span class="comment">// code for IE6, IE5</span></span></span><br><span class="line"><span class="javascript">xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;cd_catalog.xml&quot;</span>,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">xmlhttp.send();</span></span><br><span class="line"><span class="javascript">xmlDoc=xmlhttp.responseXML;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;table border=&#x27;1&#x27;&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> x=xmlDoc.getElementsByTagName(<span class="string">&quot;CD&quot;</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;x.length;i++)</span></span><br><span class="line"><span class="javascript">&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(x[i].getElementsByTagName(<span class="string">&quot;ARTIST&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(x[i].getElementsByTagName(<span class="string">&quot;TITLE&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;/td&gt;&lt;/tr&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;/table&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2021/10/26/hello-world/</url>
    <content><![CDATA[<p>你好，我的同志，这是我的第一篇博客，显而易见的是我正在学习中，所以页面会非常粗糙，还请见谅！</p>
<h2 id="起源">起源</h2>
<h3 id="一开始">一开始</h3>
<p>建立博客的缘由是因为几位朋友都有了属于他们自己的博客，这让我很感兴趣。</p>
<p>第一步</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="后来嘛">后来嘛</h3>
<p>上网找教程，最后选择了hexo+gitee（码云）的方式部署博客，期间遇到了很多问题，后来大部分都慢慢解决了，但还是有一些现在还没<br>
解决的问题。<br>
比如说：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git@gitee.com: Permission denied (publickey)</span><br></pre></td></tr></table></figure>
<p>配置的ssh明明完美无缺，可通讯还是不行，我猜测是因为我windows用户名是中文的原因，还得再试试。</p>
<h3 id="而现在">而现在</h3>
<p>我之前有一个团队网站，为了测试我把它放在这里。</p>
<p>More info: <a href="http://tocode.e.cn.vc/2">Tocode团队</a></p>
<h3 id="在未来">在未来</h3>
<p>我会继续努力的，总之感谢大家了！</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>感想</category>
      </categories>
      <tags>
        <tag>关于</tag>
      </tags>
  </entry>
  <entry>
    <title>NPM 使用介绍</title>
    <url>/2022/04/01/npm%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1>NPM 使用介绍</h1>
<p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p>
<ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
</ul>
<p>由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 <strong>“npm -v”</strong> 来测试是否成功安装。命令如下，出现版本提示表示安装成功:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npm -v</span><br><span class="line"><span class="number">2.3</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p>也可以通过命令对npm进行升级：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install npm -g</span><br></pre></td></tr></table></figure>
<h1>使用 npm 命令安装模块</h1>
<p>npm 安装 Node.js 模块语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install &lt;Module Name&gt;</span><br></pre></td></tr></table></figure>
<p>以下实例，我们使用 npm 命令安装常用的 Node.js web框架模块 <strong>express</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install express</span><br></pre></td></tr></table></figure>
<p>安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 <strong>require(‘express’)</strong> 的方式就好，无需指定第三方包路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br></pre></td></tr></table></figure>
<h3 id="本地安装">本地安装</h3>
<ul>
<li>\1. 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li>
<li>\2. 可以通过 require() 来引入本地安装的包。</li>
</ul>
<h3 id="全局安装">全局安装</h3>
<ul>
<li>\1. 将安装包放在 /usr/local 下或者你 node 的安装目录。</li>
<li>\2. 可以直接在命令行里使用。</li>
</ul>
<p>如果你希望具备两者功能，则需要在两个地方安装它或使用 <strong>npm link</strong>。</p>
<p>接下来我们使用全局方式安装 express</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install express -g</span><br></pre></td></tr></table></figure>
<h1>查看安装信息</h1>
<p>你可以使用以下命令来查看所有全局安装的模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm list -g</span><br><span class="line"></span><br><span class="line">├─┬ cnpm@4.3.2</span><br><span class="line">│ ├── auto-correct@1.0.0</span><br><span class="line">│ ├── bagpipe@0.3.5</span><br><span class="line">│ ├── colors@1.1.2</span><br><span class="line">│ ├─┬ commander@2.9.0</span><br><span class="line">│ │ └── graceful-readlink@1.0.1</span><br><span class="line">│ ├─┬ cross-spawn@0.2.9</span><br><span class="line">│ │ └── lru-cache@2.7.3</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>如果要查看某个模块的版本号，可以使用命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm list grunt</span><br><span class="line"></span><br><span class="line">projectName@projectVersion /path/to/project/folder</span><br><span class="line">└── grunt@0.4.1</span><br></pre></td></tr></table></figure>
<h1>package.json</h1>
<p>ackage.json 位于模块的目录下，用于定义包的属性。</p>
<h3 id="Package-json-属性说明">Package.json 属性说明</h3>
<ul>
<li><strong>name</strong> - 包名。</li>
<li><strong>version</strong> - 包的版本号。</li>
<li><strong>description</strong> - 包的描述。</li>
<li><strong>homepage</strong> - 包的官网 url 。</li>
<li><strong>author</strong> - 包的作者姓名。</li>
<li><strong>contributors</strong> - 包的其他贡献者姓名。</li>
<li><strong>dependencies</strong> - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。</li>
<li><strong>repository</strong> - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。</li>
<li><strong>main</strong> - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。</li>
<li><strong>keywords</strong> - 关键字</li>
</ul>
<h1>卸载模块</h1>
<p>我们可以使用以下命令来卸载 Node.js 模块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm uninstall express</span><br></pre></td></tr></table></figure>
<p>卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm ls</span><br></pre></td></tr></table></figure>
<hr>
<h1>更新模块</h1>
<p>我们可以使用以下命令更新模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm update express</span><br></pre></td></tr></table></figure>
<hr>
<h1>搜索模块</h1>
<p>使用以下来搜索模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm search express</span><br></pre></td></tr></table></figure>
<h1>NPM 常用命令</h1>
<p>除了本章介绍的部分外，NPM还提供了很多功能，package.json里也有很多其它有用的字段。</p>
<p>除了可以在<a href="https://npmjs.org/doc/">npmjs.org/doc/</a>查看官方文档外，这里再介绍一些NPM常用命令。</p>
<p>NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。</p>
<ul>
<li>NPM提供了很多命令，例如<code>install</code>和<code>publish</code>，使用<code>npm help</code>可查看所有命令。</li>
<li>使用<code>npm help &lt;command&gt;</code>可查看某条命令的详细帮助，例如<code>npm help install</code>。</li>
<li>在<code>package.json</code>所在目录下使用<code>npm install . -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</li>
<li>使用<code>npm update &lt;package&gt;</code>可以把当前目录下<code>node_modules</code>子目录里边的对应模块更新至最新版本。</li>
<li>使用<code>npm update &lt;package&gt; -g</code>可以把全局安装的对应命令行程序更新至最新版。</li>
<li>使用<code>npm cache clear</code>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</li>
<li>使用<code>npm unpublish &lt;package&gt;@&lt;version&gt;</code>可以撤销发布自己发布过的某个版本代码。</li>
</ul>
<h1>使用淘宝 NPM 镜像</h1>
<p>大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。</p>
<p>淘宝 NPM 镜像是一个完整 <a href="http://npmjs.org">npmjs.org</a> 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p>
<p>你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>
<p>这样就可以使用 cnpm 命令来安装模块了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cnpm install [name]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
        <category>小工具</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
      </tags>
  </entry>
  <entry>
    <title>两日之恋人</title>
    <url>/2021/12/19/%E4%B8%A4%E6%97%A5%E4%B9%8B%E6%81%8B%E4%BA%BA/</url>
    <content><![CDATA[<p>筠池点了投降。</p>
<p>并不是这局已经无力回天让人痛苦，而是筠池突然感到了厌烦。</p>
<p>这几天筠池时不时的就会感觉到莫名心累，前几天还在嘲笑俞佑，没想到报应来的这么快。</p>
<p>队友当然不会放过他，开始进行各种语言攻击。</p>
<p>筠池瞟了一眼消息栏，然后直接退出游戏，关掉了显示器。</p>
<p>在漆黑的屏幕里他看见了自己的脸，他惊讶于自己彷佛是在观察一个陌生人那样看着自己，里面的人自己好像并不熟悉。</p>
<p>他打开手机，有二十三条未读消息的提醒占据了屏幕，是来自女友的。</p>
<p>最新的一条是“你到底爱不爱我？”</p>
<p>筠池没动，关掉了手机，熄掉了最后一丝光亮，疲惫地瘫在了沙发上。</p>
<p>自己以前不是这样的。</p>
<p>筠池记得以前的事，那时候自己喜欢打游戏是真的，经常做梦是真的，和同伴说骚话是真的，甚至。</p>
<p>爱上葭凛也是真的。</p>
<p>但是筠池忘了葭凛是怎么成为自己女朋友的了，就好像小时候偷偷在楼下租的影碟，播放到令人激动的剧情时，总是用“一夜之后”这样的字来搪塞，令小时候的筠池痛苦不已。</p>
<p>现在也是这样，筠池已经忘记的影片的剧情了，但“一夜之后”却无奈印入了脑海。</p>
<p>也许是自己勇敢表白，葭凛羞涩地回应了他？或者是葭凛提前发现了自己的心意，她的大胆表露？再不然是两个人不约而同的默契眼神？</p>
<p>筠池没有察觉到自己轻轻地笑了笑。</p>
<p>初长成的爱情总是这样的，总有人会觉得令人回味。</p>
<p>后来呢，又发生了什么吗。</p>
<p>筠池拼命回忆，他只想知道，这一切是自己的错吗。</p>
<p>该轮到自己负责了吗。</p>
<p>这也许毫无疑问，但筠池依然想找到点什么。</p>
<p>忽然，他好像真的找到了什么。</p>
<p>那是关于一个名字的，葭凛。</p>
<p>葭凛是个不错的女孩，筠池和她是青梅竹马，两家人的关系一直不错。</p>
<p>筠池是在高中后和她联系又多了起来的。</p>
<p>一定有什么原因，一定发生了什么。</p>
<p>他觉得自己陷入了一个迷宫，这迷宫如此之熟悉，筠池对它了如指掌。</p>
<p>可是他迷路了，明记下个得转弯就是出口，可那里竟然凭空出现一堵墙，上面写着“一夜之后”立在中间，分割了他和出口。</p>
<p>也分割了他与葭凛。</p>
<p>他不想再想下去了，站到窗前拉开了窗帘，望着窗外伴随着蝉声的夜色，筠池平静了下来。</p>
<p>“我觉得你还是太幼稚了吧”</p>
<p>那是葭凛的声音，筠池非常肯定。</p>
<p>他不再犹豫，做回桌前再次打开了电脑。</p>
<p>并不是像甩掉包袱的感觉，更像是多添了一道代表历练的伤疤。</p>
<p>重新连接发现队友还在坚守高地。</p>
<p>并不是每个人都很成熟，但总有人正成长着。</p>
<p>他久违地打开输入框，认真地敲下每一个字。</p>
<p>并不是每次都可以轻松逃掉的，这次就不行。</p>
<p>“不好意思，稳住我来C。”</p>
<p>他想葭凛了。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>记录</category>
      </categories>
      <tags>
        <tag>时间的恋人</tag>
      </tags>
  </entry>
  <entry>
    <title>了解一定基础算法</title>
    <url>/2022/03/01/%E4%BA%86%E8%A7%A3%E4%B8%80%E5%AE%9A%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1>快速排序</h1>
<p>其本质在于分治思想，在确定一个模板数（在数列里任取）后，把小于它的所有数放在左边，大于它的所有数放在右边，然后再对两边进行递归处理。</p>
<p>模板代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> x=q[l],i=l<span class="number">-1</span>,j=r+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">    <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">    <span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">    <span class="keyword">if</span>(i&lt;j)<span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">quick_sort</span>(q,l,i<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">quick_sort</span>(q,i,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十日之恋人</title>
    <url>/2021/12/19/%E5%8D%81%E6%97%A5%E4%B9%8B%E6%81%8B%E4%BA%BA/</url>
    <content><![CDATA[<p>俞佑回来了。</p>
<p>“只要我去找他，无论什么时候，他还是会等我的。“</p>
<p>“没有我，他根本活不下去。”</p>
<p>婉夏真的这么有把握？</p>
<p>她的确有把握，因为她知道俞佑爱她爱得要命。</p>
<p>俞佑已经好几天没有回来了，现在终于有消息了。</p>
<p>“他果然还会回到西南石油，因为那是‘我们的家’， 那里还有俞佑辛辛苦苦抽出来的装备，攒的各种各样的玩意儿。”</p>
<p>”他一定还在等着我回去。&quot;</p>
<p>想到这里，婉夏心里忽然觉得舒服多了。</p>
<p>”这两天他一定什么事都不想做，一直忙着跟那些bug对线，甚至连作业和预习都没有弄完。&quot;</p>
<p>想到这里，婉夏又不禁皱了皱眉。</p>
<p>&quot;但是没关系，只要我一见他，无论什么事，他都会抢 着去做了，根本不用我动手。 <strong>”</strong></p>
<p>婉夏满足地叹了口气，一个人已到了她这种时候，想 到还有个地方可以回去，还有人在苦苦地等着她，这 种感觉实在令人愉快。</p>
<p>“以前我对他也许的确太狠了些，逼他逼得太紧，以后 我也要改变方针了。”</p>
<p>”男人就像是孩子，你要他听话，多少也得给他点甜头 吃吃。”</p>
<p>想到这里，她忽然觉得心里有点发热。</p>
<p>”无论如何，他虽然不是个很强的男人，但毕竟不是个 很令人讨厌的人。”</p>
<p>她忽然发觉自己还是有点爱他的。</p>
<p>她这一生中，假如还有个人能真的令她动一点感情， 那人就是俞佑了，想得越多，她就越觉得俞佑的好处 比别人多。</p>
<p>“我真该好好地对他才是，像他这样又氟金又暴肝的男 人，世上并不多，以后我也许再也找不到了。&quot; 越想她越觉得不能放弃他。</p>
<p>也许她一直都在爱着他，只不过因为他爱得太深了， 所以才令她觉得无所谓。</p>
<p>他舔她舔得若没有那么深，她说不定反而会更爱他。 这就是人性的弱点，人性的矛盾。</p>
<p>所以聪明的男人就算爱极了一个女人，也只是藏在心 里，绝不要将他的爱全部在她面前表现出来。</p>
<p>&quot;俞佑，你放心，以后我绝不会再令你伤心了，我一定 天天陪着你，以前的事全已过去，现在我们再重头做起。</p>
<p>&quot;只要你还像以前那样对我，我什么事都可以依着你。</p>
<p>但俞佑是不是还会像以前那样对她呢？</p>
<p>婉夏忽然觉得并不十分有把握，对自己的信心已动摇。</p>
<p>她以前从未有过这种感觉，那只因她以前从未觉得俞佑对她有如此重要，无论俞佑对她是好是坏，她都全不放在心上。</p>
<p>一个人只有在很想“得到”的时候，才会怕&quot;失去”</p>
<p>这种患得患失的感觉，也正是人类许多种弱点之一。</p>
<p>可悲的是，你想&quot;得到”的人越急切，&quot;失去”的可能就越 大。</p>
<p>婉夏抬起头，已看到西南石油。</p>
<p>西南石油的俞佑室里居然有灯。</p>
<p>她忽然停下来，换了身衣裳，洗了洗脸，擦了擦大腿 和手臂的痕迹，又喷了点香水来掩盖味道，又用手指做梳子，梳了梳头发。</p>
<p>她不愿让俞佑看到她这种狼狈的样子。</p>
<p>因为她绝不能再失去他。</p>
<p>屋子里的灯还在亮着。</p>
<p>西南石油里很安静，静的好像没有什么人。</p>
<p>俞佑正坐在电脑旁，不知道在做什么。</p>
<p>滴滴滴，鼠标点击的声音密密麻麻的。</p>
<p>他看着很淡然，似乎在坐着再平常不过的日常活动，夜已深。</p>
<p>一个人面对着电脑，慢慢地点击着。</p>
<p>没有看到过这种景象的人，绝不会想到这景象是多么寂寞，多么凄凉。</p>
<p>然后，门轻轻被推开了。</p>
<p>婉夏忽然出现在门口，瞧着他。</p>
<p>在看到俞佑的这一瞬间，她心里忽然觉得有一阵热血上涌，就好像流浪已久的游子骤然见到亲人一样。 就连她自己都不知道她怎会有这种感觉。</p>
<p>她的血本是冷的。</p>
<p>俞佑却似乎根本没有发觉有人进来，还是低着头，点击着鼠标。</p>
<p>但他脸上的肌肉却似在逐渐僵硬。</p>
<p>婉夏忍不住轻唤了一声：“俞佑……”</p>
<p>这呼唤的声音还是那么温柔，那么甜蜜。</p>
<p>俞佑终于慢慢地抬起头，面对着她。</p>
<p>他的眼睛还是很亮，是不是因为有泪呢？</p>
<p>婉夏的眼睛似也有些湿了，柔声道：&quot;俞佑，我回来了。”</p>
<p>俞佑没有动，也没有说话。</p>
<p>他似已僵硬得不能有任何动作了 。</p>
<p>婉夏已慢慢地向他走了过来，轻轻道：“我知道你会等我的，因为我到现在才知道这世上只有你一个人是真的对我好。”</p>
<p>这种话她说过多少次了？</p>
<p>但每一次都管用，所以这次也会有用，她始终坚信着这件事。</p>
<p>“别的人都只不过是利用我……我利用他们，他们利用我！这本没有什么吃亏的，只有你，无论我怎么样对你，你对我总是真心真意。”</p>
<p>她没有注意俞佑脸上表情的变化。</p>
<p>因为她距离俞佑已越来越近了，已近得看不清许多她应该看到的事。</p>
<p>“我决心以后绝不再去穿兔女郎衣服了，绝不会再让你伤心了，无论你要怎么样，我都可以依着你，都可以 答应你……</p>
<p>&quot;砰！”俞佑将鼠标击向木制的桌面，声音大的吓人。 婉夏拉起他的手，放在自己胸膛上。</p>
<p>自己的胸有多勾人她是最清楚不过的，俞佑，还有那些人，都拜倒在她的石榴裙下。</p>
<p>她的声音甜得像蜜。</p>
<p>“以前我若有对不起你的地方，以后我一定会加倍补偿你，我会要你觉得无论你对我多好，都是值得的。” 她的胸膛温暖而柔软。</p>
<p>无论任何人的手若放在她胸膛上，绝对再也舍不得移开。</p>
<p>俞佑的手忽然自她胸膛上移开了</p>
<p>婉夏瞟了一眼电脑，那是背包，里面空荡荡的，什么都不剩下了。</p>
<p>婉夏眼睛里忽然露出丝恐惧之色道：&quot;你……你难道……</p>
<p>难道不要我了？ ”</p>
<p>俞佑静静地瞧着她，就好像第一次看到她这个人似 的。</p>
<p>婉夏道：“我对你说的全都是真话，以前我虽然也和别 的男人有……有过，但我对他们那全都是假的……“她声音忽然停顿，因为她忽然看到了俞佑脸上的表情。</p>
<p>俞佑的表情就像是想呕吐。</p>
<p>婉夏不由自主后退了两步，道：“你……你难道不愿听真话？你难道喜欢我骗你？ ”</p>
<p>俞佑盯着她，良久良久，忽然道：“我只奇怪一件</p>
<p>事</p>
<p>婉夏道：“你奇怪什么？&quot;</p>
<p>俞佑慢慢地站了起来，一字字道：“我只奇怪，我以前怎么会爱上你这种女人的！”</p>
<p>婉夏忽然觉得全身都凉了。</p>
<p>俞佑没有再说别的。</p>
<p>他用不着再说别的，这一句话就已足够。</p>
<p>这一句话就已足够将婉夏推入万劫不复的深渊。</p>
<p>俞佑慢慢地走了出去。</p>
<p>一个人若已受过无数次打击和侮辱，绝不会不变的。</p>
<p>一个人可以忍受谎言，却绝不能忍受那种最不能忍受 的侮辱–女人如此，男人也一样。</p>
<p>做妻子的如此，做丈夫的也一样。</p>
<p>婉夏只觉自己的心在往下沉，往下沉……</p>
<p>俞佑已拉开了门。</p>
<p>婉夏忽然转身扑过去，扑倒在他脚下，拉住他的衣服，嘶声道：“你怎么能就这样离开我……我现在已只 有你……“</p>
<p>他只是慢慢地将衣服脱了下来。</p>
<p>他赤着上身走了出去，走入雨中。</p>
<p>他走了出去，走入雨中。</p>
<p>雨很冷。</p>
<p>可是雨很干净。</p>
<p>他终于甩脱了婉夏，甩脱了他心灵上的枷锁，就好像甩脱了那件早已陈旧破烂的衣服，婉夏却还在紧紧抓着那件白色衣服，因为她知道除了这件衣服外，就再也抓不住别的。</p>
<p>“到头来你总会发现你原来什么也没有得到，什么都是空的……”</p>
<p>婉夏泪已流下。</p>
<p>到这时她才发现她原来的确是一直爱着俞佑的。</p>
<p>她折磨他，也许就因为她爱他，也知道他爱她。</p>
<p>”女人为什么总喜欢折磨最爱她的男人呢？&quot;</p>
<p>到现在，她才知道俞佑对她是多么重要。</p>
<p>因为她已失去了他。</p>
<p>“女人为什么总是对得到的东西加以轻蔑，为什么总要等到失去时才知道珍惜。”</p>
<p>也许不只女人如此，男人也是一样的。</p>
<p>婉夏突然狂笑起来，狂笑着将俞佑的衣服一片片撕碎。</p>
<p>“我怕什么，我这么漂亮，又这么年轻-一只要我喜欢，要多少男人就有多少男人，我每天换十个都没有关系。</p>
<p>她在笑，可是这笑却比哭更悲惨。</p>
<p>因为她也知道男人虽容易得到，但&quot;真情&quot;却绝不是青春和美貌可以买得到的……</p>
<p>雨很冷。</p>
<p>冷雨洒在俞佑胸膛上，他觉得舒服得很，因为这雨令 他觉得自己并不是麻木的，十天来，这也许是他第一次有这种感觉。</p>
<p>而且他觉得很轻松，就像是刚卸下了一个沉重的包袱。</p>
<p>远处有人在呼唤：“你好……”</p>
<p>呼声很轻，若在几天前，他也许根本听不见。</p>
<p>但现在，他的眼睛已不再瞎，耳朵也不再聋了。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>记录</category>
      </categories>
      <tags>
        <tag>时间的恋人</tag>
      </tags>
  </entry>
  <entry>
    <title>用logisim实现八位可控加减法器</title>
    <url>/2021/12/03/%E7%AC%AC%E4%BA%8C/</url>
    <content><![CDATA[<h1>计算机组成原理实验</h1>
<p>你好，好久不见！吼吼吼吼吼吼吼吼吼吼吼吼吼吼吼，作为第二篇博客，我决定先从一些简单的实验分享开始啦！（实际因为本人是小菜鸡一只的原因。。）</p>
<h2 id="用logisim实现八位可控加减法器">用logisim实现八位可控加减法器</h2>
<h3 id="思路解析：">思路解析：</h3>
<p>要实现八位可控加减法器，采用并行思路，首先需要八个一位全加器，用分流器可以将八位二进制数分离，使得单独每一位用一位全加器来进行相关的运算，然后并行输出，最后用分流器进行还原。</p>
<h3 id="实验过程：">实验过程：</h3>
<p>1、首先进行一位全加器的设置，我们需要准备五个信号量，三个输入，两个输出，其中xi与yi为参加运算的对象，cin代表来自下一位的进位，si代表本位的输出结果，Cout代表向下一位的进位。</p>
<p><img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/%E5%9B%BE%E7%89%871.png" alt="11"></p>
<p>2、设计思路为：先用一个异或门判断xi与yi的和的情况，若异或门为1，则xi+yi==1，此时与cin进位再次进行异或门判断，若异或门为仍1，则说明不产生进位，则si可置1。若第一个异或门与cin的与门为1，则说明产生了进位并且si位为0.当xi与yi的与门为1时，cin也应该置1。经过调试判断，最终如图所示。</p>
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片2.png" style="zoom:50%;">
<p>3、用logisim进行测试，检验是否制作成果，经检验得制作成功。</p>
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片3.png" style="zoom:33%;">
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片4.png" style="zoom:50%;">
<p>4、制作分流器，准备分流器，数据位宽为8的输入，8个数据位宽为1的隧道，将隧道与分流器相连，分流器与8位位宽的输入相连。</p>
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片6.png" style="zoom:50%;">
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片7.png" style="zoom:50%;">
<p>5、同理，准备一个y输入与s输出。</p>
<p><img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/%E5%9B%BE%E7%89%878.png" alt></p>
<p><img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/%E5%9B%BE%E7%89%879.png" alt></p>
<p>6、准备8个一位全加器，一个用于表示加减的输入sub，一个用于检测溢出的of（overflow），一个cout表示最高位的进位。<br>
其基本思路是：利用sub与y输入形成异或门，用于执行加和减时y的不同形态，将异或门的结果与一起并入全加器的两个加位，输出位依次接上s的8个隧道。将8个全加器按照这样的方式链接，最后将一位全加器用进位位连接起来，sub链接至第一个全加器的进位位，这样做的目的是将原本的（x+y）变成（x+y的补码）即为（x+（1+y的反码））。结果连接如下。</p>
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片10.png" style="zoom:80%;">
]]></content>
      <categories>
        <category>学习</category>
        <category>硬件设计</category>
      </categories>
      <tags>
        <tag>logisim</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用类</title>
    <url>/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/</url>
    <content><![CDATA[<h1>object类</h1>
<p>java语言所有类的根类，object也就是所有类的父类（也就意味着所有类都可以使用object类的方法），位于lang包中，所以不需要导包便可使用。</p>
<h2 id="getclass">getclass</h2>
<p>getclass()方法是返回应引用中存储的实际对象类型（返回值为class类型）</p>
<p>多用于判断两个对象是否是同一个类。</p>
<h2 id="hashCode">hashCode</h2>
<p>hashCode()方法返回的是一个int类型，是根据对象的地址或字符串或数字使用hash算法计算出的数值。</p>
<h2 id="tostring">tostring</h2>
<p>String tostring()   返回该对象的字符串表示。</p>
<p>类如我们创建一个person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用text测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        person p1 = <span class="keyword">new</span> person(<span class="string">&quot;瑾介&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        String s=p1.toString();</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211124624726.png" alt="image-20211211124624726"></p>
<p>我们发现，直接打印对象的名字，其实就是调用了tostring方法。打印的都是堆内存中的十六进制地址值。</p>
<p>如果想直接打印对象的属性的话，我们可以重写tostring方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;person&#123;name=&quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;,age=&quot;</span>+<span class="keyword">this</span>.age+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在再来打印的话：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211125454617.png" alt="image-20211211125454617"></p>
<p>这样就实现了我们自定义的tostring输出了。</p>
<h2 id="equals">equals</h2>
<p>指示其他的某个对象是否与此对象”相等“。</p>
<p>如果没有重写equals方法，那么它将会直接比较两个对象的地址值，我们依然用之前的person对象来做测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        person p1 = <span class="keyword">new</span> person(<span class="string">&quot;瑾介&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        person p2 = <span class="keyword">new</span> person(<span class="string">&quot;瑾介&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(p1.equals(p2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211130438858.png" alt="image-20211211130438858"></p>
<p>比较两个两个对象的地址值几乎没有什么意义，那我们还是来重写一下equals海曙吧。</p>
<p><em><strong>不过这里需要注意的是，这里隐含了一个多态的问题，即我们引入的参数obj是object类的，他无法访问到我们person类的name、age等参数，所以我们需要进行一个向下转型，也就是强制转换：</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">   person person = (person)obj;<span class="comment">//进行强制转换成我们的person类。</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.age==person.age&amp;&amp;<span class="keyword">this</span>.name==person.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211143201551.png" alt="image-20211211143201551"></p>
<p>当然为了防止类型转换异常，我们一般得写一个if条件来判断我们的参数是否是person的父类，完整的重写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> person) &#123;</span><br><span class="line">        person person = (person) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age == person.age &amp;&amp; <span class="keyword">this</span>.name == person.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//不是person类型直接false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="finalize">finalize</h2>
<p>当对象被判定为垃圾对象是，由jvm自动调用此方法，用于标记垃圾对象，进入回收队列。因为Java由自动回收垃圾机制，故平时一般不太会使用。</p>
<h1>String类</h1>
<h2 id="字符串池">字符串池</h2>
<p>字符串是常量，创建后不可以改变，字符串字面值存储在字符串池中，可以共享。</p>
<p>字符串池是位于堆的一个区，为了便于共享而创建的，当创建字符串的时候会先到字符串池里寻找，比如说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name=<span class="string">&quot;jinjie&quot;</span>;<span class="comment">//&quot;jinjie&quot;常量存储在字符串池中</span></span><br><span class="line">        name=<span class="string">&quot;jingjie&quot;</span>;<span class="comment">//新的字符串“jingjie”被创建赋值给了name（“jinjie”就成了废弃物。）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在多加两行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name=<span class="string">&quot;jinjie&quot;</span>;<span class="comment">//&quot;jinjie&quot;常量存储在字符串池中</span></span><br><span class="line">        name=<span class="string">&quot;jingjie&quot;</span>;<span class="comment">//新的字符串“jingjie”被创建赋值给了name（“jinjie”就成了废弃物。）</span></span><br><span class="line">         String name2=<span class="string">&quot;jingjie&quot;</span>;</span><br><span class="line">        System.out.println(name2==name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据共享的原则，这时候创建的name2先到字符串池中寻找有没有“jingjie”，在发现有之后，就把字符串池中“jingjie”的地址也赋值给了name2，所以name2和name的地址是相等的，所以结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211214144031671.png" alt="image-20211214144031671"></p>
<p>另外，我们有两种方式来定义字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name=<span class="string">&quot;jinjie&quot;</span>;</span><br><span class="line">String name=<span class="keyword">new</span> String(<span class="string">&quot;jinjie&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上面一种是我们常用的方法，它只创建了一个对象，但是下面一种方法我们却创造了两个对象，在堆里有一个对象，在字符串池里也有一个对象，但是真正的运行的时候只有一个对象，即堆里的对象也指向字符串池里的对象（所以比较浪费空间。</p>
<p>所以字符串比较要用equals进行比较（String重写了equals方法）。</p>
<h2 id="String的常用方法">String的常用方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;<span class="comment">//返回字符串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//根据下标获取字符。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String str)</span></span>;<span class="comment">//判断当前字符串是否含有str。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray();<span class="comment">//将字符串转化成数组。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span>;<span class="comment">//返回str首次出现的下标，若不存在则返回-1.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> interestinglast <span class="title">IndexOf</span><span class="params">(String str)</span>:<span class="comment">//查找字符串在当前字符串中最后一次出现的下标。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span></span>;<span class="comment">//去掉字符串的前后空格。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">()</span></span>;<span class="comment">//将小写转换成大写。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endWith</span><span class="params">(String str)</span></span>;<span class="comment">//判断字符串是否即以str结尾。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldchar,<span class="keyword">char</span> newChar)</span></span>;<span class="comment">//替换字符。</span></span><br><span class="line"><span class="keyword">public</span> String[] split(String str);<span class="comment">//根据str做拆分。</span></span><br></pre></td></tr></table></figure>
<h2 id="可变字符串">可变字符串</h2>
<p>StringBuilder:可变长字符串，效率快，线程不安全。</p>
<p>StringBuffer:可变长字符串，效率慢，线程安全。</p>
<blockquote>
<p>现在一般使用StringBuilder.</p>
</blockquote>
<p>我们来看个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   StringBuffer n = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">   n.append(<span class="string">&quot;我叫京介！&quot;</span>);<span class="comment">//1.在最后面添加字符。</span></span><br><span class="line">   n.append(<span class="string">&quot;请多指教！&quot;</span>);</span><br><span class="line">   System.out.println(n.toString());</span><br><span class="line">   System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line">   n.insert(<span class="number">0</span>,<span class="string">&quot;你好！&quot;</span>);<span class="comment">//2.在指定位置添加内容。</span></span><br><span class="line">        System.out.println(n.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line">n.replace(<span class="number">0</span>,<span class="number">2</span>,<span class="string">&quot;欢迎！&quot;</span>);<span class="comment">//替换字符串。</span></span><br><span class="line">System.out.println(n.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211215192541609.png" alt="image-20211215192541609"></p>
<h1>BigDecimal类</h1>
<p>float与double类型储存的数据都是近似值（比如1.0就是0.999999……），原因是因为它们采取的是二进制存储。需要精度存储时要使用BigDecimal类来精确计算浮点数。</p>
<p>我们举例来说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> a1=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> a2=<span class="number">0.9</span>;</span><br><span class="line">        System.out.println(a1-a2);</span><br><span class="line">        <span class="comment">//储存近似值。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        BigDecimal b1=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">        BigDecimal b2=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">        BigDecimal r=b1.subtract(b2);<span class="comment">//减法</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        BigDecimal r1=b1.add(b2);<span class="comment">//加法</span></span><br><span class="line">        System.out.println(r1);</span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        BigDecimal r2=b1.multiply(b2);<span class="comment">//乘法</span></span><br><span class="line">        System.out.println(r2);</span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        BigDecimal r3=b1.divide(b2,<span class="number">2</span>,BigDecimal.ROUND_HALF_UP);<span class="comment">//除法</span></span><br><span class="line">        System.out.println(r3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用BigDecimal进行运算时是调用BigDecimal的方法，值得注意的是，在使用BigDecimal的除法方法的时候，如果出现除不尽的现象的话，程序将会报错，所以这时3要使用到divide除法方法的重载方法，在参数的后面添加保留的小数位数以及保留的方法</p>
<blockquote>
<p>保留方法的参数是Bigdecimal的几个常量，BigDecimal.ROUND_HALF_UP的意义即为四舍五入。</p>
</blockquote>
<p>结果是：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211215195425390.png" alt="image-20211215195425390"></p>
<h1>System类</h1>
<p>系统类是静态的，直接使用就可以，下面我列举几个方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static void arraycopy(……)</td>
<td>复制数组</td>
</tr>
<tr>
<td>static void currentTimeMillis();</td>
<td>获取系统当前时间（返回毫秒值）</td>
</tr>
<tr>
<td>static void gc();</td>
<td>建议JVM回收垃圾</td>
</tr>
<tr>
<td>static void exit(int status);</td>
<td>退出JVM</td>
</tr>
</tbody>
</table>
<h1>++包装类</h1>
<p>对于基本数据类型所拓展的包装类型，这样基本数据类型就可以实现更多的方法和功能。</p>
<blockquote>
<p>实际上，更深层的原因是Java不在支持指针操作，因此创造出了内部类的功能使得数据能在堆和栈之间进行转换。</p>
</blockquote>
<p>其包装类对应如下：</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody>
</table>
<p>每一种包装类型都由更多的方法与属性。</p>
<h2 id="装箱、拆箱">装箱、拆箱</h2>
<p>装箱：把栈里面的东西装到堆里面去（基本类型转换为引用类型）。</p>
<p><em>一般通过引用类型的构造方法实现，比如：</em><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212144744804.png" alt="image-20211212144744804"></p>
<p>拆箱：把堆里面的东西装到栈里面去（引用类型转换为基本类型）。</p>
<p><em>一般通过number类（包装类型的父类）的方法进行拆箱</em>*，比如：*</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212172036602.png" alt="image-20211212172036602"></p>
<blockquote>
<p>JDK1.5之后，java开始提供自动装箱和拆箱……意思是直接用赋值符号就行了。但其背后的实质是一样的，只是Java在背后帮我们自动操作了。</p>
</blockquote>
<h2 id="类型转换">类型转换</h2>
<h3 id="1、基本类型与字符串类型转换">1、基本类型与字符串类型转换</h3>
<h4 id="1-1使用-号">1.1使用+号</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ni=<span class="number">10</span>;</span><br><span class="line">String s1=n1+<span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="1-2使用tostring方法">1.2使用tostring方法</h4>
<p>使用Integer中的tostring()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s2=Integer.toString(ni);</span><br><span class="line">String s2=Integer.toString(ni，<span class="number">16</span>);<span class="comment">//此方法可以重载，按十六进制进行转换。 </span></span><br></pre></td></tr></table></figure>
<h3 id="2、字符串类型与基本类型转换">2、字符串类型与基本类型转换</h3>
<h4 id="2-1使用Integer的parse方法">2.1使用Integer的parse方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">&quot;150&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> n=Integer.parse(str);<span class="comment">//str里只能有数字。</span></span><br></pre></td></tr></table></figure>
<h3 id="3、Boolean字符串转换为基本类型">3、Boolean字符串转换为基本类型</h3>
<p>依旧使用parse进行格式化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str2=<span class="string">&quot;true&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> b1=Boolean.parseBoolean(str2);<span class="comment">//只用true能被格式化为true,其它字符均为false。</span></span><br></pre></td></tr></table></figure>
<h2 id="整数缓冲区">整数缓冲区</h2>
<p>Java预先创建了256的常用的整数包装对象，在实际的应用当中，对已经创建的对象进行复用。</p>
<p>我们来举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer integer1 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">        Integer integer2 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">        System.out.println(integer1==integer2);</span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        Integer integer3=<span class="number">100</span>;<span class="comment">//自动装箱</span></span><br><span class="line">        Integer integer4=<span class="number">100</span>;</span><br><span class="line">        System.out.println(integer4==integer3);</span><br><span class="line">      	Integer integer5=<span class="number">200</span>;</span><br><span class="line">        Integer integer6=<span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>猜猜看会输出什么？</p>
<p>表面上都是生成代表int值100的Integer类型，但结果是：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212180010477.png" alt="image-20211212180010477"></p>
<p>为什么会出现这种情况呢？这是因为integer1与integer2是new出来的，属于不同的地址，“==”比较的是地址值，第一个当然不同。</p>
<p>第二个为自动装箱，调用的都是Integer的valueof方法。那我们来看一下valueof方法：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212180440932.png" alt="image-20211212180440932"></p>
<p>是不是发现只要参数是在一定范围里的int，那么就返回了一个cache数组里的元素？</p>
<p>我们再来具体的看一看具体的数和cache数组：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212180855001.png" alt="静态中间那坨可以忽略"></p>
<p><em>静态中间那坨可以忽略，为的是最后的high=h</em></p>
<p>这，就是我们的整数缓冲区，一个名为cache的数组，最高high为127，low为-128，所以我们的integer3与integer4是同一个，已经被实例好的对象，所以就是相等的咯。</p>
<p>当然，相信大家都发现了，integer5与integer6的int数字是大于了127的，所以执行相应语句，也就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br></pre></td></tr></table></figure>
<p>那这自然就跟1、2的结果是一样的了。</p>
<h1>日期时间类</h1>
<h2 id="Date类">Date类</h2>
<p>类Date表示特定的瞬间，精确到毫秒。</p>
<blockquote>
<p>毫秒，即为千分之一秒。</p>
</blockquote>
<p>毫秒值一般用于计算日期的间隔，即将日期都转换成毫秒值进行加减，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.currentTimeMillis()<span class="comment">//可以输出当前系统时间距离时间原点1970年1月1日凌晨经历了多少毫秒</span></span><br></pre></td></tr></table></figure>
<h3 id="无参构造">无参构造</h3>
<p>直接实例化一个无参构造的Date类，打印出来将是我们系统的标准时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">date</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">			text();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">text</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211150504218.png" alt="image-20211211150504218"></p>
<p>这里的CST指的是中国标准时间。</p>
<h3 id="带参的构造方法">带参的构造方法</h3>
<p>Date类还可以使用带参的构造方法，此时参数为从时间原点开始的毫秒值，列如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date(<span class="number">0</span>);<span class="comment">//将上面的代码块的构造方法添加为0的参数。</span></span><br></pre></td></tr></table></figure>
<p>此时它就会打印：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211151139834.png" alt="image-20211211151139834"></p>
<p>即为打印时间原点。</p>
<h3 id="gettime-方法">gettime()方法</h3>
<p>将日期转换成毫秒值，返回的是一个long类型的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">      <span class="keyword">long</span> s=date.getTime();</span><br><span class="line">      System.out.println(s);</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211151520479.png" alt="image-20211211151520479"></p>
<h2 id="DateFormat类">DateFormat类</h2>
<p>是对时间与日期进行一个格式化的抽象类，属于Java.text包中，有两个作用：</p>
<p>格式化：从日期转到文本[String format(Date date)]</p>
<p>解析：从文本转到日期[Date parse(String source)]</p>
<p>由于DateFormat是一个抽象类，所以我们要用到他的子类SimpleDateFormat进行对日期格式的约束。</p>
<blockquote>
<p><code>SimpleDateFormat</code> 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt;  文本）、解析（文本 -&gt; 日期）和规范化。</p>
</blockquote>
<h3 id="格式化">格式化</h3>
<p>要相对时间进行一个格式化的输出，需要用到SimpleDateFormat里的format方法，那我们首先的得创建一个**”模式“**，通过这个模式来告诉我们的类应该怎样输出时间，在SimpleDateFormat类中，模式通过字母来代表创建，下面我们列举一些常用的代表：</p>
<table>
<thead>
<tr>
<th>字母代表</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody>
</table>
<p>所以我们可以写出类似于： <strong>”yyyy-MM-dd  HH:mm:ss“</strong>   这样的时间格式。</p>
<p>来创建一个SimpleDateFormat类试试吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">demo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SimpleDateFormat t1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日HH:mm:ss&quot;</span>);<span class="comment">//模式作为参数传入SimpleDateFormat类。</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();<span class="comment">//创建一个时期类</span></span><br><span class="line">        String time;</span><br><span class="line">        time=t1.format(date);<span class="comment">//用方法来格式化我们的日期类.</span></span><br><span class="line">        System.out.println(time);</span><br><span class="line">        System.out.println(date);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211155207944.png" alt="image-20211211155207944"></p>
<h3 id="解析">解析</h3>
<p>使用SimpleDateFormat里的parse方法，可以将一段字符串日期转换为Date类日期。</p>
<p>这里值得注意的是，如果字符串日期的模式与设定的模式不相符合的话，parse方法会抛出一个异常，这时我们要么使用throw继续向上抛出异常，要么使用try  catch自己进行处理。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">demo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SimpleDateFormat t1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日HH:mm:ss&quot;</span>);<span class="comment">//模式作为参数传入。</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        String time;</span><br><span class="line">        time=t1.format(date);</span><br><span class="line">        Date d1 = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//使用try catch来监控</span></span><br><span class="line">            d1=t1.parse(time);</span><br><span class="line">            System.out.println(d1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">           System.out.println(<span class="string">&quot;格式出错&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211163615731.png" alt="image-20211211163615731"></p>
<p>如果我们使用不一样的时间的话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat t2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年dd日MM月HH:mm:ss&quot;</span>);<span class="comment">//模式作为参数传入。</span></span><br><span class="line">d1=t2.parse(time);<span class="comment">//修改要捕获异常的语句</span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211164157365.png" alt="image-20211211164157365"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>零日之恋人</title>
    <url>/2021/12/19/%E9%9B%B6%E6%97%A5%E4%B9%8B%E6%81%8B%E4%BA%BA/</url>
    <content><![CDATA[<p>瑾介不知道葭玟是什么时候计划好的。</p>
<p>他依然活在过去，像个永远长不大的孩子，对爱恨没有那么深刻的认识。</p>
<p>“就算与亥氧分手分手以后……”</p>
<p>葭玟在网络上对着瑾介说。</p>
<p>瑾介不敢想象葭玟是怀着什么样的心情说下去的，他只知道自己的大脑一片空白，有许多的回忆喷涌而出，瑾介闭着眼拼命地想束缚住它们。</p>
<p>“我可能都……”</p>
<p>喷涌到达了极点，瑾介想起他在修脚店切除嵌甲时把甲根连根拔起的最后一刻，旁人都焦急地注视着状况，修脚师傅一头大汗，瑾介痛得呲牙咧嘴也感觉武士拔刀的最后时机已经到来。</p>
<p>“不会吃回头草。”</p>
<p>断了，不过，是嵌甲永远地断在里面了。准备折磨瑾介一辈子。</p>
<p>记忆安分了下来，静静地盘旋在他们主人的周围，希望能够给瑾介些许安慰。</p>
<p>瑾介开始想。</p>
<p>他拼命地想，他撕扯着周围的回忆，想要找到答案。</p>
<p>这些天是为了什么？</p>
<p>为了报复？为了利益？还是说，为了结束？</p>
<p>瑾介又开始怀疑起了自己，又是一次错过或是自作多情？自我意识过剩？还有值得分析下去的必要吗？</p>
<p>这些天的快乐是毋庸置疑的，即使是瑾介自己也无法否认，瑾介感觉自己获得了新生，更像高中那个时候的自己了。</p>
<p>但是瑾介看到的葭玟也是一样的，确实是高中时期的她。</p>
<p>是后来的所有还没发生的她。</p>
<p>瑾介又尝到的那种类似与考试快要结束试卷还没翻页的惊慌无措之感。</p>
<p>时间已经过去了五分钟，瑾介知道必须要说点什么。</p>
<p>他选择了半天，还是选择自己性格导致的必然结果。</p>
<p>“我还是会一直支持你的。”</p>
<p>瑾介本以为自己永远不会再说出这句话，瑾介这是第一次尝试对她给与自己最大的陪伴和交流，瑾介看着葭玟不断的笑容感到满意。</p>
<p>“快去睡觉吧，笨蛋”</p>
<p>瑾介毫无反应，甚至开始感受到丝丝尴尬。</p>
<p>他敢再想吗？他不能再想了，错的，全是错的，谁才是真正的小丑，瑾介想到了什么。总之，不能再想了。</p>
<p>他睁开了眼，看到了自己最不愿意看到的画面。</p>
<p>葭玟在漆黑的屋子里，躺在床上，抱着枕头上，无声地抽泣着。</p>
<p>瑾介看着这幅画面，身体一时动弹不得，他自己也不知道自己在等待着什么。</p>
<p>葭玟坐了起来，背对着瑾介，看起来是那样孤独弱小，然后她的手伸向了手机。</p>
<p>这时瑾介像是被诅咒一般发疯地把这副画面撕得粉碎，直到最后一片碎片落向地面消失不见。然后呆呆地坐在地上，掩面流泪。</p>
<p>旁边的手机显示送达了最新的消息。</p>
<p>“所以……”</p>
<p>“哥哥？”</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>记录</category>
      </categories>
      <tags>
        <tag>时间的恋人</tag>
      </tags>
  </entry>
</search>

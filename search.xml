<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>用logisim实现4位先行进位</title>
    <url>/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/</url>
    <content><![CDATA[<h3 id="实验目的：">实验目的：</h3>
<p>掌握快速加法器中先行进位的原理，能利用相关知识设计4位先行进位电路，并利用设计的4位先行进位电路构造4位快速加法器，能分析对应电路的时间延迟。</p>
<h3 id="实验结果：">实验结果：</h3>
<img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/图片9.png" style="zoom:80%;">
<h3 id="实验过程及结果分析：">实验过程及结果分析：</h3>
<p>由于串行加法器在每一位的加法时需要等待下一位的进位后才能进行加减，这就导致了时间的大量浪费，如果我们能够提前知道进位（先行进位）的话，这样的话后位的加减不用等着前位的进位，时间将会大大缩短。</p>
<p>所以，有规定为：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/%E5%9B%BE%E7%89%876.png" alt></p>
<p>所以，一位加法的所有进位形态分为进位取消、进位传播、进位产生，在这里我们只关心进位传播与进位产生，列出全加器的运算公式：</p>
<p>$$<br>
Si=ai⊕bi⊕ci;<br>
Ci+1=ai*bi+（ai⊕bi）*ci<br>
$$</p>
<p>这是每一位的结果，根据我们刚才的分类pi（进位传播项）=ai⊕bi、gi（进位产生项）=ai*bi我们可以得到全加器的公式变形：</p>
<p>$$<br>
Si=pi⊕ci;<br>
Ci+1=gi+pi*ci<br>
$$</p>
<p>这就是我们每一位求出来的值，pi、gi都只与ai与bi有关，故我们只需要求出ci即可，但是ci又与上一位ci有关系，我们将所有ci的运算公式列出：</p>
<img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/图片7.png" style="zoom:80%;">
<p>而我们将ci依次带入后一位得：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/%E5%9B%BE%E7%89%878.png" alt></p>
<p>所以现在所有值都只与ai、bi、c0有关了，我们就可以通过ai、bi和c0直接算出每一位的值而不再需要等待进位了。</p>
<p>将p1，g1，c0表示出来:</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/%E5%9B%BE%E7%89%8710.png" alt></p>
<p>用电路表示超前进位即为：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/%E5%9B%BE%E7%89%879.png" alt></p>
<blockquote>
<p>有问题请通过旁边的对话窗口联系京介喔。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
        <category>硬件设计</category>
      </categories>
      <tags>
        <tag>logisim</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS入门小识</title>
    <url>/2022/01/18/CSS%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/</url>
    <content><![CDATA[<blockquote>
<p>更新时间：2022.1.27，css内容的学习需要富有艺术性。。缓慢更新中。。</p>
</blockquote>
<h1>2、选择器</h1>
<h2 id="1、标签选择器">1、标签选择器</h2>
<h2 id="2、类选择器">2、类选择器</h2>
<h2 id="3、id选择器">3、id选择器</h2>
<h1>3、层次选择器</h1>
<h2 id="3-1后代选择器">3.1后代选择器</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">body p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-子选择器">3.2 子选择器</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">body&gt;p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3相邻兄弟选择器">3.3相邻兄弟选择器</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.class + p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4通用兄弟选择器-向下">3.4通用兄弟选择器(向下)</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.class + p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>字体样式</h1>
<h1>文本样式</h1>
<h2 id="1、颜色">1、颜色</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">color：</span><br></pre></td></tr></table></figure>
<h2 id="2、文本对齐的方式">2、文本对齐的方式</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text-align:</span><br></pre></td></tr></table></figure>
<h2 id="3、首行缩进">3、首行缩进</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text-indent:2em(em为一个字)</span><br></pre></td></tr></table></figure>
<h2 id="4、行高">4、行高</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">line-height:(设为容器一样的高度)</span><br></pre></td></tr></table></figure>
<h2 id="5、装饰">5、装饰</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">text-decoration:underline/line-through/overline(上划线、中、下)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">img,span&#123;</span><br><span class="line">vertical-align:middle(img/span居中对齐两个标签)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>超链接去下划线。</p>
<h1>超链接伪类</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.hover&#123;</span><br><span class="line"></span><br><span class="line">&#125;鼠标悬浮效果</span><br><span class="line">a.active&#123;</span><br><span class="line">激活，点击未放开</span><br><span class="line">&#125;</span><br><span class="line">cursor: url(&#x27;img/hammer.ico&#x27;),auto;</span><br><span class="line">鼠标效果</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text-shadow: 阴影颜色 偏移 偏移 模糊</span><br></pre></td></tr></table></figure>
<h1>列表样式</h1>
<p>list-style:<br>
none去掉原点<br>
circle空心圆<br>
decimal数字<br>
square正方形</p>
<h1>边框</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">border: 1px solid red</span><br></pre></td></tr></table></figure>
<h1>背景图片</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">background-repeat：repeat-x/repeat-y/no repeat</span><br><span class="line">背景重复方式</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/18/CSS%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/image-20220119111404781.png" alt="image-20220119111404781"></p>
<h1>渐变</h1>
<p><img src="/2022/01/18/CSS%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/image-20220119112059881.png" alt="image-20220119112059881"></p>
<h1>盒子模型</h1>
<h2 id="什么是盒子模型">什么是盒子模型</h2>
<p><img src="/2022/01/18/CSS%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/image-20220119112515546.png" alt="image-20220119112515546"></p>
<h2 id="边框">边框</h2>
<p>margin+border+padding</p>
<h1>浮动</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h1~h6 p div  列表</span><br></pre></td></tr></table></figure>
<p>行内元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">span img strong。。</span><br></pre></td></tr></table></figure>
<h2 id="display">display</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display:block(行内变块内)</span><br><span class="line">display:inline-block(行内变块内)是块且可以内联</span><br><span class="line">inline（行内）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端入门</tag>
      </tags>
  </entry>
  <entry>
    <title>4位快速加法器的设计</title>
    <url>/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="4位快速加法器的设计">4位快速加法器的设计</h2>
<h3 id="实验目的：">实验目的：</h3>
<p>掌握快速加法器中先行进位的原理，能利用相关知识设计4位先行进位电路，并利用设计的4位先行进位电路构造4位快速加法器，能分析对应电路的时间延迟。</p>
<h3 id="实验结果：">实验结果：</h3>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8711.png" alt></p>
<h3 id="实验结果分析：">实验结果分析：</h3>
<p>因为我们已经完成了的4位先行进位，（什么？你没什么印象？<a href="https://tosuke.gitee.io/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/">点我马上传送</a>现在我们可以来来实现4位快速加法器，没错，其实4位快速加法器就是根据我们第三个实验的原理而来，实验三所写的4位先行进位现在在4位快速加法器里是重要的中心电路。</p>
<p>第一步先准备一下我们需要的输入输出：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8712.png" alt></p>
<p>然后对应好我们之前的4位先行进位的电路封装：</p>
<img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/图片13.png" style="zoom:80%;">
<img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/图片14.png" style="zoom:80%;">
<p>确认好我们的电路封装后，那我们先来输入我们的P1、P2等Pi输入，因为</p>
<pre><code>                          **Pi=ai⊕bi  Gi=ai*bi**
</code></pre>
<p>所以我们将xi、yi连上异或门连上电路封装的pi输入，将xi、yi连上与门连上电路封装的gi输入，最后不要忘了连上C0的输入：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8715.png" alt></p>
<p>那我们输入就算完成了，现在来看看电路封装的输出部分，我们电路的电路的输出分别是Ci和p*、g*成组先进函数，又因为我们推出的运算公式中：</p>
<p>​														Si=Pi⊕Ci</p>
<p>所以我们需要将封装电路输出的Ci与Pi连上异或门再输出给Si，由于在上一步已经制造了Pi，所以连接如图：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8716.png" alt></p>
<p>最后连接上代表最高位进位的C4与p*、g*成组先进函数，电路图就链接好了。</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8717.png" alt></p>
<blockquote>
<p>有问题请通过旁边的对话窗口联系京介喔。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
        <category>硬件设计</category>
      </categories>
      <tags>
        <tag>logisim</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6,Javascript下一代版本答案(二)</title>
    <url>/2022/02/09/ES6-Javascript%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%89%88%E6%9C%AC%E7%AD%94%E6%A1%88-%E4%BA%8C/</url>
    <content><![CDATA[<h1>Symbol</h1>
<p>一种新引入的原始数据类型，表示独一无二的值，定义对象的唯一属性名，另外，ES6所有的数据类型为Number 、 String 、 Boolean 、 Object、 null 和 undefined ，还新增了 Symbol。</p>
<h2 id="用法">用法</h2>
<p>定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy=<span class="built_in">Symbol</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"><span class="comment">//其中的xxx为描述symbol的内容，便于区分不同的symbol类型。</span></span><br></pre></td></tr></table></figure>
<p>不同的写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法1</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;&#125;;</span><br><span class="line">syObject[sy] = <span class="string">&quot;kk&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(syObject);    <span class="comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;</span><br><span class="line">  [sy]: <span class="string">&quot;kk&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(syObject);    <span class="comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法3</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(syObject, sy, &#123;<span class="attr">value</span>: <span class="string">&quot;kk&quot;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(syObject);   <span class="comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="特点">特点</h2>
<p>使用 Symbol 定义常量，这样就可以保证一组常量的值都不相等。避免引发选择错误。</p>
<h2 id="方法">方法</h2>
<h3 id="Symbol-for">Symbol.for()</h3>
<p>会全局搜索是否有含有参数值的symbol类型数据，如果没有将会创造一个新的symbol并登记供搜索（以普通的方法构造的symbol不会被搜索到）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yellow = <span class="built_in">Symbol</span>(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> yellow1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">yellow === yellow1;      <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> yellow2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">yellow1 === yellow2;     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="Symbol-keyFor">Symbol.keyFor()</h3>
<p>直接返回一个Symbol的key值，参数为symbol类型的名称。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yellow1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(yellow1);    <span class="comment">// &quot;Yellow&quot;</span></span><br></pre></td></tr></table></figure>
<h1>Map 与 Set</h1>
<p>Map对象保存键值对，任何对象或是原始值都可以作为一个键或者一个值。可以说，Map比object做的更加彻底，从另一方面来说也印证了随着时代的发展，编程的语法将会不再那么严格，会变得越来越简单，学编程的成本也会大幅下降。</p>
<h2 id="Maps-和-Objects-的区别">Maps 和 Objects 的区别</h2>
<ul>
<li>一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。</li>
<li>Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</li>
<li>Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。</li>
<li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li>
</ul>
<p><img src="/2022/02/09/ES6-Javascript%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%89%88%E6%9C%AC%E7%AD%94%E6%A1%88-%E4%BA%8C/image-20220321090356352.png" alt="图片来自菜鸟教程"></p>
<h2 id="用法-2">用法</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mymap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">var</span> key=<span class="string">&quot;key`s value&quot;</span></span><br><span class="line">mymap.set(key,<span class="string">&quot;value&quot;</span>);<span class="comment">//值不一定是字符串。</span></span><br><span class="line">mymap.get(key);<span class="comment">//mymap.get(&quot;key`s value&quot;)相同。</span></span><br></pre></td></tr></table></figure>
<p>下面来列举几个Map键值对中的key是其他类型的例子：</p>
<p><strong>key是字符串：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">var</span> keyString = <span class="string">&quot;a string&quot;</span>; </span><br><span class="line"> </span><br><span class="line">myMap.set(keyString, <span class="string">&quot;和键&#x27;a string&#x27;关联的值&quot;</span>);</span><br><span class="line"> </span><br><span class="line">myMap.get(keyString);    <span class="comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span></span><br><span class="line">myMap.get(<span class="string">&quot;a string&quot;</span>);   <span class="comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span></span><br><span class="line">                         <span class="comment">// 因为 keyString === &#x27;a string&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>key 是对象</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line"><span class="keyword">var</span> keyObj = &#123;&#125;,   </span><br><span class="line"> myMap.set(keyObj, <span class="string">&quot;和键 keyObj 关联的值&quot;</span>);  myMap.get(keyObj); <span class="comment">// &quot;和键 keyObj 关联的值&quot; myMap.get(&#123;&#125;); // undefined, 因为 keyObj !== &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>key 是函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line"><span class="keyword">var</span> keyFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,  </span><br><span class="line">    <span class="comment">//函数  myMap.set(keyFunc, &quot;和键 keyFunc 关联的值&quot;);  myMap.get(keyFunc); </span></span><br><span class="line">    <span class="comment">// &quot;和键 keyFunc 关联的值&quot; myMap.get(function() &#123;&#125;) </span></span><br><span class="line">    <span class="comment">// undefined, 因为 keyFunc !== function () &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>key 是 NaN</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line">myMap.set(<span class="literal">NaN</span>, <span class="string">&quot;not a number&quot;</span>);  </span><br><span class="line">myMap.get(<span class="literal">NaN</span>); </span><br><span class="line"><span class="comment">// &quot;not a number&quot;  var otherNaN = Number(&quot;foo&quot;); myMap.get(otherNaN); </span></span><br><span class="line"><span class="comment">// &quot;not a number&quot;</span></span><br></pre></td></tr></table></figure>
<p>虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，NaN作为Map的键来说是没有区别的。</p>
<p><strong>Map的迭代</strong></p>
<p>1、for…of</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>);</span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在for循环中使用key和value的组用of对map进行迭代。</span></span><br></pre></td></tr></table></figure>
<p>被在for中用of进行迭代的对象不只是map对象，还有myMap.entries()、myMap.keys()、myMap.values()</p>
<p>等方法。</p>
<h3 id="Map-对象的操作">Map 对象的操作</h3>
<p><strong>Map 与 Array的转换</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> kvArray = [[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象</span></span><br><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(kvArray);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组</span></span><br><span class="line"><span class="keyword">var</span> outArray = <span class="built_in">Array</span>.from(myMap);</span><br></pre></td></tr></table></figure>
<p><strong>Map 的克隆</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]]);</span><br><span class="line"><span class="keyword">var</span> myMap2 = <span class="keyword">new</span> <span class="built_in">Map</span>(myMap1);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(original === clone); </span><br><span class="line"><span class="comment">// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。</span></span><br></pre></td></tr></table></figure>
<p><strong>Map 的合并</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],]);</span><br><span class="line"><span class="keyword">var</span> second = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;uno&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;dos&#x27;</span>]]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three</span></span><br><span class="line"><span class="keyword">var</span> merged = <span class="keyword">new</span> <span class="built_in">Map</span>([...first, ...second]);</span><br></pre></td></tr></table></figure>
<h3 id="Map-的迭代">Map 的迭代</h3>
<p>对 Map 进行遍历，以下两个最高级。</p>
<h4 id="for…of">for…of</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>);</span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="forEach">forEach()</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>); </span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);  </span><br><span class="line"><span class="comment">// 将会显示两个 logs。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot; </span></span><br><span class="line">myMap.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key</span>) </span>&#123;  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value); &#125;, myMap)</span><br></pre></td></tr></table></figure>
<h3 id="Map-对象的操作-2">Map 对象的操作</h3>
<p><strong>Map 与 Array的转换</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> kvArray = [[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]];  </span><br><span class="line"><span class="comment">// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象 </span></span><br><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(kvArray);  </span><br><span class="line"><span class="comment">// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组 </span></span><br><span class="line"><span class="keyword">var</span> outArray = <span class="built_in">Array</span>.from(myMap);</span><br></pre></td></tr></table></figure>
<p><strong>Map 的克隆</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]]); </span><br><span class="line"><span class="keyword">var</span> myMap2 = <span class="keyword">new</span> <span class="built_in">Map</span>(myMap1);  </span><br><span class="line"><span class="built_in">console</span>.log(original === clone);  </span><br><span class="line"><span class="comment">// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。</span></span><br></pre></td></tr></table></figure>
<p><strong>Map 的合并</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],]); </span><br><span class="line"><span class="keyword">var</span> second = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;uno&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;dos&#x27;</span>]]); </span><br><span class="line"><span class="comment">// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three var merged = new Map([...first, ...second]);</span></span><br></pre></td></tr></table></figure>
<h2 id="Set-对象">Set 对象</h2>
<p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p>
<h3 id="Set-中的特殊值">Set 中的特殊值</h3>
<p>Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：</p>
<ul>
<li>+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；</li>
<li>undefined 与 undefined 是恒等的，所以不重复；</li>
<li>NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。</li>
</ul>
<h1>ES6 字符串</h1>
<p>ES6对于字符串本身的indexof来说增加了几个函数：</p>
<h2 id="查找字符串">查找字符串</h2>
<ul>
<li><strong>includes()</strong>：返回布尔值，判断是否找到参数字符串。</li>
<li><strong>startsWith()</strong>：返回布尔值，判断参数字符串是否在原字符串的头部。</li>
<li><strong>endsWith()</strong>：返回布尔值，判断参数字符串是否在原字符串的尾部。</li>
</ul>
<p>以上每个函数都可以接受两个参数，即需要搜索的字符串和起始位置。</p>
<h3 id="字符串重复">字符串重复</h3>
<p>repeat()：返回新的字符串，表示将字符串重复指定次数返回。</p>
<p>参数为重复的次数，如果是小数的话则按照去尾法（向下处理）处理，负数则会报错。</p>
<h3 id="字符串补全">字符串补全</h3>
<ul>
<li><strong>padStart</strong>：返回新的字符串，表示用参数字符串从头部（左侧）补全原字符串。</li>
<li><strong>padEnd</strong>：返回新的字符串，表示用参数字符串从尾部（右侧）补全原字符串。</li>
</ul>
<p>以上两个方法接受两个参数，第一个参数是指定生成的字符串的最小长度，第二个参数是用来补全的字符串。如果没有指定第二个参数，默认用空格填充。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;h&quot;</span>.padStart(<span class="number">5</span>,<span class="string">&quot;o&quot;</span>));  <span class="comment">// &quot;ooooh&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;h&quot;</span>.padEnd(<span class="number">5</span>,<span class="string">&quot;o&quot;</span>));    <span class="comment">// &quot;hoooo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;h&quot;</span>.padStart(<span class="number">5</span>));      <span class="comment">// &quot;    h&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="模板字符串">模板字符串</h3>
<p>模板字符串相当于加强版的字符串，用反引号 <strong>`</strong>,除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。一般用来向字符串中插入变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Mike&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">let</span> info = <span class="string">`My Name is <span class="subst">$&#123;name&#125;</span>,I am <span class="subst">$&#123;age+<span class="number">1</span>&#125;</span> years old next year.`</span></span><br><span class="line"><span class="built_in">console</span>.log(info);</span><br><span class="line"><span class="comment">// My Name is Mike,I am 28 years old next year.</span></span><br></pre></td></tr></table></figure>
<p>以及调用函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;have fun!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> string2= <span class="string">`Game start,<span class="subst">$&#123;f()&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string2);  <span class="comment">// Game start,have fun!</span></span><br></pre></td></tr></table></figure>
<p><strong>注意要点</strong></p>
<p>模板字符串中的换行和空格都是会被保留的，意思是模板看起来是什么样的，他就会以什么样输出。</p>
<h1>ES6数值</h1>
<p>二进制表示法新写法: 前缀 0b 或 0B 。</p>
<p>八进制表示法新写法: 前缀 0o 或 0O 。</p>
<h2 id="Number-对象新方法"><strong>Number 对象新方法</strong></h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite()<span class="comment">//检测数值是否为无限的</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt()<span class="comment">//进制转换，与全局的 parseInt() 函数是同一个函数，默认10进制。</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt(<span class="string">&#x27;0011&#x27;</span>,<span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h2 id="Math-对象的扩展">Math 对象的扩展</h2>
<p>新方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt<span class="comment">//计算一个数的立方根。</span></span><br><span class="line"><span class="built_in">Math</span>.imul<span class="comment">//返回两个数以 32 位带符号整数形式相乘的结果。</span></span><br><span class="line"><span class="built_in">Math</span>.hypot<span class="comment">//用于计算所有参数的平方和的平方根。</span></span><br><span class="line"><span class="built_in">Math</span>.trunc<span class="comment">//放回数字的整数部分。</span></span><br><span class="line"><span class="built_in">Math</span>.sign<span class="comment">//判断数字正负。</span></span><br><span class="line"><span class="built_in">Math</span>.clz32<span class="comment">//用于返回数字的32 位无符号整数形式的前导0的个数。</span></span><br><span class="line"><span class="built_in">Math</span>.fround<span class="comment">//获取数字的32为单精度浮点数形式。</span></span><br></pre></td></tr></table></figure>
<h1>ES6 对象</h1>
<h3 id="属性的简洁表示法">属性的简洁表示法</h3>
<p>ES6允许对象的属性直接写变量，这时候属性名是变量名，属性值是变量值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Amy&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;age, name&#125;;</span><br><span class="line">person   <span class="comment">//&#123;age: 12, name: &quot;Amy&quot;&#125;</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">age</span>: age, <span class="attr">name</span>: name&#125;</span><br></pre></td></tr></table></figure>
<p>方法名也可以简写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">sayHi</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性名表达式">属性名表达式</h3>
<p>ES6允许用表达式作为属性名，但是一定要将表达式放在方括号内。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"> [<span class="string">&quot;he&quot;</span>+<span class="string">&quot;llo&quot;</span>]()&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.hello();  <span class="comment">//&quot;Hi&quot;//hello用表达式表示。</span></span><br></pre></td></tr></table></figure>
<h2 id="对象的拓展运算符">对象的拓展运算符</h2>
<p>拓展运算符（…）用于取出参数对象所有可遍历属性然后拷贝到当前对象（相当于一个复制粘贴）。</p>
<h3 id="基本用法">基本用法</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>, <span class="attr">age</span>: <span class="number">15</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> someone = &#123; ...person &#125;; </span><br><span class="line">someone;  </span><br><span class="line"><span class="comment">//&#123;name: &quot;Amy&quot;, age: 15&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="可用于合并两个对象">可用于合并两个对象</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = &#123;<span class="attr">age</span>: <span class="number">15</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> name = &#123;<span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> person = &#123;...age, ...name&#125;; person;  </span><br><span class="line"><span class="comment">//&#123;age: 15, name: &quot;Amy&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="注意点">注意点</h3>
<p>自定义的属性和拓展运算符对象里面属性的相同的时候，实际属性根据栈结构决定，即后面的会把前面的属性覆盖掉。</p>
<h2 id="对象的新方法">对象的新方法</h2>
<p><strong>Object.assign(target, source_1, ···)</strong></p>
<p>用于将源对象的所有可枚举属性复制到目标对象中，相当于合并对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object2 = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object3 = &#123;<span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target,object2,object3);  </span><br><span class="line"><span class="comment">// 第一个参数是目标对象，后面的参数是源对象</span></span><br><span class="line">target;  <span class="comment">// &#123;a: 1, b: 2, c: 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性（与拓展运算符相同）</li>
<li>如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。</li>
</ul>
<h3 id="Object-is-value1-value2"><a href="http://Object.is">Object.is</a>(value1, value2)</h3>
<p>用来比较两个值是否严格相等，与（===）基本类似。</p>
<h1>ES6 数组</h1>
<h2 id="数组创建">数组创建</h2>
<p><strong>Array.of()</strong></p>
<p>将参数中所有值作为元素形成数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数值可为不同类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>, <span class="literal">true</span>)); <span class="comment">// [1, &#x27;2&#x27;, true]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数为空时返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of()); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p><strong>Array.from()</strong></p>
<p>将类数组对象或可迭代对象转化为数组。</p>
<h2 id="类数组对象">类数组对象</h2>
<p>一个类数组对象必须含有 length 属性，且元素属性名必须是数值或者可转换为数值的字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(&#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, 3]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 没有 length 属性,则返回空数组</span></span><br><span class="line"><span class="keyword">let</span> array = <span class="built_in">Array</span>.from(&#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// []</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 元素属性名不为数值且无法转换为数值，返回长度为 length 元素值为 undefined 的数组  </span></span><br><span class="line"><span class="keyword">let</span> array1 = <span class="built_in">Array</span>.from(&#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array1); <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure>
<h2 id="扩展的方法">扩展的方法</h2>
<h3 id="查找">查找</h3>
<p><strong>find()</strong>；</p>
<p>查找数组中符合条件的元素,若有多个符合条件的元素，则返回第一个元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组空位处理为 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="number">1</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> <span class="literal">true</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于箭头函数（=&gt;），ES6标准新增了一种新的函数：Arrow Function（箭头函数），相当于用item为参数定义了一个函数，然后返回item &gt; 2。</p>
</blockquote>
<p><strong>findIndex()</strong></p>
<p>查找数组中符合条件的元素索引，若有多个符合条件的元素，则返回第一个元素索引。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 参数1：回调函数</span></span><br><span class="line"><span class="comment">// 参数2(可选)：指定回调函数中的 this 值</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item == <span class="number">2</span>)); <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组空位处理为 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="number">1</span>].findIndex(<span class="function"><span class="params">n</span> =&gt;</span> <span class="literal">true</span>)); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<h3 id="填充">填充</h3>
<p><strong>fill()</strong></p>
<p>将一定范围索引的数组元素内容填充为单个指定的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 参数1：用来填充的值</span></span><br><span class="line"><span class="comment">// 参数2：被填充的起始索引</span></span><br><span class="line"><span class="comment">// 参数3(可选)：被填充的结束索引，默认为数组末尾</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.fill(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">// [1, 0, 3, 4]</span></span><br></pre></td></tr></table></figure>
<h3 id="遍历">遍历</h3>
<p><strong>entries()</strong></p>
<p>遍历键值对。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不使用 for... of 循环</span></span><br><span class="line"><span class="keyword">let</span> entries = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, &quot;a&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, &quot;b&quot;]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组含空位</span></span><br><span class="line"><span class="built_in">console</span>.log([...[,<span class="string">&#x27;a&#x27;</span>].entries()]); <span class="comment">// [[0, undefined], [1, &quot;a&quot;]]</span></span><br></pre></td></tr></table></figure>
<p><strong>keys()</strong></p>
<p>遍历键名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组含空位</span></span><br><span class="line"><span class="built_in">console</span>.log([...[,<span class="string">&#x27;a&#x27;</span>].keys()]); <span class="comment">// [0, 1]</span></span><br></pre></td></tr></table></figure>
<h1>ES6 函数</h1>
<h2 id="函数参数的扩展">函数参数的扩展</h2>
<h3 id="默认参数">默认参数</h3>
<p>基本用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name,age=<span class="number">17</span></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(name+<span class="string">&quot;,&quot;</span>+age);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">&quot;Amy&quot;</span>,<span class="number">18</span>);  <span class="comment">// Amy,18</span></span><br><span class="line">fn(<span class="string">&quot;Amy&quot;</span>,<span class="string">&quot;&quot;</span>);  <span class="comment">// Amy,</span></span><br><span class="line">fn(<span class="string">&quot;Amy&quot;</span>);     <span class="comment">// Amy,17</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>与我们平时的用法一致。</p>
</blockquote>
<h3 id="不定参数">不定参数</h3>
<p>不定参数用来表示不确定参数个数，形如，…变量名，由…加上一个具名参数标识符组成。具名参数只能放在参数组的最后，并且有且只有一个不定参数。</p>
<p>基本用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">...values</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(values.length);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>);      <span class="comment">//2</span></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);  <span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<h2 id="箭头函数">箭头函数</h2>
<p>箭头函数提供了一种更加简洁的函数书写方式。基本语法是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">参数 =&gt; 函数体</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>当箭头函数没有参数或者有多个参数，要用 <strong>()</strong> 括起来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b; f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">//8</span></span><br></pre></td></tr></table></figure>
<p>当箭头函数函数体有多行语句，用 <strong>{}</strong> 包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略 <strong>{}</strong> , 结果会自动返回。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123; <span class="keyword">let</span> result = a+b; <span class="keyword">return</span> result; &#125; f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>当箭头函数要返回对象的时候，为了区分于代码块，要用 <strong>()</strong> 将对象包裹起来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">id,name</span>) =&gt;</span> &#123;<span class="attr">id</span>: id, <span class="attr">name</span>: name&#125;; f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// SyntaxError: Unexpected token :  </span></span><br><span class="line"><span class="comment">// 不报错 var f = (id,name) =&gt; (&#123;id: id, name: name&#125;); f(6,2);  </span></span><br><span class="line"><span class="comment">// &#123;id: 6, name: 2&#125;</span></span><br></pre></td></tr></table></figure>
<h1>ES6 Class 类</h1>
<h2 id="概述">概述</h2>
<p>在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。</p>
<p>class 的本质是 function。</p>
<p>它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。</p>
<h2 id="基础用法">基础用法</h2>
<h3 id="类定义">类定义</h3>
<p>类表达式可以为匿名或命名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名类</span></span><br><span class="line"><span class="keyword">let</span> Example = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 命名类</span></span><br><span class="line"><span class="keyword">let</span> Example = <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类声明">类声明</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，类定义不会被提升，这意味着，必须在访问前对类进行定义，否则就会报错。</p>
<p>类中方法不需要 function 关键字。</p>
<p>方法间不能加分号。</p>
<p><strong>方法</strong></p>
<p>constructor 方法</p>
<p>constructor 方法是类的默认方法，创建类的实例化对象时被调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;我是constructor&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Example(); <span class="comment">// 我是constructor</span></span><br></pre></td></tr></table></figure>
<h2 id="封装与继承">封装与继承</h2>
<h3 id="getter-setter">getter / setter</h3>
<p>定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a; <span class="comment">// 实例化时调用 set 方法</span></span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">a</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;getter&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">a</span>(<span class="params">a</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;setter&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.a = a; <span class="comment">// 自身递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> exam = <span class="keyword">new</span> Example(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 不断输出 setter ，最终导致 RangeError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">a</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;getter&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">a</span>(<span class="params">a</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;setter&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>._a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> exam1 = <span class="keyword">new</span> Example1(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 只输出 setter , 不会调用 getter 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(exam1._a); <span class="comment">// 1, 可以直接访问</span></span><br></pre></td></tr></table></figure>
<h3 id="extends">extends</h3>
<p>通过 extends 实现类的继承。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h3 id="super">super</h3>
<p>子类 constructor 方法中必须有 super ，且必须出现在 this 之前。</p>
<p>调用父类方法, super 作为对象，在普通方法中，指向父类的原型对象，在静态方法中，指向父类</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// 调用父类普通方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">super</span>.test()); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">test3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类静态方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.test1+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Child2.test3(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h1>ES6 模块</h1>
<h2 id="特点-2">特点</h2>
<p>ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 <strong>use strict;</strong>。</p>
<p>模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。</p>
<p>每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。</p>
<p>每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----export [test.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> myfn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;My name is&quot;</span> + myName + <span class="string">&quot;! I&#x27;m &#x27;&quot;</span> + myAge + <span class="string">&quot;years old.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myClass =  <span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> a = <span class="string">&quot;yeah!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; myName, myAge, myfn, myClass &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName, myAge, myfn, myClass &#125; <span class="keyword">from</span> <span class="string">&quot;./test.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myfn());<span class="comment">// My name is Tom! I&#x27;m 20 years old.</span></span><br><span class="line"><span class="built_in">console</span>.log(myAge);<span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(myName);<span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(myClass.a );<span class="comment">// yeah!</span></span><br></pre></td></tr></table></figure>
<h3 id="as-的用法">as 的用法</h3>
<p>export 命令导出的接口名称，须和模块内部的变量有一一对应关系。</p>
<p>导入的变量名，须和导出的接口名称相同，即顺序可以不一致。</p>
<p>一般用于重新定义接口名称，隐藏模块内部的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----export [test.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName <span class="keyword">as</span> exportName &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; exportName &#125; <span class="keyword">from</span> <span class="string">&quot;./test.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(exportName);<span class="comment">// Tom</span></span><br><span class="line">使用 <span class="keyword">as</span> 重新定义导出的接口名称，隐藏模块内部的变量</span><br><span class="line"><span class="comment">/*-----export [test1.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName &#125;</span><br><span class="line"><span class="comment">/*-----export [test2.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Jerry&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName &#125;</span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName <span class="keyword">as</span> name1 &#125; <span class="keyword">from</span> <span class="string">&quot;./test1.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; myName <span class="keyword">as</span> name2 &#125; <span class="keyword">from</span> <span class="string">&quot;./test2.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name1);<span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(name2);<span class="comment">// Jerry</span></span><br></pre></td></tr></table></figure>
<h3 id="import-命令的特点">import 命令的特点</h3>
<p><strong>只读属性</strong>：不允许在加载模块的脚本里面，改写接口的引用指向，即可以改写 import 变量类型为对象的属性值，不能改写 import 变量类型为基本类型的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span></span><br><span class="line">a = &#123;&#125;; <span class="comment">// error</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span></span><br><span class="line">a.foo = <span class="string">&quot;hello&quot;</span>; <span class="comment">// a = &#123; foo : &#x27;hello&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>单例模式</strong>：多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。import 同一模块，声明不同接口引用，会声明对应变量，但只执行一次 import 。</p>
<h3 id="export-default-命令">export default 命令</h3>
<ul>
<li>在一个文件或模块中，export、import 可以有多个，export default 仅有一个。</li>
<li>export default 中的 default 是对应的导出接口变量。</li>
<li>通过 export 方式导出，在导入时要加{ }，export default 则不需要。</li>
<li>export default 向外暴露的成员，可以使用任意变量来接收。</li>
</ul>
<h1>ES6 Promise 对象</h1>
<h2 id="概述-2">概述</h2>
<p>是异步编程的一种解决方案。</p>
<p>从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>
<h2 id="Promise-状态">Promise 状态</h2>
<h3 id="状态的特点">状态的特点</h3>
<p>Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。</p>
<p>Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success1&#x27;</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;success2&#x27;</span>);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;  </span><br><span class="line">    resolve(<span class="string">&#x27;success3&#x27;</span>); </span><br><span class="line">    reject(<span class="string">&#x27;reject&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success1</span></span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>已经忘记了promise函数？<a href="https://tosuke.gitee.io/2022/01/20/JavaScript%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/#Promise">点击我回顾</a></p>
</blockquote>
<h1>ES6 Generator 函数</h1>
<p>ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。 基本用法</p>
<h3 id="Generator-函数组成">Generator 函数组成</h3>
<p>Generator 有两个区分于普通函数的部分：</p>
<ul>
<li>一是在 function 后面，函数名之前有个 * ；</li>
<li>函数内部有 yield 表达式。</li>
</ul>
<p>其中 * 用来表示函数为 Generator 函数，yield 用来定义函数内部的状态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;two&quot;</span>);</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;three&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行机制">执行机制</h3>
<p>调用 Generator 函数和调用普通函数一样，在函数名后面加上()即可，但是 Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针，所以要调用遍历器对象Iterator 的 next 方法，指针就会从函数头部或者上一次停下来的地方开始执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f.next();</span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;1&quot;, done: false&#125;</span></span><br><span class="line"> </span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line"> </span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// three</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;3&quot;, done: true&#125;</span></span><br><span class="line"> </span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>第一次调用 next 方法时，从 Generator 函数的头部开始执行，先是打印了 one ,执行到 yield 就停下来，并将yield 后边表达式的值 ‘1’，作为返回对象的 value 属性值，此时函数还没有执行完， 返回对象的 done 属性值是 false。</p>
<p>第二次调用 next 方法时，同上步 。</p>
<p>第三次调用 next 方法时，先是打印了 three ，然后执行了函数的返回操作，并将 return 后面的表达式的值，作为返回对象的 value 属性值，此时函数已经结束，多以 done 属性值为true 。</p>
<p>第四次调用 next 方法时， 此时函数已经执行完了，所以返回 value 属性值是 undefined ，done 属性值是 true 。如果执行第三步时，没有 return 语句的话，就直接返回 {value: undefined, done: true}。</p>
<h1>ES6 async 函数</h1>
<h2 id="async">async</h2>
<p>async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">[param[, param[, ... param]]]</span>) </span>&#123; statements &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>name: 函数名称。</li>
<li>param: 要传递给函数的参数的名称。</li>
<li>statements: 函数体语句。</li>
</ul>
<h2 id="5-3-ES6-async-函数">5.3 ES6 async 函数</h2>
<h3 id="分类-ES6-教程"><em>分类</em> <a href="https://www.runoob.com/w3cnote_genre/es6">ES6 教程</a></h3>
<h2 id="async-2">async</h2>
<p>async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的。</p>
<h3 id="语法">语法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function name([param[, param[, ... param]]]) &#123; statements &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>name: 函数名称。</li>
<li>param: 要传递给函数的参数的名称。</li>
<li>statements: 函数体语句。</li>
</ul>
<h3 id="返回值">返回值</h3>
<p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;helloAsync&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(helloAsync())  <span class="comment">// Promise &#123;&lt;resolved&gt;: &quot;helloAsync&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line">helloAsync().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(v);         <span class="comment">// helloAsync</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML入门</title>
    <url>/2022/01/11/HTML%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1>初识HTML</h1>
<p>HTML全称hyper Text marker language（超文本标记语言），使web时代更具有稳定性，是多个厂商共同认定的互联网标准。</p>
<h2 id="HTML5的优势">HTML5的优势</h2>
<h3 id="世界知名浏览器厂商对HTML-5的支持">世界知名浏览器厂商对HTML 5的支持</h3>
<p>微软<br>
Google<br>
苹果<br>
Opera<br>
Mozilla</p>
<h3 id="市场的需求">市场的需求</h3>
<h3 id="跨平台">跨平台</h3>
<h2 id="W3C–万维网联盟">W3C–万维网联盟</h2>
<p>W3C<br>
World Wide Web Consortium (万维网联盟)<br>
成立于1994年，Web技术领域最权威和具影响力的国际中立性技术标准机<br>
<a href="http://www.w3.org/">http://www.w3.org/</a><br>
<a href="http://www.chinaw3c.org/">http://www.chinaw3c.org/</a><br>
W3C标准包括<br>
1、结构化标准语言(HTML、 XML)<br>
2、表现标准语言(CSS)<br>
3、行为标准(DOM、ECMAScript )</p>
<h1>HTML的结构</h1>
<p>主要由head（头部）、body（主体）构成：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112133518702.png" alt="image-20220112133518702" style="zoom:80%;">
<p>HTML名为标签语言，意味着每个语句都是一个标签，而标签是一个标签组，像</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>与<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样，必须成对出现（单独呈现的标签加‘/’来关闭元素，例如<hr>；），前一个叫<strong>开放标签</strong>后一个叫<strong>闭合标签</strong>，中间就是我们所编写的内容，开放标签里还可以添加一些参数。</p>
<p>在head标签里有一些网页基本信息</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">DOCTYPE声明：文档声明，使用什么规范。</span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>标签<span class="comment">&lt;!-- 网页的名字--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span>&gt;</span>标签<span class="comment">&lt;!-- meta一般用来做seo，即关键字描述--&gt;</span></span><br><span class="line"> 注：<span class="comment">&lt;!-- ***--&gt;</span>为HTML的注释写法，***即为想要写的内容。</span><br></pre></td></tr></table></figure>
<h1>网页基本标签</h1>
<h2 id="标题标签">标题标签</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;一级标题&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;二级标题&lt;/h2&gt;</span><br><span class="line">&lt;h3&gt;三级标题&lt;/h3&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;h1&gt;&lt;h1/&gt;</code>这样的结构就是我们的标题标签，h几就代表第几级标签，对于划分网页的结构用处很大，实际效果如下：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112135742592.png" alt="image-20220112135742592" style="zoom:80%;">
<h2 id="段落标签">段落标签</h2>
<p>假设我们直接在body标签里这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">暴雨如期而至。雨珠打翻了枯叶，搅混了池塘，空中弥漫着泥土的气息，池塘里的鱼群惊慌失措，仿佛因为看不清前途命运而焦躁不安。</span><br><span class="line"></span><br><span class="line">叶瑾介当时也是在这种时候到达新泽的。</span><br><span class="line"></span><br><span class="line">虽说新泽阴雨连绵，很少能够见到阳光，但对于参加过高考的叶瑾介来说，这注定会是他通往梦想的地方。</span><br><span class="line"></span><br><span class="line">“新泽没有夏天”</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>虽然我们编写的时候事注意了空格和换行的，当时在网页中的显示效果却是这样：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112140243572.png" alt="image-20220112140243572"></p>
<p>也就是全部一字排开，并没有识别到我们的换行。这是因为HTML并不能直接识别到我们的回车换行分段，需要使用<code>&lt;p&gt;&lt;/p&gt;</code>来进行分段规范，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    暴雨如期而至。雨珠打翻了枯叶，搅混了池塘，空中弥漫着泥土的气息，池塘里的鱼群惊慌失措，仿佛因为看不清前途命运而焦躁不安。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line">    叶瑾介当时也是在这种时候到达新泽的。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">    虽说新泽阴雨连绵，很少能够见到阳光，但对于参加过高考的叶瑾介来说，这注定会是他通往梦想的地方。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt;“新泽没有夏天”&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>诺，这样分好段的话，就是这个样子了：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112154049136.png" alt="image-20220112154049136"></p>
<h2 id="换行标签">换行标签</h2>
<p>换行与分段的效果很像，换行是在你想要换行的地方加入<code>&lt;br/&gt;</code>,不过换行的行间距要小于分段的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">暴雨如期而至。雨珠打翻了枯叶，搅混了池塘，空中弥漫着泥土的气息，池塘里的鱼群惊慌失措，仿佛因为看不清前途命运而焦躁不安。<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">叶瑾介当时也是在这种时候到达新泽的。<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">虽说新泽阴雨连绵，很少能够见到阳光，但对于参加过高考的叶瑾介来说，这注定会是他通往梦想的地方。<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">“新泽没有夏天”<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>对比效果如下：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112154636593.png" alt="image-20220112154636593"></p>
<h2 id="水平线标签">水平线标签</h2>
<p>水平线标签<code>&lt;hr/&gt;</code>就是分割文章的水平线，效果如下：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112154840335.png" alt="image-20220112154840335"></p>
<h2 id="字体样式标签">字体样式标签</h2>
<p>字体样式标签分为粗体、斜体与特殊符号</p>
<p>粗体与斜体分别用<code>&lt;strong&gt;</code>与<code>&lt;/em&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">粗体：<span class="tag">&lt;<span class="name">strong</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">斜体: <span class="tag">&lt;<span class="name">em</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>具体效果为：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112155953378.png" alt="image-20220112155953378"></p>
<h2 id="注释和特殊符号">注释和特殊符号</h2>
<p>注释已经说过了，特殊字符包括我们的代码、&lt;(这个尖括号)、空格等。</p>
<p>空格：</p>
<p>标签为&amp;nbsp，像我们自己手动打出来的空格HTML是不会认的，需要在需要空格的地方添加这个标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span> 换行</span><br><span class="line"><span class="symbol">&amp;gt;</span>大于符号</span><br><span class="line"><span class="symbol">&amp;lt;</span>小于符号</span><br><span class="line"><span class="symbol">&amp;copy;</span>版权所有</span><br></pre></td></tr></table></figure>
<p>其他标签都是由&amp;+标识符+;组成的。</p>
<h1>图像标签</h1>
<p>常见的图像格式有：jpg、gif、png、bmp（位图）等等。</p>
<p>图像标签为<code>&lt;img/&gt;</code>标签，标签内可以编写格式，它的格式为：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220112162359069.png" alt="image-20220112162359069"></p>
<p>src为图片路径，分为绝对路径贺相对路径，绝对路径是文件在具体磁盘分区的位置。</p>
<p>相对分区的格式一般要先使用…/进入上级标签，然后进入相应的文件夹选择相应的图片.</p>
<p>例如：我的图片已经放在了与HTML文件同级的img文件夹下、</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220114230853528.png" alt="image-20220114230853528" style="zoom:50%;">
<p>所以引用的相对地址就是…/img/1.jpg。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../img/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;春川魔姬&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>引用成功！：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220114231106834.png" alt="image-20220114231106834" style="zoom:50%;">
<p>至于img后的alt属性是指在图由于各种原因没加载出来时，所显示的图片名称，例如如果我把img文件夹的图片删除时，加载出来的就是这样的：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220114231508890.png" alt="image-20220114231508890" style="zoom: 67%;">
<p>另外图片标签还有title属性，就是当鼠标悬停时所显示的文字。width以及height属性，用于控制图片大小，但我们一般用CSS来完成这些工作，所以这里就请大家自己去试试吧。</p>
<h1>链接标签</h1>
<p>链接标签就是网页中点击可以跳转的文字或者图片，这种标签在网页中非常常见，所以非常重要。</p>
<p>链接标签的基本格式为：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220114232411036.png" alt="image-20220114232411036"></p>
<p>a就是a标签，href属性表示想要跳转的路径（有很多分类实现不同的功能），target为新建窗口位置（一般来说就是在当前页面打开还是新建窗口），在标签里面的就是我们想要点击的东西，可以是图片也可以是文字。</p>
<h2 id="页面链接">页面链接</h2>
<p>我先建一个新页面（也就是另一个HTML文件）：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220114234016738.png" alt="image-20220114234016738" style="zoom:50%;">
<p>然后在之前的页面中编写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;测试页面.html&quot;</span>&gt;</span>点我跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样在网页中就会有一个跳转标签：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220114234222167.png" alt="image-20220114234222167" style="zoom:80%;">
<p>点击便实现了跳转。</p>
<h2 id="网址链接">网址链接</h2>
<p>href链接路径中也可以直接填写网站链接，像是“<code>https://www.baidu.com</code>”,这样的话点击标签就直接跳转到了百度。</p>
<h2 id="锚链接">锚链接</h2>
<p>我更想叫他飞雷神链接（即基本原理为“设置标签”+“点击跳转到指定标签”）。</p>
<p>设置锚标签的语句是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;top&quot;</span>&gt;</span>顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span>（可不添加文字）</span><br></pre></td></tr></table></figure>
<p>跳转锚标签的语句是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#top&quot;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span>（也就是href属性中写#加上锚标签的名字）</span><br></pre></td></tr></table></figure>
<h2 id="功能性链接">功能性链接</h2>
<p>这种链接用于实现某一功能，比如点击联系我啊这类的，举个例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:1848228664@qq.com&quot;</span>&gt;</span>点击联系京介<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就会自动调用软件，向我发送邮件咯。</p>
<h1>行内元素与块元素</h1>
<p>这个单独成块的元素以及以行为单位的元素，这个在CSS中比较重要，这里稍作了解即可。</p>
<h1>列表标签</h1>
<p>列表标签就是辅助使得文章更加条理清晰的展示，也就是类似于文章分点这种功能。</p>
<h2 id="有序列表（order-list）">有序列表（order list）</h2>
<p>格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;ol&gt;  &lt;/ol&gt;</code>标签指的就是有序标签，在其中用<code>&lt;li&gt;   &lt;/li&gt;</code>进行分条。</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220115141301222.png" alt="image-20220115141301222" style="zoom:67%;">
<h2 id="无序标签（unorder-list）">无序标签（unorder list）</h2>
<p>格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>格式与有序标签相似，只是英文缩写不同而已。</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220115141721006.png" alt="image-20220115141721006" style="zoom:67%;">
<p>无序标签一般用于导航栏，书签之类的。</p>
<h2 id="自定义列表（defintion-list）">自定义列表（defintion list）</h2>
<p>格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>顺序<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>分类<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>python<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>c/c++<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>自定义标签指的是标签有列表分类，即可以用<code>&lt;dt&gt;&lt;/dt&gt;</code>对其下内容归纳一个类名。</p>
<p>一般用于网页底部的公司介绍等。</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220115142520683.png" alt="image-20220115142520683" style="zoom:80%;">
<h1>表格标签</h1>
<p>制作我们在网页中常见的网格</p>
<p>格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1px&quot;</span>&gt;</span> border属性是用于给表格加上裱框。</span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>1-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>1-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>1-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>先用table标签制作表格，在里面用tr标签代表行，在tr标签里用td标签代表每一列并添加内容。</p>
<p>在表格里我们经常会使用合并行或者合并项的操作，在td列标签添加属性colspan并添加合并多少列的参数就可以实现合并列，同理，在td列标签添加属性rowspan即可合并行。</p>
<p>表格也在css中占据重要位置，故HTML表格仅作了解。</p>
<h1>媒体标签</h1>
<p>例如视频元素：</p>
<p>格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>大家应该也都知道了src就是所谓的资源路径了，只需要把视频的地址放进去就行了，由于我没有比较适合拿来公开演示的视频，那么就请大家自己实验了，后面的controls与autoplay属性是实现添加视频控件和自动播放功能。</p>
<p>音频元素也是一样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以添加controls与autoplay等属性。</p>
<h1>页面结构分析</h1>
<table>
<thead>
<tr>
<th>元素名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>header</td>
<td>标题头部区域的内容(用于页面或页面中的-块区域)</td>
</tr>
<tr>
<td>footer</td>
<td>标记脚部区域的内容(用于整个页面或页面的一块区域)</td>
</tr>
<tr>
<td>section</td>
<td>Web页面中的一块独立区域</td>
</tr>
<tr>
<td>article</td>
<td>独立的文章内容</td>
</tr>
<tr>
<td>aside</td>
<td>相关内容或应用(常用于侧边栏)</td>
</tr>
<tr>
<td>nav</td>
<td>导航类辅助内容</td>
</tr>
</tbody>
</table>
<p>用这些标签去给网页内容分类，能够使得网站布局条理清晰。</p>
<h1>iframe内联框架</h1>
<p>即在网站中嵌入一个其他网站，比如在网站里嵌入其他网站的视频，功能等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">name</span>=<span class="string">&quot;框架&quot;</span> <span class="attr">width</span>=<span class="string">&quot;800px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1000px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>iframe内联框架本质上是构建一个内容框架，你可以在里面打开任何一个你想要打开的资源内容，如同上句所写，这时候你的网页将会有一个width=“800px” height=&quot;1000px&quot;的框架，里面打开的是src中的百度。</p>
<p>iframe内联框架也可以不需要src路径，在之间的链接标签中的target属性便可以指向框架的名字，这样的话跳转的内容将会在框架中呈现。</p>
<h1>表单语法</h1>
<p>我们在平时上网时，经常会注册或者登陆一些账号，比如这个界面：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220115223427076.png" alt="image-20220115223427076"></p>
<p>这些与我们提交的信息相关的叫做表单</p>
<p>了解一下表单的基本语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;我的第一个HTML.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        名字<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span><span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>表单标签是form，在form中构建你想要的表单元素，在form下的属性method决定了表单请求的方式，简单来说：get:不安全，但是效率高，而post正好相反。</p>
<p>最后的效果就如同所示，关于具体的表单请求可以在检查中的network中察看。</p>
<h2 id="文本框">文本框</h2>
<p>表单中重要的是input标签，虽然它的字面含义让人很容易想到输入框，但它的功能远不止这么简单，决定它的用途的是input标签里的type属性，举例为：</p>
<ol>
<li>text：普通文本输入框</li>
<li>password：密码输入框（输入的文字不可见）</li>
<li>submit：提交按钮</li>
<li>reset：重置按钮</li>
<li>radio：单选（同一组使用相同name进行约束，checked默认选择）</li>
<li>checkbox：多选框 （同一组有效）</li>
<li>button：按钮</li>
<li>……</li>
</ol>
<p>另外input标签还有其他属性，name用来命名，value设定初始值，maclength设定最大字符数，size设定文本框的长度。</p>
<h2 id="下拉框与文本域">下拉框与文本域</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zhi&quot;</span>&gt;</span>zhong<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zh&quot;</span> <span class="attr">selected</span>&gt;</span>mei<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zi&quot;</span>&gt;</span>ouoi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>select为下拉框标签，里面用option标签写每一个选项，option标签里的属性selected是默认选中的意思。</p>
<p>文本域为一串文本输入框：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;文本域&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>文件域可以上传文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;btn1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面那个上传按钮纯属装饰。</p>
<h2 id="输入验证">输入验证</h2>
<p>有邮件验证：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时输入的如果不是邮箱地址就会这样：</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220115232631278.png" alt="image-20220115232631278" style="zoom:67%;">
<p>url验证：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;url&quot;</span><span class="attr">name</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>数字验证：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span><span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">min</span>=<span class="string">&quot;1&quot;</span><span class="attr">step</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="滑块">滑块</h2>
<p>把数字抽象为滑块来展示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>音量：</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span><span class="attr">name</span>=<span class="string">&quot;la&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span><span class="attr">min</span>=<span class="string">&quot;0&quot;</span><span class="attr">step</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220115233049179.png" alt="image-20220115233049179"></p>
<h2 id="搜索框">搜索框</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span><span class="attr">name</span>=<span class="string">&quot;search&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="表单的应用">表单的应用</h2>
<h3 id="只读（readonly）与禁用（disable）">只读（readonly）与禁用（disable）</h3>
<p>让输入框内容无法更改，在input标签中加入readonly属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">名字<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">readonly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>让选项框无法选择，在input标签中加入disable属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zhi&quot;</span> <span class="attr">disabled</span>&gt;</span>zhong<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zh&quot;</span> <span class="attr">selected</span>&gt;</span>mei<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zi&quot;</span>&gt;</span>ouoi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时在下拉框中已无法选择zhong。</p>
<h3 id="隐藏（hidden）">隐藏（hidden）</h3>
<p>使得某些元素隐藏，达到默认值的效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>密码<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span><span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">hidden</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样便会隐藏密码框，使用默认值123546。</p>
<img src="/2022/01/11/HTML%E5%85%A5%E9%97%A8/image-20220116003850604.png" alt="image-20220116003850604" style="zoom:67%;">
<h3 id="点击文字进行输入">点击文字进行输入</h3>
<p>这是label标签的作用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;mark&quot;</span>&gt;</span>点我试试看<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将姓名输入框的id改为mark</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">名字<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mark&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样点击label就会进入姓名的输入了。</p>
<h1>表单的初级验证</h1>
<p>placeholder属性：输入框的灰色提示语句。</p>
<p>required属性：操作不能为空。</p>
<p>pattern属性：要求为正则表达式。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端入门</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6,Javascript下一代版本答案(一)</title>
    <url>/2022/02/09/ES6-Javascript%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%89%88%E6%9C%AC%E7%AD%94%E6%A1%88/</url>
    <content><![CDATA[<h1>ES6简介</h1>
<p>ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。</p>
<p>ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。</p>
<blockquote>
<p>实际上JavaScript现行最佳的语法规则就是ES6，几乎所有浏览器都支持ES6（除了已经被废弃的IE浏览器）。</p>
</blockquote>
<h2 id="ECMAScript-的背景">ECMAScript 的背景</h2>
<p>JavaScript 是大家所了解的语言名称，但是这个语言名称是商标（ Oracle 公司注册的商标）。因此，JavaScript 的正式名称是 ECMAScript 。1996年11月，JavaScript 的创造者网景公司将 JS 提交给国际化标准组织 ECMA（European computer manufactures association，欧洲计算机制造联合会），希望这种语言能够成为国际标准，随后 ECMA 发布了规定浏览器脚本语言的标准，即 ECMAScript。这也有利于这门语言的开放和中立。</p>
<h1>webpack</h1>
<p>这是一款JavaScript应用程序的打包器，会对JavaScript程序进行分模块的打包，这里暂时不深入探讨。</p>
<h1>let 与 const</h1>
<p>ES6 新增加了两个重要的 JavaScript 关键字: <strong>let</strong> 和 <strong>const</strong>。</p>
<h2 id="let">let</h2>
<h3 id="只代码块内有效">只代码块内有效</h3>
<p>let 声明的变量只在 let 命令所在的代码块内有效，即只在let所在的大括号内有效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;<span class="comment">//仅在大括号内有效。</span></span><br><span class="line">  a   <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line">a   <span class="comment">// 报错 ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>
<p>let 是在代码块内有效，而我们以前常用的var 是在全局范围内有效。</p>
<h3 id="不能重复声明"><strong>不能重复声明</strong></h3>
<p>let 只能声明一次，而var 可以声明多次</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">4</span>;</span><br><span class="line">a  <span class="comment">// Identifier &#x27;a&#x27; has already been declared</span></span><br><span class="line">b  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>for 循环计数器很适合用 let</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环计数器很适合用 <span class="keyword">let</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出十个 10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 0123456789</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实以上代码还牵扯到关于对“任务队列”的理解，用var定义的i为什么会输出十个10？是因为每一次for循环的时候，setTimeout都执行一次， 但是里面的函数没有被执行，而是被放到了任务队列里面，等待执行， for循环了4次，就放了4次，当主线程执行完成后，才进入任务队列里面执行——京介</p>
</blockquote>
<h3 id="不存在变量提升">不存在变量提升</h3>
<p>即let只能先定义声明才能使用，而var可以使用变量后再声明（变量提升）。</p>
<h2 id="const-命令">const 命令</h2>
<p>const命令大家应该很熟悉，类似于c语言的default，const 声明一个只读变量，声明之后不允许改变。意味着，一旦声明必须初始化，否则会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="string">&quot;3.1415926&quot;</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">const</span> age;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<p>ES6 明确规定，代码块内如果存在 let 或者 const，代码块会对这些命令声明的变量从块的开始就形成一个封闭作用域。代码块内，在声明变量 PI 之前使用它会报错。</p>
<h3 id="注意要点">注意要点</h3>
<p>const 如何做到变量在声明初始化之后不允许改变的？其实 const 其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动。此时，你可能已经想到，简单类型和复合类型保存值的方式是不同的。是的，对于简单类型（数值 number、字符串 string 、布尔值 boolean）,值就保存在变量指向的那个内存地址，因此 const 声明的简单类型变量等同于常量。而复杂类型（对象 object，数组 array，函数 function），变量指向的内存地址其实是保存了一个指向实际数据的指针，所以 const 只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了，所以使用 const 声明复杂类型对象时要慎重。</p>
<h1>解构赋值</h1>
<h2 id="概述">概述</h2>
<p>解构赋值是对赋值运算符的扩展。</p>
<p>他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。</p>
<p>在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。</p>
<p>举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure>
<p>是不是一目了然呢？</p>
<p>通俗地说，结构赋值就类似于一种快捷批处理命令，可以f方便我们的代码书写。</p>
<hr>
<h2 id="解构模型">解构模型</h2>
<p>在解构中，有下面两部分参与：</p>
<p>解构的源，解构赋值表达式的右边部分。解构的目标，解构赋值表达式的左边部分。</p>
<p>数组的解构有以下特点模型：</p>
<p><strong>可嵌套</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]]; </span><br><span class="line"><span class="comment">// a = 1 </span></span><br><span class="line"><span class="comment">// b = 2 </span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure>
<p><strong>可忽略</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 3</span></span><br></pre></td></tr></table></figure>
<p><strong>不完全解构</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b] = [];</span><br><span class="line"><span class="comment">// a = 1, b = undefined</span></span><br></pre></td></tr></table></figure>
<p><strong>剩余运算符</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line"><span class="comment">//a = 1 </span></span><br><span class="line"><span class="comment">//b = [2, 3]</span></span><br></pre></td></tr></table></figure>
<p><strong>字符串等</strong></p>
<p>在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。可遍历对象即实现 Iterator 接口的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="comment">// a = &#x27;h&#x27; </span></span><br><span class="line"><span class="comment">// b = &#x27;e&#x27; </span></span><br><span class="line"><span class="comment">// c = &#x27;l&#x27;</span></span><br><span class="line"><span class="comment">// d = &#x27;l&#x27; </span></span><br><span class="line"><span class="comment">// e = &#x27;o&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>解构默认值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">2</span>] = [<span class="literal">undefined</span>]; <span class="comment">// a = 2</span></span><br></pre></td></tr></table></figure>
<p>当解构模式有匹配结果，且匹配结果是 undefined 时，会触发默认值作为返回结果。</p>
<ul>
<li>
<pre><code class="language-js">let [a = 3, b = a] = [];     
// a = 3, b = 3 let [a = 3, b = a] = [1];
// a = 1, b = 1 let [a = 3, b = a] = [1, 2]; 
// a = 1, b = 2
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1、a 与 b 匹配结果为 undefined ，触发默认值：**a = 3; b = a =3**</span><br><span class="line"></span><br><span class="line">2、a 正常解构赋值，匹配结果：a = 1，b 匹配结果 undefined ，触发默认值：**b = a =1**</span><br><span class="line"></span><br><span class="line">3、a 与 b 正常解构赋值，匹配结果：**a = 1，b = 2**</span><br><span class="line"></span><br><span class="line">## 对象模型的解构（Object）</span><br><span class="line"></span><br><span class="line">对象模型也有相应的解构特点模型，这里仅供了解。</span><br><span class="line"></span><br><span class="line">**基本**</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">let &#123; foo, bar &#125; = &#123; foo: &#x27;aaa&#x27;, bar: &#x27;bbb&#x27; &#125;;</span><br><span class="line">// foo = &#x27;aaa&#x27;</span><br><span class="line">// bar = &#x27;bbb&#x27;</span><br><span class="line"> </span><br><span class="line">let &#123; baz : foo &#125; = &#123; baz : &#x27;ddd&#x27; &#125;;</span><br><span class="line">// foo = &#x27;ddd&#x27;</span><br></pre></td></tr></table></figure>

**可嵌套可忽略**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj; </span><br><span class="line"><span class="comment">// x = &#x27;hello&#x27; </span></span><br><span class="line"><span class="comment">// y = &#x27;world&#x27; let obj = &#123;p: [&#x27;hello&#x27;, &#123;y: &#x27;world&#x27;&#125;] &#125;; </span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123;  &#125;] &#125; = obj; </span><br><span class="line"><span class="comment">// x = &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>

**不完全解构**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [&#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;; </span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [&#123; y &#125;, x ] &#125; = obj; </span><br><span class="line"><span class="comment">// x = undefined </span></span><br><span class="line"><span class="comment">// y = &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>

**剩余运算符**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>&#125;; </span><br><span class="line"><span class="comment">// a = 10 </span></span><br><span class="line"><span class="comment">// b = 20 </span></span><br><span class="line"><span class="comment">// rest = &#123;c: 30, d: 40&#125;</span></span><br></pre></td></tr></table></figure>

**解构默认值**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a = <span class="number">10</span>, b = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;; </span><br><span class="line"><span class="comment">// a = 3; b = 5; </span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>: aa = <span class="number">10</span>, <span class="attr">b</span>: bb = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// aa = 3; bb = 5;</span></span><br></pre></td></tr></table></figure>

# Symbol

## 概述

ES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，**最大的用法是用来定义对象的唯一属性名。**

ES6 数据类型除了 Number 、 String 、 Boolean 、 Object、 null 和 undefined ，还新增了 Symbol 。

------

## 基本用法

Symbol 函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象。可以接受一个字符串作为参数，为新创建的 Symbol 提供描述，用来显示在控制台或者作为字符串的时候使用，便于区分。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">&quot;KK&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sy);   <span class="comment">// Symbol(KK)</span></span><br><span class="line"><span class="keyword">typeof</span>(sy);        <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 相同参数 Symbol() 返回的值不相等</span></span><br><span class="line"><span class="keyword">let</span> sy1 = <span class="built_in">Symbol</span>(<span class="string">&quot;kk&quot;</span>); </span><br><span class="line">sy === sy1;       <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

## 使用场景

第一是作为属性名，由于每一个 Symbol 的值都是不相等的，所以 Symbol 作为对象的属性名，可以保证属性不重名。

第二是定义常量，Symbol 的值是唯一的，所以不会出现相同值得常量。

# Symbol

一种新引入的原始数据类型，表示独一无二的值，定义对象的唯一属性名，另外，ES6所有的数据类型为Number 、 String 、 Boolean 、 Object、 null 和 undefined ，还新增了 Symbol。

## 用法

定义：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy=<span class="built_in">Symbol</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"><span class="comment">//其中的xxx为描述symbol的内容，便于区分不同的symbol类型。</span></span><br></pre></td></tr></table></figure>

不同的写法：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法1</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;&#125;;</span><br><span class="line">syObject[sy] = <span class="string">&quot;kk&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(syObject);    <span class="comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;</span><br><span class="line">  [sy]: <span class="string">&quot;kk&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(syObject);    <span class="comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法3</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(syObject, sy, &#123;<span class="attr">value</span>: <span class="string">&quot;kk&quot;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(syObject);   <span class="comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span></span><br></pre></td></tr></table></figure>

## 特点

使用 Symbol 定义常量，这样就可以保证一组常量的值都不相等。避免引发选择错误。

## 方法

### Symbol.for()

会全局搜索是否有含有参数值的symbol类型数据，如果没有将会创造一个新的symbol并登记供搜索（以普通的方法构造的symbol不会被搜索到）。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yellow = <span class="built_in">Symbol</span>(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> yellow1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">yellow === yellow1;      <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> yellow2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">yellow1 === yellow2;     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

### Symbol.keyFor()

直接返回一个Symbol的key值，参数为symbol类型的名称。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yellow1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(yellow1);    <span class="comment">// &quot;Yellow&quot;</span></span><br></pre></td></tr></table></figure>

# Map 与 Set

Map对象保存键值对，任何对象或是原始值都可以作为一个键或者一个值。可以说，Map比object做的更加彻底，从另一方面来说也印证了随着时代的发展，编程的语法将会不再那么严格，会变得越来越简单，学编程的成本也会大幅下降。

## Maps 和 Objects 的区别

- 一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。
- Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。
- Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。
- Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。

![图片来自菜鸟教程](E:/BaiduNetdiskWorkspace/source/image-20220321090356352.png)

## 用法

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mymap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">var</span> key=<span class="string">&quot;key`s value&quot;</span></span><br><span class="line">mymap.set(key,<span class="string">&quot;value&quot;</span>);<span class="comment">//值不一定是字符串。</span></span><br><span class="line">mymap.get(key);<span class="comment">//mymap.get(&quot;key`s value&quot;)相同。</span></span><br></pre></td></tr></table></figure>

下面来列举几个Map键值对中的key是其他类型的例子：

**key是字符串：**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">var</span> keyString = <span class="string">&quot;a string&quot;</span>; </span><br><span class="line"> </span><br><span class="line">myMap.set(keyString, <span class="string">&quot;和键&#x27;a string&#x27;关联的值&quot;</span>);</span><br><span class="line"> </span><br><span class="line">myMap.get(keyString);    <span class="comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span></span><br><span class="line">myMap.get(<span class="string">&quot;a string&quot;</span>);   <span class="comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span></span><br><span class="line">                         <span class="comment">// 因为 keyString === &#x27;a string&#x27;</span></span><br></pre></td></tr></table></figure>

**key 是对象**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line"><span class="keyword">var</span> keyObj = &#123;&#125;,   </span><br><span class="line"> myMap.set(keyObj, <span class="string">&quot;和键 keyObj 关联的值&quot;</span>);  myMap.get(keyObj); <span class="comment">// &quot;和键 keyObj 关联的值&quot; myMap.get(&#123;&#125;); // undefined, 因为 keyObj !== &#123;&#125;</span></span><br></pre></td></tr></table></figure>

**key 是函数**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line"><span class="keyword">var</span> keyFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,  </span><br><span class="line">    <span class="comment">//函数  myMap.set(keyFunc, &quot;和键 keyFunc 关联的值&quot;);  myMap.get(keyFunc); </span></span><br><span class="line">    <span class="comment">// &quot;和键 keyFunc 关联的值&quot; myMap.get(function() &#123;&#125;) </span></span><br><span class="line">    <span class="comment">// undefined, 因为 keyFunc !== function () &#123;&#125;</span></span><br></pre></td></tr></table></figure>

**key 是 NaN**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line">myMap.set(<span class="literal">NaN</span>, <span class="string">&quot;not a number&quot;</span>);  </span><br><span class="line">myMap.get(<span class="literal">NaN</span>); </span><br><span class="line"><span class="comment">// &quot;not a number&quot;  var otherNaN = Number(&quot;foo&quot;); myMap.get(otherNaN); </span></span><br><span class="line"><span class="comment">// &quot;not a number&quot;</span></span><br></pre></td></tr></table></figure>

虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，NaN作为Map的键来说是没有区别的。

**Map的迭代**

1、for...of

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>);</span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在for循环中使用key和value的组用of对map进行迭代。</span></span><br></pre></td></tr></table></figure>

被在for中用of进行迭代的对象不只是map对象，还有myMap.entries()、myMap.keys()、myMap.values()

等方法。

### Map 对象的操作

**Map 与 Array的转换**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> kvArray = [[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象</span></span><br><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(kvArray);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组</span></span><br><span class="line"><span class="keyword">var</span> outArray = <span class="built_in">Array</span>.from(myMap);</span><br></pre></td></tr></table></figure>

**Map 的克隆**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]]);</span><br><span class="line"><span class="keyword">var</span> myMap2 = <span class="keyword">new</span> <span class="built_in">Map</span>(myMap1);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(original === clone); </span><br><span class="line"><span class="comment">// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。</span></span><br></pre></td></tr></table></figure>

**Map 的合并**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],]);</span><br><span class="line"><span class="keyword">var</span> second = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;uno&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;dos&#x27;</span>]]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three</span></span><br><span class="line"><span class="keyword">var</span> merged = <span class="keyword">new</span> <span class="built_in">Map</span>([...first, ...second]);</span><br></pre></td></tr></table></figure>

### Map 的迭代

对 Map 进行遍历，以下两个最高级。

#### for...of

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>);</span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### forEach()

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>); </span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);  </span><br><span class="line"><span class="comment">// 将会显示两个 logs。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot; </span></span><br><span class="line">myMap.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key</span>) </span>&#123;  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value); &#125;, myMap)</span><br></pre></td></tr></table></figure>

### Map 对象的操作

**Map 与 Array的转换**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> kvArray = [[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]];  </span><br><span class="line"><span class="comment">// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象 </span></span><br><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(kvArray);  </span><br><span class="line"><span class="comment">// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组 </span></span><br><span class="line"><span class="keyword">var</span> outArray = <span class="built_in">Array</span>.from(myMap);</span><br></pre></td></tr></table></figure>

**Map 的克隆**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]]); </span><br><span class="line"><span class="keyword">var</span> myMap2 = <span class="keyword">new</span> <span class="built_in">Map</span>(myMap1);  </span><br><span class="line"><span class="built_in">console</span>.log(original === clone);  </span><br><span class="line"><span class="comment">// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。</span></span><br></pre></td></tr></table></figure>

**Map 的合并**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],]); </span><br><span class="line"><span class="keyword">var</span> second = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;uno&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;dos&#x27;</span>]]); </span><br><span class="line"><span class="comment">// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three var merged = new Map([...first, ...second]);</span></span><br></pre></td></tr></table></figure>

## Set 对象

Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。

### Set 中的特殊值

Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：

- +0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；
- undefined 与 undefined 是恒等的，所以不重复；
- NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。

# ES6 字符串

ES6对于字符串本身的indexof来说增加了几个函数：

## 查找字符串

- **includes()**：返回布尔值，判断是否找到参数字符串。
- **startsWith()**：返回布尔值，判断参数字符串是否在原字符串的头部。
- **endsWith()**：返回布尔值，判断参数字符串是否在原字符串的尾部。

以上每个函数都可以接受两个参数，即需要搜索的字符串和起始位置。

### 字符串重复

repeat()：返回新的字符串，表示将字符串重复指定次数返回。

参数为重复的次数，如果是小数的话则按照去尾法（向下处理）处理，负数则会报错。

### 字符串补全

- **padStart**：返回新的字符串，表示用参数字符串从头部（左侧）补全原字符串。
- **padEnd**：返回新的字符串，表示用参数字符串从尾部（右侧）补全原字符串。

以上两个方法接受两个参数，第一个参数是指定生成的字符串的最小长度，第二个参数是用来补全的字符串。如果没有指定第二个参数，默认用空格填充。

例如：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;h&quot;</span>.padStart(<span class="number">5</span>,<span class="string">&quot;o&quot;</span>));  <span class="comment">// &quot;ooooh&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;h&quot;</span>.padEnd(<span class="number">5</span>,<span class="string">&quot;o&quot;</span>));    <span class="comment">// &quot;hoooo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;h&quot;</span>.padStart(<span class="number">5</span>));      <span class="comment">// &quot;    h&quot;</span></span><br></pre></td></tr></table></figure>

### 模板字符串

模板字符串相当于加强版的字符串，用反引号 **`**,除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。一般用来向字符串中插入变量。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Mike&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">let</span> info = <span class="string">`My Name is <span class="subst">$&#123;name&#125;</span>,I am <span class="subst">$&#123;age+<span class="number">1</span>&#125;</span> years old next year.`</span></span><br><span class="line"><span class="built_in">console</span>.log(info);</span><br><span class="line"><span class="comment">// My Name is Mike,I am 28 years old next year.</span></span><br></pre></td></tr></table></figure>

以及调用函数：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;have fun!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> string2= <span class="string">`Game start,<span class="subst">$&#123;f()&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string2);  <span class="comment">// Game start,have fun!</span></span><br></pre></td></tr></table></figure>

**注意要点**

模板字符串中的换行和空格都是会被保留的，意思是模板看起来是什么样的，他就会以什么样输出。

# ES6数值

二进制表示法新写法: 前缀 0b 或 0B 。

八进制表示法新写法: 前缀 0o 或 0O 。

## **Number 对象新方法**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite()<span class="comment">//检测数值是否为无限的</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt()<span class="comment">//进制转换，与全局的 parseInt() 函数是同一个函数，默认10进制。</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt(<span class="string">&#x27;0011&#x27;</span>,<span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

## Math 对象的扩展

新方法：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt<span class="comment">//计算一个数的立方根。</span></span><br><span class="line"><span class="built_in">Math</span>.imul<span class="comment">//返回两个数以 32 位带符号整数形式相乘的结果。</span></span><br><span class="line"><span class="built_in">Math</span>.hypot<span class="comment">//用于计算所有参数的平方和的平方根。</span></span><br><span class="line"><span class="built_in">Math</span>.trunc<span class="comment">//放回数字的整数部分。</span></span><br><span class="line"><span class="built_in">Math</span>.sign<span class="comment">//判断数字正负。</span></span><br><span class="line"><span class="built_in">Math</span>.clz32<span class="comment">//用于返回数字的32 位无符号整数形式的前导0的个数。</span></span><br><span class="line"><span class="built_in">Math</span>.fround<span class="comment">//获取数字的32为单精度浮点数形式。</span></span><br></pre></td></tr></table></figure>

# ES6 对象

### 属性的简洁表示法

ES6允许对象的属性直接写变量，这时候属性名是变量名，属性值是变量值。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Amy&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;age, name&#125;;</span><br><span class="line">person   <span class="comment">//&#123;age: 12, name: &quot;Amy&quot;&#125;</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">age</span>: age, <span class="attr">name</span>: name&#125;</span><br></pre></td></tr></table></figure>

方法名也可以简写：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

等同于

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">sayHi</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 属性名表达式

ES6允许用表达式作为属性名，但是一定要将表达式放在方括号内。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"> [<span class="string">&quot;he&quot;</span>+<span class="string">&quot;llo&quot;</span>]()&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.hello();  <span class="comment">//&quot;Hi&quot;//hello用表达式表示。</span></span><br></pre></td></tr></table></figure>

## 对象的拓展运算符

拓展运算符（...）用于取出参数对象所有可遍历属性然后拷贝到当前对象（相当于一个复制粘贴）。

### 基本用法

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>, <span class="attr">age</span>: <span class="number">15</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> someone = &#123; ...person &#125;; </span><br><span class="line">someone;  </span><br><span class="line"><span class="comment">//&#123;name: &quot;Amy&quot;, age: 15&#125;</span></span><br></pre></td></tr></table></figure>

### 可用于合并两个对象

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = &#123;<span class="attr">age</span>: <span class="number">15</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> name = &#123;<span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> person = &#123;...age, ...name&#125;; person;  </span><br><span class="line"><span class="comment">//&#123;age: 15, name: &quot;Amy&quot;&#125;</span></span><br></pre></td></tr></table></figure>

### 注意点

自定义的属性和拓展运算符对象里面属性的相同的时候，实际属性根据栈结构决定，即后面的会把前面的属性覆盖掉。

## 对象的新方法

**Object.assign(target, source_1, ···)**

用于将源对象的所有可枚举属性复制到目标对象中，相当于合并对象。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object2 = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object3 = &#123;<span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target,object2,object3);  </span><br><span class="line"><span class="comment">// 第一个参数是目标对象，后面的参数是源对象</span></span><br><span class="line">target;  <span class="comment">// &#123;a: 1, b: 2, c: 3</span></span><br></pre></td></tr></table></figure>

- 如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性（与拓展运算符相同）
- 如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。

### Object.is(value1, value2)

用来比较两个值是否严格相等，与（===）基本类似。

# ES6 数组

## 数组创建

**Array.of()**

将参数中所有值作为元素形成数组。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数值可为不同类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>, <span class="literal">true</span>)); <span class="comment">// [1, &#x27;2&#x27;, true]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数为空时返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of()); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

**Array.from()**

将类数组对象或可迭代对象转化为数组。

## 类数组对象

一个类数组对象必须含有 length 属性，且元素属性名必须是数值或者可转换为数值的字符。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(&#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, 3]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 没有 length 属性,则返回空数组</span></span><br><span class="line"><span class="keyword">let</span> array = <span class="built_in">Array</span>.from(&#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// []</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 元素属性名不为数值且无法转换为数值，返回长度为 length 元素值为 undefined 的数组  </span></span><br><span class="line"><span class="keyword">let</span> array1 = <span class="built_in">Array</span>.from(&#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array1); <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure>

## 扩展的方法

### 查找

**find()**；

查找数组中符合条件的元素,若有多个符合条件的元素，则返回第一个元素。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组空位处理为 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="number">1</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> <span class="literal">true</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

&gt; 关于箭头函数（=&gt;），ES6标准新增了一种新的函数：Arrow Function（箭头函数），相当于用item为参数定义了一个函数，然后返回item &gt; 2。

**findIndex()**

查找数组中符合条件的元素索引，若有多个符合条件的元素，则返回第一个元素索引。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 参数1：回调函数</span></span><br><span class="line"><span class="comment">// 参数2(可选)：指定回调函数中的 this 值</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item == <span class="number">2</span>)); <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组空位处理为 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="number">1</span>].findIndex(<span class="function"><span class="params">n</span> =&gt;</span> <span class="literal">true</span>)); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

### 填充

**fill()**

将一定范围索引的数组元素内容填充为单个指定的值。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 参数1：用来填充的值</span></span><br><span class="line"><span class="comment">// 参数2：被填充的起始索引</span></span><br><span class="line"><span class="comment">// 参数3(可选)：被填充的结束索引，默认为数组末尾</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.fill(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">// [1, 0, 3, 4]</span></span><br></pre></td></tr></table></figure>

### 遍历

**entries()**

遍历键值对。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不使用 for... of 循环</span></span><br><span class="line"><span class="keyword">let</span> entries = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, &quot;a&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, &quot;b&quot;]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组含空位</span></span><br><span class="line"><span class="built_in">console</span>.log([...[,<span class="string">&#x27;a&#x27;</span>].entries()]); <span class="comment">// [[0, undefined], [1, &quot;a&quot;]]</span></span><br></pre></td></tr></table></figure>

**keys()**

遍历键名。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组含空位</span></span><br><span class="line"><span class="built_in">console</span>.log([...[,<span class="string">&#x27;a&#x27;</span>].keys()]); <span class="comment">// [0, 1]</span></span><br></pre></td></tr></table></figure>

# ES6 函数

## 函数参数的扩展

### 默认参数

基本用法

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name,age=<span class="number">17</span></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(name+<span class="string">&quot;,&quot;</span>+age);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">&quot;Amy&quot;</span>,<span class="number">18</span>);  <span class="comment">// Amy,18</span></span><br><span class="line">fn(<span class="string">&quot;Amy&quot;</span>,<span class="string">&quot;&quot;</span>);  <span class="comment">// Amy,</span></span><br><span class="line">fn(<span class="string">&quot;Amy&quot;</span>);     <span class="comment">// Amy,17</span></span><br></pre></td></tr></table></figure>

&gt; 与我们平时的用法一致。

### 不定参数

不定参数用来表示不确定参数个数，形如，...变量名，由...加上一个具名参数标识符组成。具名参数只能放在参数组的最后，并且有且只有一个不定参数。

基本用法

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">...values</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(values.length);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>);      <span class="comment">//2</span></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);  <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

## 箭头函数

箭头函数提供了一种更加简洁的函数书写方式。基本语法是：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">参数 =&gt; 函数体</span><br></pre></td></tr></table></figure>

例如：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

当箭头函数没有参数或者有多个参数，要用 **()** 括起来。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b; f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">//8</span></span><br></pre></td></tr></table></figure>

当箭头函数函数体有多行语句，用 **&#123;&#125;** 包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略 **&#123;&#125;** , 结果会自动返回。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123; <span class="keyword">let</span> result = a+b; <span class="keyword">return</span> result; &#125; f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

当箭头函数要返回对象的时候，为了区分于代码块，要用 **()** 将对象包裹起来

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">id,name</span>) =&gt;</span> &#123;<span class="attr">id</span>: id, <span class="attr">name</span>: name&#125;; f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// SyntaxError: Unexpected token :  </span></span><br><span class="line"><span class="comment">// 不报错 var f = (id,name) =&gt; (&#123;id: id, name: name&#125;); f(6,2);  </span></span><br><span class="line"><span class="comment">// &#123;id: 6, name: 2&#125;</span></span><br></pre></td></tr></table></figure>

# ES6 Class 类

## 概述

在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。

class 的本质是 function。

它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。

## 基础用法

### 类定义

类表达式可以为匿名或命名。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名类</span></span><br><span class="line"><span class="keyword">let</span> Example = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 命名类</span></span><br><span class="line"><span class="keyword">let</span> Example = <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 类声明

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

注意，类定义不会被提升，这意味着，必须在访问前对类进行定义，否则就会报错。

类中方法不需要 function 关键字。

方法间不能加分号。

**方法**

constructor 方法

constructor 方法是类的默认方法，创建类的实例化对象时被调用。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;我是constructor&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Example(); <span class="comment">// 我是constructor</span></span><br></pre></td></tr></table></figure>

## 封装与继承

### getter / setter

定义

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a; <span class="comment">// 实例化时调用 set 方法</span></span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">a</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;getter&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">a</span>(<span class="params">a</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;setter&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.a = a; <span class="comment">// 自身递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> exam = <span class="keyword">new</span> Example(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 不断输出 setter ，最终导致 RangeError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">a</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;getter&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">a</span>(<span class="params">a</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;setter&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>._a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> exam1 = <span class="keyword">new</span> Example1(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 只输出 setter , 不会调用 getter 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(exam1._a); <span class="comment">// 1, 可以直接访问</span></span><br></pre></td></tr></table></figure>

### extends

通过 extends 实现类的继承。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

### super

子类 constructor 方法中必须有 super ，且必须出现在 this 之前。

调用父类方法, super 作为对象，在普通方法中，指向父类的原型对象，在静态方法中，指向父类

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// 调用父类普通方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">super</span>.test()); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">test3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类静态方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.test1+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Child2.test3(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

#  ES6 模块

## 特点

ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 **use strict;**。

模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。

每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。

每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----export [test.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> myfn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;My name is&quot;</span> + myName + <span class="string">&quot;! I&#x27;m &#x27;&quot;</span> + myAge + <span class="string">&quot;years old.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myClass =  <span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> a = <span class="string">&quot;yeah!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; myName, myAge, myfn, myClass &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName, myAge, myfn, myClass &#125; <span class="keyword">from</span> <span class="string">&quot;./test.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myfn());<span class="comment">// My name is Tom! I&#x27;m 20 years old.</span></span><br><span class="line"><span class="built_in">console</span>.log(myAge);<span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(myName);<span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(myClass.a );<span class="comment">// yeah!</span></span><br></pre></td></tr></table></figure>

### as 的用法

export 命令导出的接口名称，须和模块内部的变量有一一对应关系。

导入的变量名，须和导出的接口名称相同，即顺序可以不一致。

一般用于重新定义接口名称，隐藏模块内部的变量。 

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----export [test.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName <span class="keyword">as</span> exportName &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; exportName &#125; <span class="keyword">from</span> <span class="string">&quot;./test.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(exportName);<span class="comment">// Tom</span></span><br><span class="line">使用 <span class="keyword">as</span> 重新定义导出的接口名称，隐藏模块内部的变量</span><br><span class="line"><span class="comment">/*-----export [test1.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName &#125;</span><br><span class="line"><span class="comment">/*-----export [test2.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Jerry&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName &#125;</span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName <span class="keyword">as</span> name1 &#125; <span class="keyword">from</span> <span class="string">&quot;./test1.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; myName <span class="keyword">as</span> name2 &#125; <span class="keyword">from</span> <span class="string">&quot;./test2.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name1);<span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(name2);<span class="comment">// Jerry</span></span><br></pre></td></tr></table></figure>

### import 命令的特点

**只读属性**：不允许在加载模块的脚本里面，改写接口的引用指向，即可以改写 import 变量类型为对象的属性值，不能改写 import 变量类型为基本类型的值。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span></span><br><span class="line">a = &#123;&#125;; <span class="comment">// error</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span></span><br><span class="line">a.foo = <span class="string">&quot;hello&quot;</span>; <span class="comment">// a = &#123; foo : &#x27;hello&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

**单例模式**：多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。import 同一模块，声明不同接口引用，会声明对应变量，但只执行一次 import 。

### export default 命令

- 在一个文件或模块中，export、import 可以有多个，export default 仅有一个。
- export default 中的 default 是对应的导出接口变量。
- 通过 export 方式导出，在导入时要加&#123; &#125;，export default 则不需要。
- export default 向外暴露的成员，可以使用任意变量来接收。

# ES6 Promise 对象

## 概述

是异步编程的一种解决方案。

从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。

## Promise 状态

### 状态的特点

Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。

Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success1&#x27;</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;success2&#x27;</span>);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;  </span><br><span class="line">    resolve(<span class="string">&#x27;success3&#x27;</span>); </span><br><span class="line">    reject(<span class="string">&#x27;reject&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success1</span></span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

&gt; 已经忘记了promise函数？[点击我回顾](https://tosuke.gitee.io/2022/01/20/JavaScript%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/#Promise)

# ES6 Generator 函数

ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。 基本用法

### Generator 函数组成

Generator 有两个区分于普通函数的部分：

- 一是在 function 后面，函数名之前有个 * ；
- 函数内部有 yield 表达式。

其中 * 用来表示函数为 Generator 函数，yield 用来定义函数内部的状态。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;two&quot;</span>);</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;three&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 执行机制

调用 Generator 函数和调用普通函数一样，在函数名后面加上()即可，但是 Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针，所以要调用遍历器对象Iterator 的 next 方法，指针就会从函数头部或者上一次停下来的地方开始执行。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f.next();</span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;1&quot;, done: false&#125;</span></span><br><span class="line"> </span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line"> </span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// three</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;3&quot;, done: true&#125;</span></span><br><span class="line"> </span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

第一次调用 next 方法时，从 Generator 函数的头部开始执行，先是打印了 one ,执行到 yield 就停下来，并将yield 后边表达式的值 '1'，作为返回对象的 value 属性值，此时函数还没有执行完， 返回对象的 done 属性值是 false。

第二次调用 next 方法时，同上步 。

第三次调用 next 方法时，先是打印了 three ，然后执行了函数的返回操作，并将 return 后面的表达式的值，作为返回对象的 value 属性值，此时函数已经结束，多以 done 属性值为true 。

第四次调用 next 方法时， 此时函数已经执行完了，所以返回 value 属性值是 undefined ，done 属性值是 true 。如果执行第三步时，没有 return 语句的话，就直接返回 &#123;value: undefined, done: true&#125;。

# ES6 async 函数

## async

async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">[param[, param[, ... param]]]</span>) </span>&#123; statements &#125;</span><br></pre></td></tr></table></figure>

- name: 函数名称。
- param: 要传递给函数的参数的名称。
- statements: 函数体语句。

## 5.3 ES6 async 函数

### *分类* [ES6 教程](https://www.runoob.com/w3cnote_genre/es6)

## async

async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的。

### 语法

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function name([param[, param[, ... param]]]) &#123; statements &#125;</span><br></pre></td></tr></table></figure>

- name: 函数名称。
- param: 要传递给函数的参数的名称。
- statements: 函数体语句。

### 返回值

async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;helloAsync&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(helloAsync())  <span class="comment">// Promise &#123;&lt;resolved&gt;: &quot;helloAsync&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line">helloAsync().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(v);         <span class="comment">// helloAsync</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

# Symbol

一种新引入的原始数据类型，表示独一无二的值，定义对象的唯一属性名，另外，ES6所有的数据类型为Number 、 String 、 Boolean 、 Object、 null 和 undefined ，还新增了 Symbol。

## 用法

定义：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy=<span class="built_in">Symbol</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"><span class="comment">//其中的xxx为描述symbol的内容，便于区分不同的symbol类型。</span></span><br></pre></td></tr></table></figure>

不同的写法：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法1</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;&#125;;</span><br><span class="line">syObject[sy] = <span class="string">&quot;kk&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(syObject);    <span class="comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;</span><br><span class="line">  [sy]: <span class="string">&quot;kk&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(syObject);    <span class="comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法3</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(syObject, sy, &#123;<span class="attr">value</span>: <span class="string">&quot;kk&quot;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(syObject);   <span class="comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span></span><br></pre></td></tr></table></figure>

## 特点

使用 Symbol 定义常量，这样就可以保证一组常量的值都不相等。避免引发选择错误。

## 方法

### Symbol.for()

会全局搜索是否有含有参数值的symbol类型数据，如果没有将会创造一个新的symbol并登记供搜索（以普通的方法构造的symbol不会被搜索到）。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yellow = <span class="built_in">Symbol</span>(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> yellow1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">yellow === yellow1;      <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> yellow2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">yellow1 === yellow2;     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

### Symbol.keyFor()

直接返回一个Symbol的key值，参数为symbol类型的名称。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yellow1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(yellow1);    <span class="comment">// &quot;Yellow&quot;</span></span><br></pre></td></tr></table></figure>

# Map 与 Set

Map对象保存键值对，任何对象或是原始值都可以作为一个键或者一个值。可以说，Map比object做的更加彻底，从另一方面来说也印证了随着时代的发展，编程的语法将会不再那么严格，会变得越来越简单，学编程的成本也会大幅下降。

## Maps 和 Objects 的区别

- 一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。
- Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。
- Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。
- Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。

![图片来自菜鸟教程](E:/BaiduNetdiskWorkspace/source/image-20220321090356352.png)

## 用法

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mymap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">var</span> key=<span class="string">&quot;key`s value&quot;</span></span><br><span class="line">mymap.set(key,<span class="string">&quot;value&quot;</span>);<span class="comment">//值不一定是字符串。</span></span><br><span class="line">mymap.get(key);<span class="comment">//mymap.get(&quot;key`s value&quot;)相同。</span></span><br></pre></td></tr></table></figure>

下面来列举几个Map键值对中的key是其他类型的例子：

**key是字符串：**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">var</span> keyString = <span class="string">&quot;a string&quot;</span>; </span><br><span class="line"> </span><br><span class="line">myMap.set(keyString, <span class="string">&quot;和键&#x27;a string&#x27;关联的值&quot;</span>);</span><br><span class="line"> </span><br><span class="line">myMap.get(keyString);    <span class="comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span></span><br><span class="line">myMap.get(<span class="string">&quot;a string&quot;</span>);   <span class="comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span></span><br><span class="line">                         <span class="comment">// 因为 keyString === &#x27;a string&#x27;</span></span><br></pre></td></tr></table></figure>

**key 是对象**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line"><span class="keyword">var</span> keyObj = &#123;&#125;,   </span><br><span class="line"> myMap.set(keyObj, <span class="string">&quot;和键 keyObj 关联的值&quot;</span>);  myMap.get(keyObj); <span class="comment">// &quot;和键 keyObj 关联的值&quot; myMap.get(&#123;&#125;); // undefined, 因为 keyObj !== &#123;&#125;</span></span><br></pre></td></tr></table></figure>

**key 是函数**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line"><span class="keyword">var</span> keyFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,  </span><br><span class="line">    <span class="comment">//函数  myMap.set(keyFunc, &quot;和键 keyFunc 关联的值&quot;);  myMap.get(keyFunc); </span></span><br><span class="line">    <span class="comment">// &quot;和键 keyFunc 关联的值&quot; myMap.get(function() &#123;&#125;) </span></span><br><span class="line">    <span class="comment">// undefined, 因为 keyFunc !== function () &#123;&#125;</span></span><br></pre></td></tr></table></figure>

**key 是 NaN**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line">myMap.set(<span class="literal">NaN</span>, <span class="string">&quot;not a number&quot;</span>);  </span><br><span class="line">myMap.get(<span class="literal">NaN</span>); </span><br><span class="line"><span class="comment">// &quot;not a number&quot;  var otherNaN = Number(&quot;foo&quot;); myMap.get(otherNaN); </span></span><br><span class="line"><span class="comment">// &quot;not a number&quot;</span></span><br></pre></td></tr></table></figure>

虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，NaN作为Map的键来说是没有区别的。

**Map的迭代**

1、for...of

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>);</span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在for循环中使用key和value的组用of对map进行迭代。</span></span><br></pre></td></tr></table></figure>

被在for中用of进行迭代的对象不只是map对象，还有myMap.entries()、myMap.keys()、myMap.values()

等方法。

### Map 对象的操作

**Map 与 Array的转换**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> kvArray = [[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象</span></span><br><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(kvArray);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组</span></span><br><span class="line"><span class="keyword">var</span> outArray = <span class="built_in">Array</span>.from(myMap);</span><br></pre></td></tr></table></figure>

**Map 的克隆**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]]);</span><br><span class="line"><span class="keyword">var</span> myMap2 = <span class="keyword">new</span> <span class="built_in">Map</span>(myMap1);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(original === clone); </span><br><span class="line"><span class="comment">// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。</span></span><br></pre></td></tr></table></figure>

**Map 的合并**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],]);</span><br><span class="line"><span class="keyword">var</span> second = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;uno&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;dos&#x27;</span>]]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three</span></span><br><span class="line"><span class="keyword">var</span> merged = <span class="keyword">new</span> <span class="built_in">Map</span>([...first, ...second]);</span><br></pre></td></tr></table></figure>

### Map 的迭代

对 Map 进行遍历，以下两个最高级。

#### for...of

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>);</span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### forEach()

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>); </span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);  </span><br><span class="line"><span class="comment">// 将会显示两个 logs。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot; </span></span><br><span class="line">myMap.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key</span>) </span>&#123;  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value); &#125;, myMap)</span><br></pre></td></tr></table></figure>

### Map 对象的操作

**Map 与 Array的转换**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> kvArray = [[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]];  </span><br><span class="line"><span class="comment">// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象 </span></span><br><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(kvArray);  </span><br><span class="line"><span class="comment">// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组 </span></span><br><span class="line"><span class="keyword">var</span> outArray = <span class="built_in">Array</span>.from(myMap);</span><br></pre></td></tr></table></figure>

**Map 的克隆**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]]); </span><br><span class="line"><span class="keyword">var</span> myMap2 = <span class="keyword">new</span> <span class="built_in">Map</span>(myMap1);  </span><br><span class="line"><span class="built_in">console</span>.log(original === clone);  </span><br><span class="line"><span class="comment">// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。</span></span><br></pre></td></tr></table></figure>

**Map 的合并**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],]); </span><br><span class="line"><span class="keyword">var</span> second = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;uno&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;dos&#x27;</span>]]); </span><br><span class="line"><span class="comment">// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three var merged = new Map([...first, ...second]);</span></span><br></pre></td></tr></table></figure>

## Set 对象

Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。

### Set 中的特殊值

Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：

- +0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；
- undefined 与 undefined 是恒等的，所以不重复；
- NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。

# ES6 字符串

ES6对于字符串本身的indexof来说增加了几个函数：

## 查找字符串

- **includes()**：返回布尔值，判断是否找到参数字符串。
- **startsWith()**：返回布尔值，判断参数字符串是否在原字符串的头部。
- **endsWith()**：返回布尔值，判断参数字符串是否在原字符串的尾部。

以上每个函数都可以接受两个参数，即需要搜索的字符串和起始位置。

### 字符串重复

repeat()：返回新的字符串，表示将字符串重复指定次数返回。

参数为重复的次数，如果是小数的话则按照去尾法（向下处理）处理，负数则会报错。

### 字符串补全

- **padStart**：返回新的字符串，表示用参数字符串从头部（左侧）补全原字符串。
- **padEnd**：返回新的字符串，表示用参数字符串从尾部（右侧）补全原字符串。

以上两个方法接受两个参数，第一个参数是指定生成的字符串的最小长度，第二个参数是用来补全的字符串。如果没有指定第二个参数，默认用空格填充。

例如：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;h&quot;</span>.padStart(<span class="number">5</span>,<span class="string">&quot;o&quot;</span>));  <span class="comment">// &quot;ooooh&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;h&quot;</span>.padEnd(<span class="number">5</span>,<span class="string">&quot;o&quot;</span>));    <span class="comment">// &quot;hoooo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;h&quot;</span>.padStart(<span class="number">5</span>));      <span class="comment">// &quot;    h&quot;</span></span><br></pre></td></tr></table></figure>

### 模板字符串

模板字符串相当于加强版的字符串，用反引号 **`**,除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。一般用来向字符串中插入变量。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Mike&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">let</span> info = <span class="string">`My Name is <span class="subst">$&#123;name&#125;</span>,I am <span class="subst">$&#123;age+<span class="number">1</span>&#125;</span> years old next year.`</span></span><br><span class="line"><span class="built_in">console</span>.log(info);</span><br><span class="line"><span class="comment">// My Name is Mike,I am 28 years old next year.</span></span><br></pre></td></tr></table></figure>

以及调用函数：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;have fun!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> string2= <span class="string">`Game start,<span class="subst">$&#123;f()&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string2);  <span class="comment">// Game start,have fun!</span></span><br></pre></td></tr></table></figure>

**注意要点**

模板字符串中的换行和空格都是会被保留的，意思是模板看起来是什么样的，他就会以什么样输出。

# ES6数值

二进制表示法新写法: 前缀 0b 或 0B 。

八进制表示法新写法: 前缀 0o 或 0O 。

## **Number 对象新方法**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite()<span class="comment">//检测数值是否为无限的</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt()<span class="comment">//进制转换，与全局的 parseInt() 函数是同一个函数，默认10进制。</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt(<span class="string">&#x27;0011&#x27;</span>,<span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

## Math 对象的扩展

新方法：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt<span class="comment">//计算一个数的立方根。</span></span><br><span class="line"><span class="built_in">Math</span>.imul<span class="comment">//返回两个数以 32 位带符号整数形式相乘的结果。</span></span><br><span class="line"><span class="built_in">Math</span>.hypot<span class="comment">//用于计算所有参数的平方和的平方根。</span></span><br><span class="line"><span class="built_in">Math</span>.trunc<span class="comment">//放回数字的整数部分。</span></span><br><span class="line"><span class="built_in">Math</span>.sign<span class="comment">//判断数字正负。</span></span><br><span class="line"><span class="built_in">Math</span>.clz32<span class="comment">//用于返回数字的32 位无符号整数形式的前导0的个数。</span></span><br><span class="line"><span class="built_in">Math</span>.fround<span class="comment">//获取数字的32为单精度浮点数形式。</span></span><br></pre></td></tr></table></figure>

# ES6 对象

### 属性的简洁表示法

ES6允许对象的属性直接写变量，这时候属性名是变量名，属性值是变量值。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Amy&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;age, name&#125;;</span><br><span class="line">person   <span class="comment">//&#123;age: 12, name: &quot;Amy&quot;&#125;</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">age</span>: age, <span class="attr">name</span>: name&#125;</span><br></pre></td></tr></table></figure>

方法名也可以简写：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

等同于

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">sayHi</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 属性名表达式

ES6允许用表达式作为属性名，但是一定要将表达式放在方括号内。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"> [<span class="string">&quot;he&quot;</span>+<span class="string">&quot;llo&quot;</span>]()&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.hello();  <span class="comment">//&quot;Hi&quot;//hello用表达式表示。</span></span><br></pre></td></tr></table></figure>

## 对象的拓展运算符

拓展运算符（...）用于取出参数对象所有可遍历属性然后拷贝到当前对象（相当于一个复制粘贴）。

### 基本用法

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>, <span class="attr">age</span>: <span class="number">15</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> someone = &#123; ...person &#125;; </span><br><span class="line">someone;  </span><br><span class="line"><span class="comment">//&#123;name: &quot;Amy&quot;, age: 15&#125;</span></span><br></pre></td></tr></table></figure>

### 可用于合并两个对象

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = &#123;<span class="attr">age</span>: <span class="number">15</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> name = &#123;<span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>&#125;; </span><br><span class="line"><span class="keyword">let</span> person = &#123;...age, ...name&#125;; person;  </span><br><span class="line"><span class="comment">//&#123;age: 15, name: &quot;Amy&quot;&#125;</span></span><br></pre></td></tr></table></figure>

### 注意点

自定义的属性和拓展运算符对象里面属性的相同的时候，实际属性根据栈结构决定，即后面的会把前面的属性覆盖掉。

## 对象的新方法

**Object.assign(target, source_1, ···)**

用于将源对象的所有可枚举属性复制到目标对象中，相当于合并对象。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object2 = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object3 = &#123;<span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target,object2,object3);  </span><br><span class="line"><span class="comment">// 第一个参数是目标对象，后面的参数是源对象</span></span><br><span class="line">target;  <span class="comment">// &#123;a: 1, b: 2, c: 3</span></span><br></pre></td></tr></table></figure>

- 如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性（与拓展运算符相同）
- 如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。

### Object.is(value1, value2)

用来比较两个值是否严格相等，与（===）基本类似。

# ES6 数组

## 数组创建

**Array.of()**

将参数中所有值作为元素形成数组。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数值可为不同类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>, <span class="literal">true</span>)); <span class="comment">// [1, &#x27;2&#x27;, true]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数为空时返回空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of()); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

**Array.from()**

将类数组对象或可迭代对象转化为数组。

## 类数组对象

一个类数组对象必须含有 length 属性，且元素属性名必须是数值或者可转换为数值的字符。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(&#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, 3]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 没有 length 属性,则返回空数组</span></span><br><span class="line"><span class="keyword">let</span> array = <span class="built_in">Array</span>.from(&#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// []</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 元素属性名不为数值且无法转换为数值，返回长度为 length 元素值为 undefined 的数组  </span></span><br><span class="line"><span class="keyword">let</span> array1 = <span class="built_in">Array</span>.from(&#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array1); <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure>

## 扩展的方法

### 查找

**find()**；

查找数组中符合条件的元素,若有多个符合条件的元素，则返回第一个元素。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组空位处理为 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="number">1</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> <span class="literal">true</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

&gt; 关于箭头函数（=&gt;），ES6标准新增了一种新的函数：Arrow Function（箭头函数），相当于用item为参数定义了一个函数，然后返回item &gt; 2。

**findIndex()**

查找数组中符合条件的元素索引，若有多个符合条件的元素，则返回第一个元素索引。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 参数1：回调函数</span></span><br><span class="line"><span class="comment">// 参数2(可选)：指定回调函数中的 this 值</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item == <span class="number">2</span>)); <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组空位处理为 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log([, <span class="number">1</span>].findIndex(<span class="function"><span class="params">n</span> =&gt;</span> <span class="literal">true</span>)); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

### 填充

**fill()**

将一定范围索引的数组元素内容填充为单个指定的值。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 参数1：用来填充的值</span></span><br><span class="line"><span class="comment">// 参数2：被填充的起始索引</span></span><br><span class="line"><span class="comment">// 参数3(可选)：被填充的结束索引，默认为数组末尾</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.fill(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">// [1, 0, 3, 4]</span></span><br></pre></td></tr></table></figure>

### 遍历

**entries()**

遍历键值对。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不使用 for... of 循环</span></span><br><span class="line"><span class="keyword">let</span> entries = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, &quot;a&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, &quot;b&quot;]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组含空位</span></span><br><span class="line"><span class="built_in">console</span>.log([...[,<span class="string">&#x27;a&#x27;</span>].entries()]); <span class="comment">// [[0, undefined], [1, &quot;a&quot;]]</span></span><br></pre></td></tr></table></figure>

**keys()**

遍历键名。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组含空位</span></span><br><span class="line"><span class="built_in">console</span>.log([...[,<span class="string">&#x27;a&#x27;</span>].keys()]); <span class="comment">// [0, 1]</span></span><br></pre></td></tr></table></figure>

# ES6 函数

## 函数参数的扩展

### 默认参数

基本用法

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name,age=<span class="number">17</span></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(name+<span class="string">&quot;,&quot;</span>+age);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">&quot;Amy&quot;</span>,<span class="number">18</span>);  <span class="comment">// Amy,18</span></span><br><span class="line">fn(<span class="string">&quot;Amy&quot;</span>,<span class="string">&quot;&quot;</span>);  <span class="comment">// Amy,</span></span><br><span class="line">fn(<span class="string">&quot;Amy&quot;</span>);     <span class="comment">// Amy,17</span></span><br></pre></td></tr></table></figure>

&gt; 与我们平时的用法一致。

### 不定参数

不定参数用来表示不确定参数个数，形如，...变量名，由...加上一个具名参数标识符组成。具名参数只能放在参数组的最后，并且有且只有一个不定参数。

基本用法

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">...values</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(values.length);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>);      <span class="comment">//2</span></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);  <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

## 箭头函数

箭头函数提供了一种更加简洁的函数书写方式。基本语法是：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">参数 =&gt; 函数体</span><br></pre></td></tr></table></figure>

例如：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

当箭头函数没有参数或者有多个参数，要用 **()** 括起来。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b; f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">//8</span></span><br></pre></td></tr></table></figure>

当箭头函数函数体有多行语句，用 **&#123;&#125;** 包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略 **&#123;&#125;** , 结果会自动返回。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123; <span class="keyword">let</span> result = a+b; <span class="keyword">return</span> result; &#125; f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

当箭头函数要返回对象的时候，为了区分于代码块，要用 **()** 将对象包裹起来

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">id,name</span>) =&gt;</span> &#123;<span class="attr">id</span>: id, <span class="attr">name</span>: name&#125;; f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// SyntaxError: Unexpected token :  </span></span><br><span class="line"><span class="comment">// 不报错 var f = (id,name) =&gt; (&#123;id: id, name: name&#125;); f(6,2);  </span></span><br><span class="line"><span class="comment">// &#123;id: 6, name: 2&#125;</span></span><br></pre></td></tr></table></figure>

# ES6 Class 类

## 概述

在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。

class 的本质是 function。

它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。

## 基础用法

### 类定义

类表达式可以为匿名或命名。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名类</span></span><br><span class="line"><span class="keyword">let</span> Example = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 命名类</span></span><br><span class="line"><span class="keyword">let</span> Example = <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 类声明

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

注意，类定义不会被提升，这意味着，必须在访问前对类进行定义，否则就会报错。

类中方法不需要 function 关键字。

方法间不能加分号。

**方法**

constructor 方法

constructor 方法是类的默认方法，创建类的实例化对象时被调用。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;我是constructor&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Example(); <span class="comment">// 我是constructor</span></span><br></pre></td></tr></table></figure>

## 封装与继承

### getter / setter

定义

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a; <span class="comment">// 实例化时调用 set 方法</span></span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">a</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;getter&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">a</span>(<span class="params">a</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;setter&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.a = a; <span class="comment">// 自身递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> exam = <span class="keyword">new</span> Example(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 不断输出 setter ，最终导致 RangeError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">a</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;getter&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">a</span>(<span class="params">a</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;setter&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>._a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> exam1 = <span class="keyword">new</span> Example1(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 只输出 setter , 不会调用 getter 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(exam1._a); <span class="comment">// 1, 可以直接访问</span></span><br></pre></td></tr></table></figure>

### extends

通过 extends 实现类的继承。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

### super

子类 constructor 方法中必须有 super ，且必须出现在 this 之前。

调用父类方法, super 作为对象，在普通方法中，指向父类的原型对象，在静态方法中，指向父类

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// 调用父类普通方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">super</span>.test()); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">test3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类静态方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.test1+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Child2.test3(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

#  ES6 模块

## 特点

ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 **use strict;**。

模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。

每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。

每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----export [test.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> myfn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;My name is&quot;</span> + myName + <span class="string">&quot;! I&#x27;m &#x27;&quot;</span> + myAge + <span class="string">&quot;years old.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myClass =  <span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> a = <span class="string">&quot;yeah!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; myName, myAge, myfn, myClass &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName, myAge, myfn, myClass &#125; <span class="keyword">from</span> <span class="string">&quot;./test.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myfn());<span class="comment">// My name is Tom! I&#x27;m 20 years old.</span></span><br><span class="line"><span class="built_in">console</span>.log(myAge);<span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(myName);<span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(myClass.a );<span class="comment">// yeah!</span></span><br></pre></td></tr></table></figure>

### as 的用法

export 命令导出的接口名称，须和模块内部的变量有一一对应关系。

导入的变量名，须和导出的接口名称相同，即顺序可以不一致。

一般用于重新定义接口名称，隐藏模块内部的变量。 

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----export [test.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName <span class="keyword">as</span> exportName &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; exportName &#125; <span class="keyword">from</span> <span class="string">&quot;./test.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(exportName);<span class="comment">// Tom</span></span><br><span class="line">使用 <span class="keyword">as</span> 重新定义导出的接口名称，隐藏模块内部的变量</span><br><span class="line"><span class="comment">/*-----export [test1.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName &#125;</span><br><span class="line"><span class="comment">/*-----export [test2.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Jerry&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName &#125;</span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName <span class="keyword">as</span> name1 &#125; <span class="keyword">from</span> <span class="string">&quot;./test1.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; myName <span class="keyword">as</span> name2 &#125; <span class="keyword">from</span> <span class="string">&quot;./test2.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name1);<span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(name2);<span class="comment">// Jerry</span></span><br></pre></td></tr></table></figure>

### import 命令的特点

**只读属性**：不允许在加载模块的脚本里面，改写接口的引用指向，即可以改写 import 变量类型为对象的属性值，不能改写 import 变量类型为基本类型的值。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span></span><br><span class="line">a = &#123;&#125;; <span class="comment">// error</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span></span><br><span class="line">a.foo = <span class="string">&quot;hello&quot;</span>; <span class="comment">// a = &#123; foo : &#x27;hello&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

**单例模式**：多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。import 同一模块，声明不同接口引用，会声明对应变量，但只执行一次 import 。

### export default 命令

- 在一个文件或模块中，export、import 可以有多个，export default 仅有一个。
- export default 中的 default 是对应的导出接口变量。
- 通过 export 方式导出，在导入时要加&#123; &#125;，export default 则不需要。
- export default 向外暴露的成员，可以使用任意变量来接收。

# ES6 Promise 对象

## 概述

是异步编程的一种解决方案。

从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。

## Promise 状态

### 状态的特点

Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。

Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success1&#x27;</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;success2&#x27;</span>);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;  </span><br><span class="line">    resolve(<span class="string">&#x27;success3&#x27;</span>); </span><br><span class="line">    reject(<span class="string">&#x27;reject&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success1</span></span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

&gt; 已经忘记了promise函数？[点击我回顾](https://tosuke.gitee.io/2022/01/20/JavaScript%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/#Promise)

# ES6 Generator 函数

ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。 基本用法

### Generator 函数组成

Generator 有两个区分于普通函数的部分：

- 一是在 function 后面，函数名之前有个 * ；
- 函数内部有 yield 表达式。

其中 * 用来表示函数为 Generator 函数，yield 用来定义函数内部的状态。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;two&quot;</span>);</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;three&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 执行机制

调用 Generator 函数和调用普通函数一样，在函数名后面加上()即可，但是 Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针，所以要调用遍历器对象Iterator 的 next 方法，指针就会从函数头部或者上一次停下来的地方开始执行。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f.next();</span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;1&quot;, done: false&#125;</span></span><br><span class="line"> </span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line"> </span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// three</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;3&quot;, done: true&#125;</span></span><br><span class="line"> </span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

第一次调用 next 方法时，从 Generator 函数的头部开始执行，先是打印了 one ,执行到 yield 就停下来，并将yield 后边表达式的值 '1'，作为返回对象的 value 属性值，此时函数还没有执行完， 返回对象的 done 属性值是 false。

第二次调用 next 方法时，同上步 。

第三次调用 next 方法时，先是打印了 three ，然后执行了函数的返回操作，并将 return 后面的表达式的值，作为返回对象的 value 属性值，此时函数已经结束，多以 done 属性值为true 。

第四次调用 next 方法时， 此时函数已经执行完了，所以返回 value 属性值是 undefined ，done 属性值是 true 。如果执行第三步时，没有 return 语句的话，就直接返回 &#123;value: undefined, done: true&#125;。

# ES6 async 函数

## async

async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">[param[, param[, ... param]]]</span>) </span>&#123; statements &#125;</span><br></pre></td></tr></table></figure>

- name: 函数名称。
- param: 要传递给函数的参数的名称。
- statements: 函数体语句。

## 5.3 ES6 async 函数

### *分类* [ES6 教程](https://www.runoob.com/w3cnote_genre/es6)

## async

async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的。

### 语法

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function name([param[, param[, ... param]]]) &#123; statements &#125;</span><br></pre></td></tr></table></figure>

- name: 函数名称。
- param: 要传递给函数的参数的名称。
- statements: 函数体语句。

### 返回值

async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;helloAsync&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(helloAsync())  <span class="comment">// Promise &#123;&lt;resolved&gt;: &quot;helloAsync&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line">helloAsync().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(v);         <span class="comment">// helloAsync</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE的部分要点</title>
    <url>/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/</url>
    <content><![CDATA[<h1>scanner</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">scanner.hasnextline()  <span class="comment">//判断是否还有输入</span></span><br></pre></td></tr></table></figure>
<p>next（）与nextLine（）的区别；</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208161159615.png" alt="image-20211208161159615"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sacanner.nextLine(); <span class="comment">//可以接受空白，以回车为结束。</span></span><br><span class="line">scanner.close();   <span class="comment">//关闭scanner</span></span><br></pre></td></tr></table></figure>
<h1>增强for循环</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x:数组名)&#123;</span><br><span class="line">  system.out.println(x);</span><br><span class="line">  <span class="comment">//遍历数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>给main函数传递参数</h1>
<p>找到包的路径下，在命令行中进行编译，运行。</p>
<h1>可变参数</h1>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208164227825.png" alt="image-20211208164227825"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>... i)</span></span>&#123;</span><br><span class="line"> system.out.println(i[]);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//此时i为可变参数，可输入多个值,i也就可能成为一个数组。</span></span><br></pre></td></tr></table></figure>
<h1>递归</h1>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208164910624.png" alt="image-20211208164910624"></p>
<h1>继承和多态</h1>
<p>静态方法是类的方法，非静态的方法是对象的方法。</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208211748858.png" alt="image-20211208211748858"></p>
<p>我们的person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我开动了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>student类继承person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">student</span> <span class="keyword">extends</span> <span class="title">person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生的事怎么能叫吃呢？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我要学习了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>text类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">texi1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        student  s1=<span class="keyword">new</span> student();</span><br><span class="line">        person s2=<span class="keyword">new</span> student();</span><br><span class="line">s1.eat();</span><br><span class="line">s2.eat();</span><br><span class="line">s1.learn();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208215628894.png" alt="image-20211208215628894"></p>
<h2 id="多态（只针对方法）：">多态（只针对方法）：</h2>
<p>同一方法可以根据发送对象的不同采取多种不同的行为方式，一个对象的实际类型是知道的，但指向对象的引用类型有很多，比如父类的引用指向了子类的对象。</p>
<p>执行方法先看类里面的静态方法（静态方法属于类的，不属于对象），再看对象实际类型对应的方法。</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208214431807.png" alt="image-20211208214431807"></p>
<h1>instanceof与类型转换</h1>
<p>instanceof会判断两个类的继承关系，兄弟关系则会报错。</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209175621741.png" alt="image-20211209175621741"></p>
<p><em>底类转高类不需要强制转换。</em></p>
<p><em>高类转底类需要进行强制转换</em></p>
<p>子类转换为父类可能会丢失一些方法（子类te’you）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object s1 = <span class="keyword">new</span> student(); </span><br><span class="line"><span class="comment">//底类转高类不需要强制转换</span></span><br><span class="line">person s2 = (student) s1;          <span class="comment">//高类转底类需要进行强制转换</span></span><br><span class="line">s2.eat();</span><br><span class="line">student s3 = (student) s2;</span><br><span class="line">s3.eat();</span><br><span class="line">s3.learn();</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209182350137.png" alt="image-20211209182350137"></p>
<blockquote>
<p>这里插入一个我突然看到的，对于对象和实例区别的一个例子：</p>
<p>父母口中的女朋友（对象），怀里搂着的她（实例）。</p>
<p>（精辟无敌）</p>
</blockquote>
<h1>抽象类与接口</h1>
<h2 id="抽象类">抽象类</h2>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209182856546.png" alt="image-20211209182856546"></p>
<blockquote>
<p>抽象类：给予类约束，让其他人帮我们实现。继承了抽象类的类必须重写抽象类所有的抽象方法（除非自己也是抽象类）。我们一般把他们叫做资本家与被压榨的苦力。</p>
</blockquote>
<p>生成一个抽象类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 资本家 </span>&#123;</span><br><span class="line">    <span class="comment">//来帮我写个方法,我只给需求，我就不写了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">ganfan</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以及一个苦力：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 被压榨的苦力 <span class="keyword">extends</span> 资本家 </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ganfan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我为老板冲锋陷阵！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        被压榨的苦力 苦力<span class="number">1</span> = <span class="keyword">new</span> 被压榨的苦力();</span><br><span class="line">        苦力<span class="number">1.</span>ganfan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209184432977.png" alt="image-20211209184432977"></p>
<h2 id="接口">接口</h2>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209184503107.png" alt="image-20211209184503107"></p>
<p>接口全是抽象方法还有静态常量，只有由别人实现。即接口全是要求，资本家自愧不如。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">service</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有对象皆抽象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> speed)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">get</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> age=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个类实现两个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">serviceimpl</span> <span class="keyword">implements</span> <span class="title">service</span>,<span class="title">get</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lost</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用接口实现多继承,接口不能被实例化~接口中没有构造方法。</p>
<h1>内部类</h1>
<h2 id="成员内部类">成员内部类</h2>
<p>定义一个内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外面的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">in</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是里面的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个内部对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        text t1 = <span class="keyword">new</span> text();</span><br><span class="line">        text.in in1 = t1.<span class="function">new <span class="title">in</span><span class="params">()</span></span>;</span><br><span class="line">        t1.out();</span><br><span class="line">        in1.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209190853396.png" alt="image-20211209190853396"></p>
<p><strong>内部类可以操纵外部类的私有属性，这是它的特点（毕竟是亲生的）。</strong></p>
<h2 id="静态内部类">静态内部类</h2>
<p>也就是定义内部类时加上static，需要时注意的是，如果内部类被静态化，那么这个静态内部类也许就不能访问外部类的私有属性了（静态内部类相当于预加载），除非该私有属性也是静态的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外面的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">in</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是里面的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="局部内部类">局部内部类</h2>
<p>在方法里定义的类（类如局部变量）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">in</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是里面的&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外面的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类">匿名内部类</h2>
<p>new出来直接用，没有名字初始类，不用将实例保存到类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        id=<span class="keyword">new</span> Scanner().nextInt();</span><br><span class="line">        <span class="comment">//没有创建scanner类.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>异常机制</h1>
<h2 id="异常">异常</h2>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209193513675.png" alt="image-20211209193513675"></p>
<p><strong>异常也是一种对象</strong></p>
<p>当遇到异常或者是错误时，Java会抛出异常对象，可以对其进行捕获处理（尤其是异常）。</p>
<h2 id="异常处理">异常处理</h2>
<h3 id="五个关键字">五个关键字</h3>
<p>try:尝试捕获异常的监控区。</p>
<p>catch：捕获异常（括号里为想要捕获的异常类型）。</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211210195637949.png" alt="image-20211210195637949"></p>
<p>finally：无论执不执行最后都要走的（一般用于善后工作）。</p>
<p>throw：主动抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException();</span><br></pre></td></tr></table></figure>
<p>throws：方法调用时抛出，</p>
<p>写个报错程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(b/a);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;有问题&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;<span class="comment">//善后处理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ctrl+alt+t可以快速构造代码块框架，包括try|catch语句。</p>
</blockquote>
<p>输出：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211210201559270.png" alt="image-20211210201559270"></p>
<h2 id="自定义异常">自定义异常</h2>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211210202529797.png" alt="image-20211210202529797"></p>
<p>比如数字大于10，我们设计的异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myexception</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> detali;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Myexception</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.detali=a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Myexception&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;detali=&quot;</span> + detali +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="number">11</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Myexception e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> Myexception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Myexception(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;正常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211210203653004.png" alt="image-20211210203653004"></p>
<h1>结束</h1>
<p>JavaSE大体部分就到此结束！</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-BOM</title>
    <url>/2022/01/28/JavaScript-BOM/</url>
    <content><![CDATA[<h1>浏览器对象模型（<strong>B</strong>rowser <strong>O</strong>bject <strong>M</strong>odel (BOM)）</h1>
<p>浏览器对象模型 (BOM) 使 JavaScript 有能力与浏览器&quot;对话&quot;，指的是js与我们面向的浏览器的对话，所有浏览器都支持 window 对象。它表示浏览器窗口。</p>
<p>所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。</p>
<p>全局变量是 window 对象的属性。</p>
<p>全局函数是 window 对象的方法。</p>
<p>HTML DOM 的 document 也是 window 对象的属性之一：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.document.getElementById(<span class="string">&quot;header&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>我们平时写的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;header&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>是与之相同的语句。</p>
<h1>Window 尺寸</h1>
<p>有三种方法能够确定浏览器窗口的尺寸。</p>
<p>对于Internet Explorer、Chrome、Firefox、Opera 以及 Safari：</p>
<ul>
<li>window.innerHeight - 浏览器窗口的内部高度(包括滚动条)</li>
<li>window.innerWidth - 浏览器窗口的内部宽度(包括滚动条)</li>
</ul>
<p>对于 ：</p>
<ul>
<li>document.documentElement.clientHeight</li>
<li>document.documentElement.clientWidth</li>
</ul>
<p>或者</p>
<ul>
<li>document.body.clientHeight</li>
<li>document.body.clientWidth</li>
</ul>
<p>故我们可以写出一个对于所有的浏览器通用的输出显示浏览器窗口的高度和宽度的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> w=<span class="built_in">window</span>.innerWidth</span><br><span class="line">      || <span class="built_in">document</span>.documentElement.clientWidth</span><br><span class="line">      || <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line"><span class="keyword">var</span> h=<span class="built_in">window</span>.innerHeight</span><br><span class="line">      || <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">      || <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">x=<span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">x.innerHTML=<span class="string">&quot;浏览器window宽度: &quot;</span> + w + <span class="string">&quot;, 高度: &quot;</span> + h + <span class="string">&quot;。&quot;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/28/JavaScript-BOM/image-20220128123251923.png" alt="image-20220128123251923"></p>
<p>但由于 Internet Explorer 浏览器已经不再被经常使用，所以很少能用到后面几个属性。</p>
<h1>其他 Window 方法</h1>
<p>一些其他方法：</p>
<ul>
<li>window.open() - 打开新窗口</li>
<li>window.close() - 关闭当前窗口</li>
<li>window.moveTo() - 移动当前窗口</li>
<li>window.resizeTo() - 调整当前窗口的尺寸</li>
</ul>
<h1>Window Screen</h1>
<p>window.screen 对象包含有关用户屏幕的信息。</p>
<ul>
<li>screen.availWidth - 可用的屏幕宽度</li>
<li>screen.availHeight - 可用的屏幕高度</li>
</ul>
<h1>Window Location</h1>
<p>window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。</p>
<p>例如：</p>
<ul>
<li>location.hostname 返回 web 主机的域名</li>
<li>location.pathname 返回当前页面的路径和文件名</li>
<li>location.port 返回 web 主机的端口 （80 或 443）</li>
<li>location.protocol 返回所使用的 web 协议（http: 或 https:）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(location.href);<span class="comment">//返回当前页面的url</span></span><br><span class="line"><span class="built_in">document</span>.write(location.pathname);<span class="comment">//返回URL 的路径名，也就是页面的相对路径</span></span><br></pre></td></tr></table></figure>
<h1>Window Location Assign</h1>
<p>location.assign() 方法可以加载新的文档。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newDoc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.location.assign(<span class="string">&quot;http://tosuke.gitee.io/&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用这个函数，页面将会加载<a href="http://tosuke.gitee.io/">京介的正牌博客 - 知识越多，代码越少 (gitee.io)</a>这个页面。</p>
<blockquote>
<p>还有一个与他很像的函数window.location.replace(url) ，都是相当于跳转新链接，不同之处在于：</p>
<p>window.location.assign(url) ： 加载 URL 指定的新的 HTML 文档。 就相当于一个链接，跳转到指定的url，当前页面会转为新页面内容，可以点击后退返回上一个页面。</p>
<p>window.location.replace(url) ： 通过加载 URL 指定的文档来替换当前文档 ，这个方法是替换当前窗口页面，前后两个页面共用一个窗口，所以是没有后退返回上一页的</p>
</blockquote>
<h1>Window History</h1>
<p>window.history 对象包含浏览器的要命的历史，所以js对他的访问也有一些限制（遗嘱：请务必清除我的所有浏览器数据）</p>
<p>首先是两个非常普通的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.back() - 与在浏览器点击后退按钮相同</span><br><span class="line">history.forward() - 与在浏览器中点击向前按钮相同</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除此之外可以用 <strong>history.go()</strong> 这个方法来实现向前，后退的功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.go(<span class="number">1</span>);<span class="comment">//向前一个页面 </span></span><br><span class="line">history.go(-<span class="number">1</span>); <span class="comment">//向后一个页面 </span></span><br><span class="line">history.go(<span class="number">0</span>); <span class="comment">//刷新当前页面页面 </span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1>Window Navigator</h1>
<p>window.navigator 对象包含有关访问者浏览器的信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">txt = <span class="string">&quot;&lt;p&gt;浏览器代号: &quot;</span> + navigator.appCodeName + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">txt+= <span class="string">&quot;&lt;p&gt;浏览器名称: &quot;</span> + navigator.appName + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">txt+= <span class="string">&quot;&lt;p&gt;浏览器版本: &quot;</span> + navigator.appVersion + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">txt+= <span class="string">&quot;&lt;p&gt;启用Cookies: &quot;</span> + navigator.cookieEnabled + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">txt+= <span class="string">&quot;&lt;p&gt;硬件平台: &quot;</span> + navigator.platform + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">txt+= <span class="string">&quot;&lt;p&gt;用户代理: &quot;</span> + navigator.userAgent + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">txt+= <span class="string">&quot;&lt;p&gt;用户代理语言: &quot;</span> + navigator.language + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;example&quot;</span>).innerHTML=txt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>来自 navigator 对象的信息具有误导性，不应该被用于检测浏览器版本，这是因为：</p>
<ul>
<li>navigator 数据可被浏览器使用者更改</li>
<li>一些浏览器对测试站点会识别错误</li>
<li>浏览器无法报告晚于浏览器发布的新操作系统</li>
</ul>
<h1>弹窗</h1>
<p>可以在 JavaScript 中创建三种消息框：警告框、确认框、提示框</p>
<h2 id="警告框">警告框</h2>
<p>警告框经常用于确保用户可以得到某些信息。</p>
<p>当警告框出现后，用户需要点击确定按钮才能继续进行操作。</p>
<p>警告框也就是我们一直再用的<strong>window.alert()</strong> 方法（可以不加上window对象）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">&quot;即将跳转&quot;</span>)；</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/28/JavaScript-BOM/image-20220128153501193.png" alt="image-20220128153501193"></p>
<p>即这样的警示框。</p>
<h2 id="确认框">确认框</h2>
<p>确认框通常用于验证是否接受用户操作。</p>
<p>当确认卡弹出时，用户可以点击 “确认” 或者 “取消” 来确定用户操作。</p>
<p>当你点击 “确认”, 确认框返回 true， 如果点击 “取消”, 确认框返回 false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r=confirm(<span class="string">&quot;按下按钮&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (r==<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		   <span class="built_in">window</span>.location.assign(<span class="string">&quot;http://tosuke.gitee.io/&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">		   alert(<span class="string">&quot;取消！&quot;</span>)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/28/JavaScript-BOM/image-20220128153932257.png" alt="image-20220128153932257"></p>
<h2 id="提示框">提示框</h2>
<p>提示框经常用于提示用户在进入页面前输入某个值。</p>
<p>当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操纵。</p>
<p>如果用户点击确认，那么返回值为输入的值。如果用户点击取消，那么返回值为 null。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.prompt(<span class="string">&quot;sometext&quot;</span>,<span class="string">&quot;defaultvalue&quot;</span>);<span class="comment">//语法</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=prompt(<span class="string">&quot;输入你的年龄！&quot;</span>,<span class="string">&quot;Tosuke&quot;</span>);</span><br><span class="line">	   <span class="keyword">if</span>(x!=<span class="literal">null</span>&amp;&amp;x!=<span class="string">&quot;&quot;</span>)</span><br><span class="line">	   &#123;</span><br><span class="line">		   alert(<span class="string">&quot;你好！&quot;</span>+x+<span class="string">&quot;天气不错呢！&quot;</span>);</span><br><span class="line">	   &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/28/JavaScript-BOM/image-20220128154608684.png" alt="image-20220128154608684"></p>
<h2 id="换行">换行</h2>
<p>弹窗使用 反斜杠 + “n”(\n) 来设置换行。</p>
<h1>计时事件</h1>
<p>JavaScript 一个设定的时间间隔之后来执行代码我们称之为计时事件.</p>
<h2 id="JavaScript-计时事件">JavaScript 计时事件</h2>
<p>通过使用 JavaScript，我们有能力做到在一个设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。我们称之为计时事件。</p>
<p>在 JavaScritp 中使用计时事件是很容易的，两个关键方法是:</p>
<ul>
<li>setInterval() - 间隔指定的毫秒数不停地执行指定的代码。</li>
<li>setTimeout() - 在指定的毫秒数后执行指定代码。</li>
</ul>
<p><strong>注意:</strong> setInterval() 和 setTimeout() 是 HTML DOM Window对象的两个方法。</p>
<h3 id="setInterval">setInterval()</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">&quot;Hello&quot;</span>)&#125;,<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>setInterval()有两个参数，第一个是需要循环执行的函数，第二个是循环的时间间隔。</p>
<p><strong>clearInterval() 方法</strong>用于停止 setInterval() 方法执行的函数代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">直接在<span class="built_in">clearInterval</span>() 中填上作为需要停止的<span class="built_in">setInterval</span></span><br></pre></td></tr></table></figure>
<h3 id="setTimeout">setTimeout()</h3>
<p>在指定的毫秒数后执行指定代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myVar= <span class="built_in">window</span>.setTimeout(<span class="string">&quot;javascript function&quot;</span>, milliseconds);</span><br></pre></td></tr></table></figure>
<p>与setInterval()是相同的参数结构，clearTimeout() 来停止setTimeout函数。</p>
<h1>Cookie</h1>
<h2 id="什么是-Cookie？">什么是 Cookie？</h2>
<p>Cookie 是一些数据, 存储于你电脑上的文本文件中。</p>
<p>当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。</p>
<p>Cookie 的作用就是用于解决 “如何记录客户端的用户信息”:</p>
<ul>
<li>当用户访问 web 页面时，他的名字可以记录在 cookie 中。</li>
<li>在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。</li>
</ul>
<p>Cookie 以名/值对形式存储：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">username=Tosuke</span><br></pre></td></tr></table></figure>
<p>当浏览器从服务器上请求 web 页面时， 属于该页面的 cookie 会被添加到该请求中。服务端通过这种方式来获取用户的信息。</p>
<h2 id="使用-JavaScript-创建Cookie">使用 JavaScript 创建Cookie</h2>
<p>JavaScript 可以使用 <strong>document.cookie</strong> 属性来创建 、读取、及删除 cookie。</p>
<p>JavaScript 中，创建 cookie 如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie=<span class="string">&quot;username=John Doe&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>使用path告诉浏览器cookie的路径，默认情况下，cookie属于当前页面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie=<span class="string">&quot;username=John Doe; path=/&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="使用-JavaScript-读取-Cookie">使用 JavaScript 读取 Cookie</h2>
<p>在 JavaScript 中, 可以使用以下代码来读取 cookie：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>document.cookie 将以字符串的方式返回所有的 cookie，类型格式： cookie1=value; cookie2=value; cookie3=value;</p>
</blockquote>
<h2 id="使用-JavaScript-修改-Cookie">使用 JavaScript 修改 Cookie</h2>
<p>在 JavaScript 中，修改 cookie 类似于创建 cookie，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie=<span class="string">&quot;username=John Smith; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>旧的 cookie 将被覆盖。</p>
<h2 id="使用-JavaScript-删除-Cookie">使用 JavaScript 删除 Cookie</h2>
<p>删除 cookie 非常简单。您只需要设置 expires 参数为以前的时间即可，如下所示，设置为 Thu, 01 Jan 1970 00:00:00 GMT:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;username=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>注意，当您删除时不必指定 cookie 的值。</p>
<h2 id="Cookie-字符串">Cookie 字符串</h2>
<p>document.cookie 属性看起来像一个普通的文本字符串，其实它不是。</p>
<p>即使您在 document.cookie 中写入一个完整的 cookie 字符串, 当您重新读取该 cookie 信息时，cookie 信息是以名/值对的形式展示的。</p>
<p>如果您设置了新的 cookie，旧的 cookie 不会被覆盖。 新 cookie 将添加到 document.cookie 中，所以如果您重新读取document.cookie</p>
<h2 id="设置-cookie-值的函数">设置 cookie 值的函数</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">cname,cvalue,exdays</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  d.setTime(d.getTime()+(exdays*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>));</span><br><span class="line">  <span class="keyword">var</span> expires = <span class="string">&quot;expires=&quot;</span>+d.toGMTString();<span class="comment">//设置过期时间</span></span><br><span class="line">  <span class="built_in">document</span>.cookie = cname + <span class="string">&quot;=&quot;</span> + cvalue + <span class="string">&quot;; &quot;</span> + expires;<span class="comment">//进行储存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数解析：</strong></p>
<p>以上的函数参数中，cookie 的名称为 cname，cookie 的值为 cvalue，并设置了 cookie 的过期时间 expires。</p>
<p>该函数设置了 cookie 名、cookie 值、cookie过期时间。</p>
<h2 id="获取-cookie-值的函数">获取 cookie 值的函数</h2>
<p>然后，我们创建一个函数用于返回指定 cookie 的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">cname</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = cname + <span class="string">&quot;=&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> ca = <span class="built_in">document</span>.cookie.split(<span class="string">&#x27;;&#x27;</span>);<span class="comment">//使用；进行分割操作</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;ca.length; i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> c = ca[i].trim();</span><br><span class="line">    <span class="keyword">if</span> (c.indexOf(name)==<span class="number">0</span>) <span class="keyword">return</span> c.substring(name.length,c.length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数解析：</strong></p>
<p>cookie 名的参数为 cname。</p>
<p>创建一个文本变量用于检索指定 cookie :cname + “=”。</p>
<p>使用分号来分割 document.cookie 字符串，并将分割后的字符串数组赋值给 ca (ca = document.cookie.split(‘;’))。</p>
<p>循环 ca 数组 (i=0;i&lt;ca.length;i++)，然后读取数组中的每个值，并去除前后空格 (c=ca[i].trim())。</p>
<p>如果找到 cookie(c.indexOf(name) == 0)，返回 cookie 的值 (c.substring(name.length,c.length)。</p>
<p>如果没有找到 cookie, 返回 “”。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端入门</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-Dom</title>
    <url>/2022/01/27/JavaScript-Dom/</url>
    <content><![CDATA[<h1>HTML DOM (文档对象模型)</h1>
<p>当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素。</p>
<p>HTML DOM 树的结构示意图（图片来自菜鸟编程）：</p>
<p><img src="/2022/01/27/JavaScript-Dom/image-20220127233523498.png" alt="image-20220127233523498"></p>
<p>通过js对dom的掌控，使得这些对象模型可以被动态的展示出来（类似于商品列表，一刷新一换）。</p>
<h1>查找 HTML 元素</h1>
<p>通过 JavaScript操作 HTML 元素需要先通过某种方式进行查找从而进行选择。</p>
<p>有三种方法来做这件事：</p>
<ul>
<li>通过 id 找到 HTML 元素</li>
<li>通过标签名找到 HTML 元素</li>
<li>通过类名找到 HTML 元素</li>
</ul>
<h2 id="通过-id-找到-HTML-元素">通过 id 找到 HTML 元素</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="built_in">document</span>.getElementById(<span class="string">&quot;id名&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="通过标签名找到-HTML-元素">通过标签名找到 HTML 元素</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="built_in">document</span>.getElementById(<span class="string">&quot;main&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> y=x.getElementsByTagName(<span class="string">&quot;p&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>本例查找 id=“main” 的元素，然后查找 id=“main” 元素中的所有 <code>&lt;p&gt;</code> 元素</p>
<h2 id="通过类名找到-HTML-元素">通过类名找到 HTML 元素</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;intro&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1>改变 HTML 输出流</h1>
<p>document.write() 可用于直接向 HTML 输出流写内容。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.write(<span class="built_in">Date</span>());<span class="comment">//该语句会直接向HTML输出流xie</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：绝对不要在文档(DOM)加载完成之后使用 document.write()。这会覆盖该文档。</strong></p>
</blockquote>
<h1>改变 HTML 内容</h1>
<p>document.getElementById(<em>id</em>).innerHTML=<em>新的改变</em></p>
<p>使用这个函数可以使得HTML元素的内容发生改变</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.getElementById(<span class="string">&quot;p1&quot;</span>).innerHTML=<span class="string">&quot;新文本!&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>这里改变了<code>&lt;p1&gt;</code>的内容。</p>
<h1>改变 HTML 属性</h1>
<p>document.getElementById(<em>id</em>).<em>attribute=新属性值</em></p>
<p>使用此函数改变HTML标签的属性。</p>
<p>例如改变图片的路径：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;smiley.gif&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.getElementById(<span class="string">&quot;image&quot;</span>).src=<span class="string">&quot;landscape.jpg&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1>改变 HTML 样式</h1>
<p>document.getElementById(<em>id</em>).style.<em>property</em>=<em>新样式</em></p>
<p>使用此函数改变HTML标签的样式。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.getElementById(<span class="string">&quot;p2&quot;</span>).style.color=<span class="string">&quot;blue&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.getElementById(<span class="string">&quot;p2&quot;</span>).style.fontFamily=<span class="string">&quot;Arial&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.getElementById(<span class="string">&quot;p2&quot;</span>).style.fontSize=<span class="string">&quot;larger&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>666<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1>使用事件</h1>
<p>HTML DOM 允许我们通过触发事件来执行代码，使 JavaScript 有能力对 HTML 事件做出反应。</p>
<p>比如以下事件：</p>
<ul>
<li>元素被点击。</li>
<li>页面加载完成。</li>
<li>输入框被修改。</li>
<li>当网页已加载时</li>
<li>当图像已加载时</li>
<li>当鼠标移动到元素上时</li>
<li>当输入字段被改变时</li>
<li>当提交 HTML 表单时</li>
<li>当用户触发按键时</li>
<li>……</li>
</ul>
<p>例如点击事件（onclick）调用一个js函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="function"><span class="keyword">function</span> <span class="title">changetext</span>(<span class="params">id</span>)</span></span></span></span><br><span class="line"><span class="function"><span class="javascript"><span class="xml"></span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    id.innerHTML=<span class="string">&quot;Ooops!&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onclick</span>=<span class="string">&quot;changetext(this)&quot;</span>&gt;</span>点击我!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>changetext将会在标题被点击时运行。</p>
<p><strong>onload 和 onunload 事件</strong></p>
<p>onload 和 onunload 事件会在用户进入或离开页面时被触发。</p>
<p>onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。</p>
<p>onload 和 onunload 事件可用于处理 cookie。</p>
<p><strong>onchange 事件</strong></p>
<p>onchange 事件常结合对输入字段的验证来使用，在字段被改变时调用。</p>
<p><strong>onmouseover 和 onmouseout 事件</strong></p>
<p>onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。</p>
<p><strong>onmousedown、onmouseup 以及 onclick 事件</strong></p>
<p>onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。首先当点击鼠标按钮时，会触发 onmousedown 事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件。</p>
<h1>EventListener（事件监听）</h1>
<p>用于捕获事件，当某事件触发后执行某函数。</p>
<p><em>element</em>.addEventListener(<em>event, function, useCapture</em>);</p>
<p>第一个参数是事件的类型 (如 “click” 或 “mousedown”).</p>
<p>第二个参数是事件触发后调用的函数。</p>
<p>第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。</p>
<blockquote>
<p>注意:不要使用 “on” 前缀。 例如，使用 “click” ,而不是使用 “onclick”。</p>
</blockquote>
<p>addEventListener() 方法允许向同一个元素添加多个事件，且不会覆盖已存在的事件</p>
<h2 id="关于传递参数">关于传递参数</h2>
<p>当传递参数值时，使用&quot;匿名函数&quot;调用带参数的函数，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; myFunction(p1, p2); &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="事件冒泡与事件捕获">事件冒泡与事件捕获</h2>
<p>事件传递有两种方式：冒泡与捕获。</p>
<p>事件传递定义了元素事件触发的顺序。 如果你将 </p><p> 元素插入到 <div> 元素中，用户点击 <p> 元素, 哪个元素的 “click” 事件先被触发呢？</p>
<p>在 <em>冒泡</em> 中，内部元素的事件会先被触发，然后再触发外部元素，即： </p><p> 元素的点击事件先触发，然后会触发 <div> 元素的点击事件。</div></p>
<p>在 <em>捕获</em> 中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即： <div> 元素的点击事件先触发 ，然后再触发 <p> 元素的点击事件。</p>
<p>addEventListener() 方法可以指定 “useCapture” 参数来设置传递类型：</p>
<h2 id="removeEventListener-方法">removeEventListener() 方法</h2>
<p>removeEventListener() 方法移除由 addEventListener() 方法添加的事件句柄。</p>
<h1>DOM 元素 (节点)</h1>
<p><strong>要创建新的 HTML 元素 (节点)需要先创建一个元素，然后在已存在的元素中添加它。</strong></p>
<p>以下代码是用于创建 </p><p> 元素:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> para = <span class="built_in">document</span>.createElement(<span class="string">&quot;p&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>为 </p><p> 元素创建一个新的文本节点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;这是一个新的段落。&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>将文本节点添加到 </p><p> 元素中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">para.appendChild(node);<span class="comment">//insertBefore() 方法可以将新元素添加到开始位置。</span></span><br></pre></td></tr></table></figure>
<p>最后，在一个已存在的元素中添加 p 元素。</p>
<p>查找已存在的元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>添加到已存在的元素中:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.appendChild(para);<span class="comment">////insertBefore() 方法可以将新元素添加到开始位置。</span></span><br></pre></td></tr></table></figure>
<h2 id="移除已存在的元素">移除已存在的元素</h2>
<p>在父元素中使用node.remove() 方法，parent.removeChild(child);。</p>
<h2 id="替换-HTML-元素">替换 HTML 元素</h2>
<p>我们可以使用 replaceChild() 方法来替换 HTML DOM 中的元素。</p>
<h1>HTMLCollection 对象</h1>
<p>getElementsByTagName() 方法返回 <code>HTMLCollection</code> 对象。</p>
<p>HTMLCollection 对象类似包含 HTML 元素的一个数组。</p>
<p>例如访问所以p元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">y = x[<span class="number">1</span>];<span class="comment">//用类似与数组的方式访问</span></span><br></pre></td></tr></table></figure>
<p>HTMLCollection 对象的 length 属性定义了集合中元素的数量。</p>
<h1>DOM 节点列表</h1>
<p><strong>NodeList</strong> 对象是一个从文档中获取的节点列表 (集合) 。</p>
<p>NodeList 对象类似HTMLCollection 对象。</p>
<p>一些旧版本浏览器中的方法（如：<strong>getElementsByClassName()</strong>）返回的是 NodeList 对象，而不是 HTMLCollection 对象。</p>
<p>所有浏览器的 <strong>childNodes</strong> 属性返回的是 NodeList 对象。</p>
<p>大部分浏览器的 <strong>querySelectorAll()</strong> 返回 NodeList 对象。</p>
<p>同样是访问所有p元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myNodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">y = myNodeList[<span class="number">1</span>];<span class="comment">//同样通过下标访问</span></span><br></pre></td></tr></table></figure>
<h2 id="NodeList-对象-length-属性">NodeList 对象 length 属性</h2>
<p>NodeList 对象 length 属性定义了节点列表中元素的数量。</p>
<h2 id="HTMLCollection-与-NodeList-的区别">HTMLCollection 与 NodeList 的区别</h2>
<p>HTMLCollection是 HTML 元素的集合。</p>
<p>NodeList 是一个文档节点的集合。</p>
<p>NodeList 与 HTMLCollection 有很多类似的地方。</p>
<p>NodeList 与 HTMLCollection 都与数组对象有点类似，可以使用索引 (0, 1, 2, 3, 4, …) 来获取元素。</p>
<p>NodeList 与 HTMLCollection 都有 length 属性。</p>
<p>HTMLCollection 元素可以通过 name，id 或索引来获取。</p>
<p>NodeList 只能通过索引来获取。</p>
<p>只有 NodeList 对象有包含属性节点和文本节点。</p>
<blockquote>
<p><strong>节点列表不是一个数组！</strong></p>
<p>节点列表看起来可能是一个数组，但其实不是。</p>
<p>你可以像数组一样，使用索引来获取元素。</p>
<p>节点列表无法使用数组的方法： valueOf(), pop(), push(), 或 join() 。</p>
</blockquote>
</div></p></div></p>]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端入门</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript入门小识</title>
    <url>/2022/01/20/JavaScript%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/</url>
    <content><![CDATA[<h1>什么是JavaScript？</h1>
<p>JavaScript 是互联网上最流行的脚本语言，这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。</p>
<h1>引入JavaScript</h1>
<h3 id="1-内部引入">1.内部引入</h3>
<h3 id="script-标签"><code>&lt;script&gt;</code> 标签</h3>
<p>如需在 HTML 页面中插入 JavaScript，请使用 <code>&lt;script&gt;</code> 标签。</p>
<p><code>&lt;script&gt;</code>和 <code>&lt;/script&gt;</code>会告诉 JavaScript 在何处开始和结束，之间的代码行包含了 JavaScript:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">alert(<span class="string">&quot;我的第一个 JavaScript&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-外部引入">2.外部引入</h3>
<p>也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。</p>
<p>外部 JavaScript 文件的文件扩展名是 .js。</p>
<p>如需使用外部文件，请在  <code>&lt;script&gt;</code>标签的 “src” 属性中设置该 .js 文件，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;myScript.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="基本语法入门">基本语法入门</h2>
<h2 id="数据类型">数据类型</h2>
<p><strong>变量名不能用数字开头</strong></p>
<p>number：数字（不区分大小写）</p>
<p>字符串：‘abc’、“ann”</p>
<p>布尔值：true，false</p>
<p>逻辑运算:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&amp;&amp;  于</span><br><span class="line">|| 或</span><br><span class="line">！ 非</span><br></pre></td></tr></table></figure>
<p>比较运算符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">=</span><br><span class="line">== 等于（类型不算）</span><br><span class="line">=== 绝对等于（类型）</span><br></pre></td></tr></table></figure>
<p>在js中一般使用“===”</p>
<p><strong>注意</strong>：NaN（not a number）与所有值都不相等（包括自己）只能使用isNaN(NaN)来判断是否未NaN</p>
<p>null和undefind：未定义</p>
<p>数组：什么都装，不需要类型相同。尽量使用中括号表示数组</p>
<p>类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person&#123;</span><br><span class="line">name：“十大”,</span><br><span class="line"><span class="attr">age</span>: <span class="string">&#x27;10&#x27;</span></span><br><span class="line"><span class="attr">tag</span>: [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象成员用逗号隔开，最后一位不需要逗号。</p>
<p>用“.”来访问对象成员</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.name</span><br><span class="line">&gt;<span class="string">&quot;十大&quot;</span></span><br><span class="line">person.age</span><br><span class="line">&gt;<span class="number">10</span></span><br></pre></td></tr></table></figure>
<h2 id="严格检查模式">严格检查模式</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br></pre></td></tr></table></figure>
<h1>数据类型</h1>
<p>在 JavaScript 中有 6 种不同的数据类型：</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>object</li>
<li>function</li>
<li>symbol</li>
</ul>
<p>3 种对象类型：</p>
<ul>
<li>Object</li>
<li>Date</li>
<li>Array</li>
</ul>
<p>2 个不包含任何值的数据类型：</p>
<ul>
<li>null</li>
<li>undefined</li>
</ul>
<p><strong>你可以使用 typeof 操作符来查看 JavaScript 变量的数据类型。</strong></p>
<h2 id="constructor-属性">constructor 属性</h2>
<p><strong>constructor</strong> 属性返回所有 JavaScript 变量的构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;John&quot;</span>.constructor                 <span class="comment">// 返回函数 String()  &#123; [native code] &#125;</span></span><br><span class="line">(<span class="number">3.14</span>).constructor                 <span class="comment">// 返回函数 Number()  &#123; [native code] &#125;</span></span><br><span class="line"><span class="literal">false</span>.constructor                  <span class="comment">// 返回函数 Boolean() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="1、字符串">1、字符串</h2>
<p>1、正常的字符串使用单引号或者双引号包围</p>
<p>2、注意转义字符\</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">\<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<p>3、多行字符串编写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">`hello</span></span><br><span class="line"><span class="string">sad</span></span><br><span class="line"><span class="string">happy</span></span><br><span class="line"><span class="string">das`</span></span><br></pre></td></tr></table></figure>
<p>4、模板字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name=<span class="string">&quot;Tosuke&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> msg =<span class="string">`你好呀,<span class="subst">$&#123;name&#125;</span>;</span></span><br></pre></td></tr></table></figure>
<p>5、字符串的长度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.length</span><br></pre></td></tr></table></figure>
<p>6、字符串的可变性，不可变性</p>
<p><img src="/2022/01/20/JavaScript%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/image-20220120144032536.png" alt="image-20220120144032536"></p>
<p>7、大小写转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意，此为方法</span></span><br><span class="line">student.toUpperCase()</span><br><span class="line">student.toLowerCase()</span><br></pre></td></tr></table></figure>
<p>8、student.indexOf(‘t’)</p>
<p>9、substring</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">student.substring(<span class="number">1</span>)<span class="comment">//从第一个字符串截取到最后一个</span></span><br><span class="line">student.substring(<span class="number">1</span>,<span class="number">3</span>)<span class="comment">//[1,3)</span></span><br></pre></td></tr></table></figure>
<h2 id="2、数组">2、数组</h2>
<p>array可以包含任意类型的数据类型</p>
<p>1、长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr.length</span><br></pre></td></tr></table></figure>
<p>可以对长度数据进行修改，数组相应大小就会改变。（小心数据丢失！）</p>
<p>2、indexOf，通过元素获得下标索引</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.indexof(<span class="number">2</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>3、slice()</p>
<h2 id="JavaScript-类型转换">JavaScript 类型转换</h2>
<p>JavaScript 变量可以转换为新变量或其他数据类型：</p>
<ul>
<li>通过使用 JavaScript 函数</li>
<li>通过 JavaScript 自身自动转换</li>
</ul>
<h3 id="将数字转换为字符串">将数字转换为字符串</h3>
<p>全局方法 <strong>String()</strong> 可以将数字转换为字符串。</p>
<p>该方法可用于任何类型的数字，字母，变量，表达式（Number 方法 <strong>toString()</strong> 也是有同样的效果。）：</p>
<h1>JavaScript 正则表达式</h1>
<p>正则表达式是由一个字符序列形成的搜索模式。</p>
<p>当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。</p>
<p>正则表达式可以是一个简单的字符，或一个更复杂的模式。</p>
<p>正则表达式可用于所有文本搜索和文本替换的操作。</p>
<p><img src="/2022/01/20/JavaScript%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%86/image-20220127162021505.png" alt="image-20220127162021505"></p>
<h2 id="使用-test">使用 test()</h2>
<p>test() 方法是一个正则表达式方法。</p>
<p>test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。</p>
<table>
<thead>
<tr>
<th>[abc]</th>
<th>查找方括号之间的任何字符。</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0-9]</td>
<td>查找任何从 0 至 9 的数字。</td>
</tr>
<tr>
<td>(x|y)</td>
<td>查找任何以 | 分隔的选项。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">元字符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\d</td>
<td style="text-align:center">查找数字。</td>
</tr>
<tr>
<td style="text-align:left">\s</td>
<td style="text-align:center">查找空白字符。</td>
</tr>
<tr>
<td style="text-align:left">\b</td>
<td style="text-align:center">匹配单词边界。</td>
</tr>
<tr>
<td style="text-align:left">\uxxxx</td>
<td style="text-align:center">查找以十六进制数 xxxx 规定的 Unicode 字符。</td>
</tr>
</tbody>
</table>
<h2 id="使用-exec">使用 exec()</h2>
<p>exec() 方法是一个正则表达式方法。</p>
<p>exec() 方法用于检索字符串中的正则表达式的匹配。</p>
<p>该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p>
<h1>JavaScript 错误 - throw、try 和 catch</h1>
<hr>
<p><strong>try</strong> 语句测试代码块的错误。</p>
<p><strong>catch</strong> 语句处理错误。</p>
<p><strong>throw</strong> 语句创建自定义错误。</p>
<p><strong>finally</strong> 语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行。</p>
<p>该部分与Java依然极其相似：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...    <span class="comment">//异常的抛出</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    ...    <span class="comment">//异常的捕获与处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...    <span class="comment">//结束处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>JavaScript 调试</h1>
<p>我们浏览器启用调试工具一般是按下 F12 键，并在调试菜单中选择 “Console” 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="设置断点">设置断点</h2>
<p>在调试窗口中，你可以设置 JavaScript 代码的断点。</p>
<p>在每个断点上，都会停止执行 JavaScript 代码，以便于我们检查 JavaScript 变量的值。</p>
<p>在检查完毕后，可以重新执行代码（如播放按钮）。</p>
<h1>JavaScript 声明提升</h1>
<p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。</p>
<p>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p>
<p>意思是尽管设置变量时没有在这行代码之前声明它，而是在后面才声明时也是可以使用的（声明自动提升），不过大家还是得遵守先声明再使用的原则。</p>
<h1>JavaScript 严格模式(use strict)</h1>
<p>使用 “use strict” 指令<br>
“use strict” 指令在 JavaScript 1.8.5 (ECMAScript5) 中新增。</p>
<p>它不是一条语句，但是是一个字面量表达式，在 JavaScript 旧版本中会被忽略。</p>
<p>“use strict” 的目的是指定代码在严格条件下执行。</p>
<p>严格模式下你不能使用未声明的变量。</p>
<h2 id="表单验证">表单验证</h2>
<p>HTML 表单验证可以通过 JavaScript 来完成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TableTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x=<span class="built_in">document</span>.forms[<span class="string">&quot;myform&quot;</span>][<span class="string">&quot;fname&quot;</span>].value;</span><br><span class="line">  <span class="keyword">if</span>(x==<span class="literal">null</span>||x==<span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      alert(<span class="string">&quot;需要输入名字。&quot;</span>)；</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form name=<span class="string">&quot;myForm&quot;</span> action=<span class="string">&quot;demo_form.php&quot;</span> onsubmit=<span class="string">&quot;return validateForm()&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">名字: <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fname&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1>JavaScript this 关键字</h1>
<p>面向对象语言中 this 表示当前对象的一个引用。</p>
<p>但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。</p>
<ul>
<li>在方法中，this 表示该方法所属的对象。</li>
<li>如果单独使用，this 表示全局对象。</li>
<li>在函数中，this 表示全局对象。</li>
<li>在函数中，在严格模式下，this 是未定义的(undefined)。</li>
<li>在事件中，this 表示接收事件的元素。</li>
<li>类似 call() 和 apply() 方法可以将 this 引用到任何对象</li>
</ul>
<h1>JavaScript let 和 const</h1>
<h3 id="ECMAScript-2015-ECMAScript-6">ECMAScript 2015(ECMAScript 6)</h3>
<p>ES2015(ES6) 新增加了两个重要的 JavaScript 关键字: <strong>let</strong> 和 <strong>const</strong>。</p>
<p>let 声明的变量只在 let 命令所在的代码块内有效。</p>
<p>const 声明一个只读的常量，一旦声明，常量的值就不能改变。</p>
<p>在 ES6 之前，JavaScript 只有两种作用域： <strong>全局变量</strong> 与 <strong>函数内的局部变量</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">let 定义的代码只在这里生效。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>JavaScript JSON</h1>
<ul>
<li>JSON 英文全称 <strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation</li>
<li>JSON 是一种轻量级的数据交换格式</li>
<li>JSON是独立的语言</li>
<li>JSON 易于理解</li>
</ul>
<h2 id="JSON-语法规则">JSON 语法规则</h2>
<ul>
<li>数据为 键/值 对。</li>
<li>数据由逗号分隔。</li>
<li>大括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<h2 id="JSON-数据-一个名称对应一个值">JSON 数据 - 一个名称对应一个值</h2>
<p>JSON 数据格式为 键/值 对，就像 JavaScript 对象属性。</p>
<p>键/值对包括字段名称（在双引号中），后面一个冒号，然后是值：</p>
<p>“name”:“Runoob”</p>
<hr>
<h2 id="JSON-对象">JSON 对象</h2>
<p>JSON 对象保存在大括号内。</p>
<p>就像在 JavaScript 中, 对象可以保存多个 键/值 对：</p>
<p>{“name”:“Runoob”, “url”:“<a href="http://www.runoob.com">www.runoob.com</a>”}</p>
<hr>
<h2 id="JSON-数组">JSON 数组</h2>
<p>JSON 数组保存在中括号内。</p>
<p>就像在 JavaScript 中, 数组可以包含对象：</p>
<p>“sites”:[    {“name”:“Runoob”, “url”:“<a href="http://www.runoob.com">www.runoob.com</a>”},     {“name”:“Google”, “url”:“<a href="http://www.google.com">www.google.com</a>”},    {“name”:“Taobao”, “url”:“<a href="http://www.taobao.com">www.taobao.com</a>”} ]JSON 数据 - 一个名称对应一个值</p>
<p>JSON 数据格式为 键/值 对，就像 JavaScript 对象属性。</p>
<p>键/值对包括字段名称（在双引号中），后面一个冒号，然后是值：</p>
<p>“name”:“Runoob”</p>
<p>JSON 语法规则<br>
数据为 键/值 对。<br>
数据由逗号分隔。<br>
大括号保存对象<br>
方括号保存数组</p>
<hr>
<h2 id="JSON-对象-2">JSON 对象</h2>
<p>JSON 对象保存在大括号内。</p>
<p>就像在 JavaScript 中, 对象可以保存多个 键/值 对：</p>
<p>{“name”:“Runoob”, “url”:“<a href="http://www.runoob.com">www.runoob.com</a>”}</p>
<hr>
<h2 id="重要函数">重要函数</h2>
<p>用于转换json字符串与js对象</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/js/javascript-json-parse.html">JSON.parse()</a></td>
<td style="text-align:left">用于将一个 JSON 字符串转换为 JavaScript 对象。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/js/javascript-json-stringify.html">JSON.stringify()</a></td>
<td style="text-align:left">用于将 JavaScript 值转换为 JSON 字符串。</td>
</tr>
</tbody>
</table>
<h1>异步编程</h1>
<p>在前端编程中（甚至后端有时也是这样），我们在处理一些简短、快速的操作时，例如计算 1 + 1 的结果，往往在主线程中就可以完成。主线程作为一个线程，不能够同时接受多方面的请求。所以，当一个事件没有结束时，界面将无法处理其他请求。</p>
<p>现在有一个按钮，如果我们设置它的 onclick 事件为一个死循环，那么当这个按钮按下，整个网页将失去响应。</p>
<p>为了避免这种情况的发生，我们常常用子线程来完成一些可能消耗时间足够长以至于被用户察觉的事情，比如读取一个大文件或者发出一个网络请求。因为子线程独立于主线程，所以即使出现阻塞也不会影响主线程的运行。但是子线程有一个局限：一旦发射了以后就会与主线程失去同步，我们无法确定它的结束，如果结束之后需要处理一些事情，比如处理来自服务器的信息，我们是无法将它合并到主线程中去的。</p>
<p>为了解决这个问题，JavaScript 中的异步操作函数往往通过回调函数来实现异步任务的结果处理。</p>
<blockquote>
<p>值得一提的是，js里的同步与异步的概念是与我们现实生活中的同异步恰恰相反的。</p>
</blockquote>
<h2 id="回调函数">回调函数</h2>
<p>回调函数就是一个函数，它是在我们启动一个异步任务的时候就告诉它：等你完成了这个任务之后要干什么。这样一来主线程几乎不用关心异步任务的状态了，他自己会善始善终。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML=<span class="string">&quot;RUNOOB!&quot;</span>;</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>这是一个延时函数，将会在3000毫秒后执行。</p>
<h2 id="Promise">Promise</h2>
<p>Promise 是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;First&quot;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, <span class="number">4000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Third&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码实现了分三次输出字符串，第一次间隔 1 秒，第二次间隔 4 秒，第三次间隔 3 秒，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Run&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//这段程序会直接输出Run</span></span><br></pre></td></tr></table></figure>
<p>Promise 构造函数只有一个函数作为参数，叫做起始函数，起始函数有两个参数resolve 和 reject，其中调用 resolve 代表一切正常，reject 是出现异常时所调用的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) reject(<span class="string">&quot;Divide zero&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> resolve(a / b);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a / b = &quot;</span> + value);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;).finally(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;End&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段程序执行结果是:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a / b = <span class="number">0</span></span><br><span class="line">End</span><br></pre></td></tr></table></figure>
<hr>
<p>resolve() 中可以放置一个参数用于向下一个 then 传递一个值，then 中的函数也可以返回一个值传递给 then。但是，如果 then 中返回的是一个 Promise 对象，那么下一个 then 将相当于对这个返回的 Promise 进行操作，这一点从刚才的计时器的例子中可以看出来。</p>
<p>reject() 参数中一般会传递一个异常给之后的 catch 函数用于处理异常。</p>
<p>但是请注意以下两点：</p>
<ul>
<li>resolve 和 reject 的作用域只有起始函数，不包括 then 以及其他序列；</li>
<li>resolve 和 reject 并不能够使起始函数停止运行，别忘了 return。</li>
</ul>
<h3 id="Promise-函数">Promise 函数</h3>
<p>上述的 “计时器” 程序看上去比函数瀑布还要长，所以我们可以将它的核心部分写成一个 Promise 函数：</p>
<p>封装promise函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">delay, message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(message);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就可以放心大胆的实现程序功能了：</p>
<p>使用函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">print(<span class="number">1000</span>, <span class="string">&quot;First&quot;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> print(<span class="number">4000</span>, <span class="string">&quot;Second&quot;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    print(<span class="number">3000</span>, <span class="string">&quot;Third&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><em>这种返回值为一个 Promise 对象的函数称作 Promise 函数，它常常用于开发基于异步操作的库。</em></p>
<blockquote>
<p>下面是一些常见问题及解答的收录：</p>
<p><strong>Q: then、catch 和 finally 序列能否顺序颠倒？</strong></p>
<p>A: 可以，效果完全一样。但不建议这样做，最好按 then-catch-finally 的顺序编写程序。</p>
<p><strong>Q: 除了 then 块以外，其它两种块能否多次使用？</strong></p>
<p>A: 可以，finally 与 then 一样会按顺序执行，但是 catch 块只会执行第一个，除非 catch 块里有异常。所以最好只安排一个 catch 和 finally 块。</p>
<p><strong>Q: then 块如何中断？</strong></p>
<p>A: then 块默认会向下顺序执行，return 是不能中断的，可以通过 throw 来跳转至 catch 实现中断。</p>
<p><strong>Q: 什么时候适合用 Promise 而不是传统回调函数？</strong></p>
<p>A: 当需要多次顺序执行异步操作的时候，例如，如果想通过异步方法先后检测用户名和密码，需要先异步检测用户名，然后再异步检测密码的情况下就很适合 Promise。</p>
<p><strong>Q: Promise 是一种将异步转换为同步的方法吗？</strong></p>
<p>A: 完全不是。Promise 只不过是一种更良好的编程风格。</p>
<p><strong>Q: 什么时候我们需要再写一个 then 而不是在当前的 then 接着编程？</strong></p>
<p>A: 当你又需要调用一个异步任务的时候。</p>
</blockquote>
<h2 id="异步函数（async-function）">异步函数（async function）</h2>
<p>在之前的promise函数中，我们可以把接下来调用promise函数的过程变得更加简洁：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> print(<span class="number">1000</span>, <span class="string">&quot;First&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> print(<span class="number">4000</span>, <span class="string">&quot;Second&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> print(<span class="number">3000</span>, <span class="string">&quot;Third&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">asyncFunc();</span><br></pre></td></tr></table></figure>
<p>异步函数 async function 中可以使用 await 指令，await 指令后必须跟着一个 Promise，异步函数会在这个 Promise 运行中暂停，直到其运行结束再继续运行。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/2021/12/21/Java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1>泛型的概念</h1>
<h1>泛型的好处</h1>
<h2 id="类型安全">类型安全</h2>
<h2 id="消除强制转换类型">消除强制转换类型</h2>
<h1>泛型的作用</h1>
<h2 id="编译期间检查">编译期间检查</h2>
<h1>泛型类</h1>
<p><img src="/2021/12/21/Java%E6%B3%9B%E5%9E%8B/image-20211221125349265.png" alt="image-20211221125349265"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的I/O流</title>
    <url>/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/</url>
    <content><![CDATA[<h1>I/O框架</h1>
<h2 id="流的概念">流的概念</h2>
<p>流是内存与存储设备之间传输数据的通道，如果你学习过计算机组成原理或者是操作系统的话，那么你一定知道运行的程序是在内存中的，但程序需要的数据和程序想要写出的数据都保存在我们储存设备（比如磁盘）里的，所以这时候就需要一个进去和一个出来的通道，而这便是流的概念了。</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211215201600633.png" alt="image-20211215201600633"></p>
<h2 id="流的分类">流的分类</h2>
<p><strong>1、按方向分（主要）：</strong></p>
<p>· 输入流：存储设备-&gt;内存（input）</p>
<p>· 输出流：内存-&gt;存储设备（output）</p>
<p><strong>2、按单位分：</strong></p>
<p>· 字节流：以字节为单位，可以读写所有数据。</p>
<p>· 字符流：以字符为单位，只能读写文本数据。</p>
<p><strong>3、按功能分：</strong></p>
<p>· 节点流：具有实际传输数据的读写功能。</p>
<p>· 过滤流：在节点流的基础上增强功能。</p>
<h1>字节流</h1>
<p>字节流的父类（抽象类），我们来看看这些抽象类的一些方法：</p>
<p><strong>inputStream（输入字节流）</strong>：</p>
<p>1、public int read(){}</p>
<p>2、public int read(byte[] b){}</p>
<p>3、public int read(byte[] b,int off,int len){}</p>
<p><strong>OutputStream(输出字节流)：</strong></p>
<p>1、public void write(int n){}</p>
<p>2、public void write(byte[] b){}</p>
<p>3、public void write(byte[] b,int off,int len){}</p>
<h2 id="文件字节流">文件字节流</h2>
<p>文件字节流用于java程序与我们的电脑文件的数据交换。</p>
<p><strong>FileinputStream：</strong></p>
<p>1、public int read(read[] b)//从流中读取多个字节，将读到的内容存入b数组，返回实际读到的字节数；如果达到文件的尾部，则返回-1。</p>
<p><strong>FileOutputStream:</strong></p>
<p>1、public void write(byte[] b)//一次写多个字节，将b数组中所有的字节写入输出流。</p>
<h3 id="文件字节输入流">文件字节输入流</h3>
<p>下面我们来看看简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">       <span class="comment">//创建输入流并指定路径</span></span><br><span class="line">        FileInputStream fs = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;g:\\IOtest.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//尝试读取</span></span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">while</span> ((data=fs.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(data);</span><br><span class="line">        &#125;</span><br><span class="line">        fs.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创造文件g:\IOtest.txt以及输入内容：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219134520046.png" alt="image-20211219134520046"></p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219134601184.png" alt="image-20211219134601184"></p>
<p>输出：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219134629750.png" alt="image-20211219134629750"></p>
<p>这里需要注意的是：</p>
<p>1、我们使用的构造方法中的参数name代表的是我们电脑中文件的路径，所以得保证该路径有这个文件，不然就会报错。</p>
<p>2、采用的读取方法是read（），即每次只读取单个字节，所以我们需要循环输出语句while，并且由于结束条件是——“如果达到文件的尾部，则返回-1。”所以我们的data类型为int类型，这也导致了输出为所对应的ascii码值，但要是想解决也很好办，只需要输出时强制转换类型就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println((<span class="keyword">char</span>)data);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219134849648.png" alt="image-20211219134849648"></p>
<p>我们也可以一次读入多个字节，也就是使用byte数组来进行储存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">       <span class="comment">//创建输入流并指定路径</span></span><br><span class="line">        FileInputStream fs = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;g:\\IOtest.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//尝试读取</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>];</span><br><span class="line">       fs.read(buf);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        fs.read(buf);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        fs.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219135625281.png" alt="image-20211219135625281"></p>
<p>这里值得注意的是，每次调用read方法时，读入多少数据是由数组的大小决定的，会每次接着读取，直到最后数据不够。</p>
<h3 id="文件字节输出流">文件字节输出流</h3>
<p>我们依旧来写个例子吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">out</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileOutputStream fs = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;g:\\IOtest.txt&quot;</span>，<span class="keyword">true</span>);<span class="comment">//创建输出流对象,此处有一个重构，即第二个参数为true时，写入将接着前面的内容，不会重写覆盖。</span></span><br><span class="line">        fs.write(<span class="number">97</span>);</span><br><span class="line">        fs.write(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//本质上依然是转换成ascii码。</span></span><br><span class="line">        fs.write(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我把之前的文件已经清空。</p>
<p>输出：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219141244327.png" alt="image-20211219141244327"></p>
<p>看看文件内容：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219141325188.png" alt="image-20211219141325188"></p>
<p>当然，这种输入方式效率过于低下，我们依然可以采用数组的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">out</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileOutputStream fs = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;g:\\IOtest.txt&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        String sr=<span class="string">&quot;我是京介，请多指教！&quot;</span>;</span><br><span class="line">        fs.write(sr.getBytes());<span class="comment">//利用string转换为byte数组的方法；</span></span><br><span class="line">        fs.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219152607765.png" alt="image-20211219152607765"></p>
<p>看看文件：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219152635237.png" alt="image-20211219152635237"></p>
<p>大功告成！</p>
<h2 id="字节流复制">字节流复制</h2>
<p>输入流与输出流的配合，创造一个输入与输出，然后读一个写一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileLockInterruptionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fuzi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">        FileInputStream f1 = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;g:\\1.jpg&quot;</span>);</span><br><span class="line">        FileOutputStream f2 = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;g:\\2.jpg&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">while</span> ((count=f1.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            f2.write(count);</span><br><span class="line">        &#125;<span class="comment">//一边读一边写</span></span><br><span class="line">        f1.close();</span><br><span class="line">        f2.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;复制完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前的文件：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219153900302.png" alt="image-20211219153900302"></p>
<p>输出：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219153916320.png" alt="image-20211219153916320"></p>
<p>之后的文件夹：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219153949402.png" alt="image-20211219153949402"></p>
<p>这样我们就成功的复制了一张图片啦！</p>
<h2 id="字节缓冲流">字节缓冲流</h2>
<p>BufferedInputStream以及BufferedOutputStream为字节缓冲流，他们自己就已经拥有一个缓冲区，他们的作用是为其他的输入输出流套上一层缓冲的壳子，因为其他字节流（例如文件字节流）是内存与外存直接数据交流，所以效率很低，这时我们就可以用字节缓冲流来增进效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">huan</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileInputStream f1 = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;g:\\IOtest.txt&quot;</span>);</span><br><span class="line">        BufferedInputStream f2 = <span class="keyword">new</span> BufferedInputStream(f1);<span class="comment">//正是因为为其他流添加缓冲，所以参数是一个其他流，现在我们就用f2来代替f1执行功能。</span></span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">while</span> ((data=f2.read())!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(data+“ ”);</span><br><span class="line">        &#125;</span><br><span class="line">        f2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件还是我们那个老文件：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219162024335.png" alt="image-20211219162024335"></p>
<p>输出为：</p>
<p><img src="/2021/12/15/Java%E7%9A%84I-O%E6%B5%81/image-20211219162107314.png" alt="一串熟悉的ascii码"></p>
<p>一串熟悉的ascii码。</p>
<p>在读取数据这一步时，其实是f2自己的缓冲区在进行读取，效率就高了许多。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs搭建简易web后端</title>
    <url>/2022/01/29/NodeJs%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93web%E5%90%8E%E7%AB%AF/</url>
    <content><![CDATA[<blockquote>
<p>更新于2022.1.29</p>
</blockquote>
<h1>什么是Nodejs？</h1>
<p>为了让JavaScript代码能够脱离浏览器独立进行运行，NodeJs便由此而生。JavaScript能够运行在浏览器的一大原因是浏览器内置了V8引擎，能够将JavaScript代码转换为机器语言，而NodeJs封装了v8引擎，本身由c++编写。也就可以正常运行。这样，JavaScript在电脑也可以正常运行。</p>
<p>此次我们要使用NodeJs制作一个简单的Web服务器。</p>
<h1>安装NodeJs</h1>
<p>网络下载安装包进行安装，此处不再赘述。</p>
<h1>认识https请求</h1>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>后端入门</tag>
      </tags>
  </entry>
  <entry>
    <title>XML-HTML走上不同道路的亲兄弟</title>
    <url>/2022/04/11/XML-HTML%E8%B5%B0%E4%B8%8A%E4%B8%8D%E5%90%8C%E9%81%93%E8%B7%AF%E7%9A%84%E4%BA%B2%E5%85%84%E5%BC%9F/</url>
    <content><![CDATA[<h1>Xml-可扩展标记语言-概述</h1>
<h2 id="用途">用途</h2>
<p>1、XML 的设计宗旨是传输数据，而不是显示数据。毕竟显示数据是HTML干的活。</p>
<p>2、xml只是一个文件，他需要软件的运行来显现内容（不像HTML可以直接打开）。</p>
<p>3、同样都是标记语言，xml的标签由你自己决定。</p>
<p><strong>XML 把数据从 HTML 分离</strong></p>
<p>如果你需要在 HTML 文档中显示动态数据，那么每当数据改变时将花费大量的时间来编辑 HTML。</p>
<p>通过 XML，数据能够存储在独立的 XML 文件中。这样您就可以专注于使用 HTML/CSS 进行显示和布局，并确保修改底层数据不再需要对 HTML 进行任何的改变。</p>
<p>通过使用几行 JavaScript 代码，您就可以读取一个外部 XML 文件，并更新您的网页的数据内容。</p>
<p><strong>XML 简化数据传输</strong></p>
<p>对开发人员来说，其中一项最费时的挑战一直是在互联网上的不兼容系统之间交换数据。</p>
<p>由于可以通过各种不兼容的应用程序来读取数据，以 XML 交换数据降低了这种复杂性。</p>
<h1>XML 树结构</h1>
<p>xml的数据具有出色的自我描述性，</p>
<p>XML 文档必须包含<strong>根元素</strong>。该元素是所有其他元素的父元素。</p>
<p>XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。</p>
<p>所有的元素都可以有子元素：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">subchild</span>&gt;</span></span><br><span class="line">            .....</span><br><span class="line">        <span class="tag">&lt;/<span class="name">subchild</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>父、子以及同胞等术语用于描述元素之间的关系。父元素拥有子元素。相同层级上的子元素成为同胞（兄弟或姐妹）。</p>
<p>所有的元素都可以有文本内容和属性（类似 HTML 中）。</p>
<p>例如：这是几本不同属性的书</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;COOKING&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Everyday Italian<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>Giada De Laurentiis<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>30.00<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;CHILDREN&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;WEB&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>Erik T. Ray<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2003<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>良好的层级结构使得xml更易于阅读。</p>
<h1>xml语法</h1>
<p><strong>XML 文档必须有根元素</strong></p>
<p>像是上面的例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">subchild</span>&gt;</span></span><br><span class="line">            .....</span><br><span class="line">        <span class="tag">&lt;/<span class="name">subchild</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>root即为根元素。</p>
<h2 id="XML-声明">XML 声明</h2>
<p>XML 声明文件的可选部分，如果存在需要放在文档的第一行，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>version代表xml版本，encoding代表编码格式。</p>
<h2 id="所有的-XML-元素都必须有一个关闭标签">所有的 XML 元素都必须有一个关闭标签</h2>
<p>在 HTML 中，某些元素不必有一个关闭标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;This is a paragraph.</span><br><span class="line">&lt;br&gt;</span><br></pre></td></tr></table></figure>
<p>在 XML 中，省略关闭标签是非法的。所有元素都<strong>必须</strong>有关闭标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;This is a paragraph.&lt;/p&gt;</span><br><span class="line">&lt;br /&gt;</span><br></pre></td></tr></table></figure>
<p>由于声明本身不属于xml文档的一部分，所以它不需要关闭标签。</p>
<h2 id="XML-标签对大小写敏感">XML 标签对大小写敏感</h2>
<p>XML 标签对大小写敏感。标签 <Letter> 与标签 <letter> 是不同的。</letter></Letter></p>
<p>必须使用相同的大小写来编写打开标签和关闭标签：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Message</span>&gt;</span>这是错误的<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span>这是正确的<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="XML-必须正确嵌套">XML 必须正确嵌套</h2>
<p>在 HTML 中，常会看到没有正确嵌套的元素：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>This text is bold and italic<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 XML 中，所有元素都<strong>必须</strong>彼此正确地嵌套：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>This text is bold and italic<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的实例中，正确嵌套的意思是：由于 <i> 元素是在 <b> 元素内打开的，那么它必须在 <b> 元素内关闭。</b></b></i></p>
<blockquote>
<p>由于xml是作为数据传输文件而存在的，所以语法要求比以展现为功能的HTML要严格许多。</p>
</blockquote>
<h2 id="XML-属性值必须加引号">XML 属性值必须加引号</h2>
<p>与 HTML 类似，XML 元素也可拥有属性（名称/值的对）。</p>
<p>在 XML 中，XML 的属性值必须加引号。</p>
<p>请研究下面的两个 XML 文档。 第一个是错误的，第二个是正确的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span> <span class="attr">date</span>=<span class="string">12/11/2007</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span> <span class="attr">date</span>=<span class="string">&quot;12/11/2007&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在第一个文档中的错误是，note 元素中的 date 属性没有加引号。</p>
<h2 id="实体引用">实体引用</h2>
<p>在 XML 中，一些字符拥有特殊的意义。</p>
<p>如果您把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。</p>
<p>这样会产生 XML 错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;</span><br></pre></td></tr></table></figure>
<p>为了避免这个错误，请用<strong>实体引用</strong>来代替 “&lt;” 字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt;</span><br></pre></td></tr></table></figure>
<p>在 XML 中，有 5 个预定义的实体引用(<strong>实际应用时注意添加分号！</strong>)：</p>
<table>
<thead>
<tr>
<th>&amp;lt</th>
<th>&lt;</th>
<th>less than</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;gt</td>
<td>&gt;</td>
<td>greater than</td>
</tr>
<tr>
<td>&amp;amp</td>
<td>&amp;</td>
<td>ampersand</td>
</tr>
<tr>
<td>&amp;apos</td>
<td>’</td>
<td>apostrophe</td>
</tr>
<tr>
<td>&amp;quot</td>
<td>&quot;</td>
<td>quotation mark</td>
</tr>
</tbody>
</table>
<p>在 XML 中，只有字符 “&lt;” 和 “&amp;” 是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。</p>
<p>(1)属性值用双引号 <strong>&quot;</strong> 或单引号 <strong>’</strong> 分隔，如果属性值中有单引号，则用双引号分隔；如果有双引号，则用单引号分隔。那么如果属性值中既有单引号还有双引号怎么办？这种要使用实体（转义字符，类似于html中的空格符），XML 有 5 个预定义的实体字符，如下：</p>
<p><img src="/2022/04/11/XML-HTML%E8%B5%B0%E4%B8%8A%E4%B8%8D%E5%90%8C%E9%81%93%E8%B7%AF%E7%9A%84%E4%BA%B2%E5%85%84%E5%BC%9F/blog/source/20160526222841679.png" alt="img"></p>
<p>(2)一个元素可以有多个属性，它的基本格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;元素名 属性名1=&quot;属性值1&quot; 属性名2=&quot;属性值2&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>(3)特定的属性名称在同一个元素标记中只能出现一次</p>
<p>(4)属性值不能包括 &lt;,&gt;,&amp;，如果一定要包含，也要使用实体</p>
<h2 id="XML-中的注释">XML 中的注释</h2>
<p>在 XML 中编写注释的语法与 HTML 的语法很相似。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- This is a comment --&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="在-XML-中，空格会被保留">在 XML 中，空格会被保留</h2>
<p>HTML 会把多个连续的空格字符裁减（合并）为一个：</p>
<table>
<thead>
<tr>
<th>HTML:</th>
<th><code>Hello           Tove</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>输出结果:</td>
<td>Hello Tove</td>
</tr>
</tbody>
</table>
<p>在 XML 中，文档中的空格不会被删减。</p>
<h2 id="XML-以-LF-存储换行">XML 以 LF 存储换行</h2>
<h1>XML 元素</h1>
<p>XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。</p>
<p>一个元素可以包含：</p>
<ul>
<li>其他元素</li>
<li>文本</li>
<li>属性</li>
<li>或混合以上所有…</li>
</ul>
<h2 id="XML-命名规则">XML 命名规则</h2>
<p>XML 元素必须遵循以下命名规则：</p>
<ul>
<li>名称可以包含字母、数字以及其他的字符</li>
<li>名称不能以数字或者标点符号开始</li>
<li>名称不能以字母 xml（或者 XML、Xml 等等）开始</li>
<li>名称不能包含空格</li>
</ul>
<p>可使用任何名称，没有保留的字词。</p>
<h2 id="最佳命名习惯">最佳命名习惯</h2>
<p>使名称具有描述性。使用下划线的名称也很不错：&lt;first_name&gt;、&lt;last_name&gt;。</p>
<p>名称应简短和简单，比如：&lt;book_title&gt;，而不是：&lt;the_title_of_the_book&gt;。</p>
<p>避免 “-” 字符。如果您按照这样的方式进行命名：“first-name”，一些软件会认为您想要从 first 里边减去 name。</p>
<p>避免 “.” 字符。如果您按照这样的方式进行命名：“<a href="http://first.name">first.name</a>”，一些软件会认为 “name” 是对象 “first” 的属性。</p>
<p>避免 “:” 字符。冒号会被转换为命名空间来使用。</p>
<h2 id="XML-元素是可扩展的">XML 元素是可扩展的</h2>
<p>XML 元素是可扩展，以携带更多的信息。</p>
<p>请看下面的 XML 实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>让我们设想一下，我们创建了一个应用程序，可将 <to>、<from> 以及 <body> 元素从 XML 文档中提取出来，并产生以下的输出：</body></from></to></p>
<p><strong>MESSAGE</strong></p>
<p><strong>To:</strong> Tove</p>
<p><strong>From:</strong> JaniDon’t forget me this weekend!</p>
<p>想象一下，XML 文档的作者添加的一些额外信息：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">date</span>&gt;</span>2008-01-10<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么这个应用程序会中断或崩溃吗？</p>
<p>不会。这个应用程序仍然可以找到 XML 文档中的 <to>、<from> 以及 <body> 元素，并产生同样的输出。</body></from></to></p>
<p>XML 的优势之一，就是可以在不中断应用程序的情况下进行扩展。</p>
<h1>XML 属性</h1>
<p>XML元素具有属性，类似 HTML。</p>
<p>属性（Attribute）提供有关元素的额外信息。决定元素的一些其他性质。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;demo.html&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于标签的一些重要的属性的改变。</p>
<h2 id="XML-属性必须加引号">XML 属性必须加引号</h2>
<p>属性值必须被引号包围，不过单引号和双引号均可使用。比如一个人的性别，person 元素可以这样写：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span> <span class="attr">sex</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="XML-元素-vs-属性">XML 元素 vs. 属性</h2>
<p>请看这些实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span> <span class="attr">sex</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">firstname</span>&gt;</span>Anna<span class="tag">&lt;/<span class="name">firstname</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lastname</span>&gt;</span>Smith<span class="tag">&lt;/<span class="name">lastname</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sex</span>&gt;</span>female<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">firstname</span>&gt;</span>Anna<span class="tag">&lt;/<span class="name">firstname</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lastname</span>&gt;</span>Smith<span class="tag">&lt;/<span class="name">lastname</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在第一个实例中，sex 是一个属性。在第二个实例中，sex 是一个元素。这两个实例都提供相同的信息。</p>
<p>没有什么规矩可以告诉我们什么时候该使用属性，而什么时候该使用元素。我的经验是在 HTML 中，属性用起来很便利，但是在 XML 中，您应该尽量避免使用属性。如果信息感觉起来很像数据，那么请使用元素吧。</p>
<h2 id="避免-XML-属性">避免 XML 属性</h2>
<p>因使用属性而引起的一些问题：</p>
<ul>
<li>属性不能包含多个值（元素可以）</li>
<li>属性不能包含树结构（元素可以）</li>
<li>属性不容易扩展（为未来的变化）</li>
</ul>
<p>属性难以阅读和维护。请尽量使用元素来描述数据。而仅仅使用属性来提供与数据无关的信息。</p>
<p>不要做这样的蠢事（这不是 XML 应该被使用的方式）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span> <span class="attr">day</span>=<span class="string">&quot;10&quot;</span> <span class="attr">month</span>=<span class="string">&quot;01&quot;</span> <span class="attr">year</span>=<span class="string">&quot;2008&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">to</span>=<span class="string">&quot;Tove&quot;</span> <span class="attr">from</span>=<span class="string">&quot;Jani&quot;</span> <span class="attr">heading</span>=<span class="string">&quot;Reminder&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">body</span>=<span class="string">&quot;Don&#x27;t forget me this weekend!&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样令人看着就头大的xml不利于阅读与维护。</p>
</blockquote>
<h1>XML 验证</h1>
<p>拥有正确语法的 XML 被称为&quot;形式良好&quot;的 XML。</p>
<p>通过 DTD 验证的XML是&quot;合法&quot;的 XML。</p>
<p>式良好&quot;的 XML 文档拥有正确的语法。</p>
<p>在前面的章节描述的语法规则：</p>
<ul>
<li>XML 文档必须有一个根元素</li>
<li>XML元素都必须有一个关闭标签</li>
<li>XML 标签对大小写敏感</li>
<li>XML 元素必须被正确的嵌套</li>
<li>XML 属性值必须加引号</li>
</ul>
<h1>查看 XML 文件</h1>
<p>他们被浏览器打开后是这个样子的：</p>
<p><img src="/2022/04/11/XML-HTML%E8%B5%B0%E4%B8%8A%E4%B8%8D%E5%90%8C%E9%81%93%E8%B7%AF%E7%9A%84%E4%BA%B2%E5%85%84%E5%BC%9F/blog/source/image-20220408173721335.png" alt="image-20220408173721335"></p>
<p>与Html那样专注与展现不同，xml打开是以这样的数据模式打开。并没有HTML的&lt;p&gt;那样指定为可以被浏览器理解为段落并进行相关展示。</p>
<h1>使用 CSS 显示 XML</h1>
<p>下面是 XML 文件的一小部分。第二行把 XML 文件链接到 CSS 文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;cd_catalog.css&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">CATALOG</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">CD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TITLE</span>&gt;</span>Empire Burlesque<span class="tag">&lt;/<span class="name">TITLE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ARTIST</span>&gt;</span>Bob Dylan<span class="tag">&lt;/<span class="name">ARTIST</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">COUNTRY</span>&gt;</span>USA<span class="tag">&lt;/<span class="name">COUNTRY</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">COMPANY</span>&gt;</span>Columbia<span class="tag">&lt;/<span class="name">COMPANY</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PRICE</span>&gt;</span>10.90<span class="tag">&lt;/<span class="name">PRICE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">YEAR</span>&gt;</span>1985<span class="tag">&lt;/<span class="name">YEAR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">CD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">CD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TITLE</span>&gt;</span>Hide your heart<span class="tag">&lt;/<span class="name">TITLE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ARTIST</span>&gt;</span>Bonnie Tyler<span class="tag">&lt;/<span class="name">ARTIST</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">COUNTRY</span>&gt;</span>UK<span class="tag">&lt;/<span class="name">COUNTRY</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">COMPANY</span>&gt;</span>CBS Records<span class="tag">&lt;/<span class="name">COMPANY</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PRICE</span>&gt;</span>9.90<span class="tag">&lt;/<span class="name">PRICE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">YEAR</span>&gt;</span>1988<span class="tag">&lt;/<span class="name">YEAR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">CD</span>&gt;</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="tag">&lt;/<span class="name">CATALOG</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二行代码连接了一个CSS文件，就可以按照CSS对xml文件进行格式化。</p>
<p>使用 CSS 格式化 XML 不是常用的方法。</p>
<p>W3C 推荐使用 XSLT。</p>
<h1>使用 XSLT 显示 XML</h1>
<p>通过使用 XSLT，您可以把 XML 文档转换成 HTML 格式。</p>
<h2 id="在服务器上通过-XSLT-转换-XML">在服务器上通过 XSLT 转换 XML</h2>
<p>在上面的实例中，当浏览器读取 XML 文件时，XSLT 转换是由浏览器完成的。</p>
<p>在使用 XSLT 来转换 XML 时，不同的浏览器可能会产生不同结果。为了减少这种问题，可以在服务器上进行 XSLT 转换。</p>
<h1>XMLHttpRequest 对象</h1>
<h2 id="XMLHttpRequest-对象">XMLHttpRequest 对象</h2>
<p>XMLHttpRequest 对象用于在后台与服务器交换数据。</p>
<p>XMLHttpRequest 对象是<strong>开发者的梦想</strong>，因为您能够：</p>
<ul>
<li>在不重新加载页面的情况下更新网页</li>
<li>在页面已加载后从服务器请求数据</li>
<li>在页面已加载后从服务器接收数据</li>
<li>在后台向服务器发送数据</li>
</ul>
<h2 id="创建一个-XMLHttpRequest-对象">创建一个 XMLHttpRequest 对象</h2>
<p>所有现代浏览器（IE7+、Firefox、Chrome、Safari 和 Opera）都有内建的 XMLHttpRequest 对象。</p>
<p>创建 XMLHttpRequest 对象的语法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlhttp=new XMLHttpRequest();</span><br></pre></td></tr></table></figure>
<h1>XML Parser</h1>
<p>所有现代浏览器都有内建的 XML 解析器。</p>
<p>XML 解析器把 XML 文档转换为 XML DOM 对象 - 可通过 JavaScript 操作的对象。</p>
<h2 id="解析-XML-文档">解析 XML 文档</h2>
<p>下面的代码片段把 XML 文档解析到 XML DOM 对象中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span><br><span class="line">&#123;<span class="comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span><br><span class="line">xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">// code for IE6, IE5</span></span><br><span class="line">xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;books.xml&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">xmlhttp.send();</span><br><span class="line">xmlDoc=xmlhttp.responseXML;</span><br></pre></td></tr></table></figure>
<h2 id="解析-XML-字符串">解析 XML 字符串</h2>
<p>下面的代码片段把 XML 字符串解析到 XML DOM 对象中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">txt=&quot;<span class="tag">&lt;<span class="name">bookstore</span>&gt;</span><span class="tag">&lt;<span class="name">book</span>&gt;</span>&quot;;</span><br><span class="line">txt=txt+&quot;<span class="tag">&lt;<span class="name">title</span>&gt;</span>Everyday Italian<span class="tag">&lt;/<span class="name">title</span>&gt;</span>&quot;;</span><br><span class="line">txt=txt+&quot;<span class="tag">&lt;<span class="name">author</span>&gt;</span>Giada De Laurentiis<span class="tag">&lt;/<span class="name">author</span>&gt;</span>&quot;;</span><br><span class="line">txt=txt+&quot;<span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span>&quot;;</span><br><span class="line">txt=txt+&quot;<span class="tag">&lt;/<span class="name">book</span>&gt;</span><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span>&quot;;</span><br><span class="line"></span><br><span class="line">if (window.DOMParser)</span><br><span class="line">&#123;</span><br><span class="line">parser=new DOMParser();</span><br><span class="line">xmlDoc=parser.parseFromString(txt,&quot;text/xml&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else // Internet Explorer</span><br><span class="line">&#123;</span><br><span class="line">xmlDoc=new ActiveXObject(&quot;Microsoft.XMLDOM&quot;);</span><br><span class="line">xmlDoc.async=false;</span><br><span class="line">xmlDoc.loadXML(txt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跨域访问">跨域访问</h2>
<p>出于安全方面的原因，现代的浏览器不允许跨域的访问。</p>
<p>这意味着，网页以及它试图加载的 XML 文件，都必须位于相同的服务器上。</p>
<h1>XML DOM</h1>
<p>相信很多人知道Html的Dom操作（文档对象模型）</p>
<p>XML DOM则定义了访问和操作 XML 文档的标准方法。</p>
<p>XML DOM 把 XML 文档作为树结构来查看。</p>
<p>所有元素可以通过 DOM 树来访问。可以修改或删除它们的内容，并创建新的元素。元素，它们的文本，以及它们的属性，都被认为是节点。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>W3Schools Internal Note<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>To:<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;to&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>From:<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;from&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>Message:<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span></span><br><span class="line"><span class="javascript">&#123;<span class="comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span></span><br><span class="line"><span class="javascript">xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">else</span></span></span><br><span class="line"><span class="javascript">&#123;<span class="comment">// code for IE6, IE5</span></span></span><br><span class="line"><span class="javascript">xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;note.xml&quot;</span>,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">xmlhttp.send();</span></span><br><span class="line"><span class="javascript">xmlDoc=xmlhttp.responseXML;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&quot;to&quot;</span>).innerHTML=</span></span><br><span class="line"><span class="javascript">xmlDoc.getElementsByTagName(<span class="string">&quot;to&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&quot;from&quot;</span>).innerHTML=</span></span><br><span class="line"><span class="javascript">xmlDoc.getElementsByTagName(<span class="string">&quot;from&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&quot;message&quot;</span>).innerHTML=</span></span><br><span class="line"><span class="javascript">xmlDoc.getElementsByTagName(<span class="string">&quot;body&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，即使 XML 文件只包含一个 <to> 元素，您仍然必须指定数组索引 [0]。这是因为 getElementsByTagName() 方法返回一个数组。</to></p>
</blockquote>
<h1>HTML 页面显示 XML 数据</h1>
<hr>
<h2 id="在-HTML-页面中显示-XML-数据">在 HTML 页面中显示 XML 数据</h2>
<p>在下面的实例中，我们打开一个 XML 文件（“<a href="https://www.runoob.com/try/xml/cd_catalog.xml">cd_catalog.xml</a>”），然后遍历每个 CD 元素，并显示HTML 表格中的 ARTIST 元素和 TITLE 元素的值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span></span><br><span class="line"><span class="javascript">&#123;<span class="comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span></span><br><span class="line"><span class="javascript">xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">else</span></span></span><br><span class="line"><span class="javascript">&#123;<span class="comment">// code for IE6, IE5</span></span></span><br><span class="line"><span class="javascript">xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;cd_catalog.xml&quot;</span>,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">xmlhttp.send();</span></span><br><span class="line"><span class="javascript">xmlDoc=xmlhttp.responseXML;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;table border=&#x27;1&#x27;&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> x=xmlDoc.getElementsByTagName(<span class="string">&quot;CD&quot;</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;x.length;i++)</span></span><br><span class="line"><span class="javascript">&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(x[i].getElementsByTagName(<span class="string">&quot;ARTIST&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(x[i].getElementsByTagName(<span class="string">&quot;TITLE&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;/td&gt;&lt;/tr&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;/table&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2021/10/26/hello-world/</url>
    <content><![CDATA[<p>你好，我的同志，这是我的第一篇博客，显而易见的是我正在学习中，所以页面会非常粗糙，还请见谅！</p>
<h2 id="起源">起源</h2>
<h3 id="一开始">一开始</h3>
<p>建立博客的缘由是因为几位朋友都有了属于他们自己的博客，这让我很感兴趣。</p>
<p>第一步</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="后来嘛">后来嘛</h3>
<p>上网找教程，最后选择了hexo+gitee（码云）的方式部署博客，期间遇到了很多问题，后来大部分都慢慢解决了，但还是有一些现在还没<br>
解决的问题。<br>
比如说：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git@gitee.com: Permission denied (publickey)</span><br></pre></td></tr></table></figure>
<p>配置的ssh明明完美无缺，可通讯还是不行，我猜测是因为我windows用户名是中文的原因，还得再试试。</p>
<h3 id="而现在">而现在</h3>
<p>我之前有一个团队网站，为了测试我把它放在这里。</p>
<p>More info: <a href="http://tocode.e.cn.vc/2">Tocode团队</a></p>
<h3 id="在未来">在未来</h3>
<p>我会继续努力的，总之感谢大家了！</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>感想</category>
      </categories>
      <tags>
        <tag>关于</tag>
      </tags>
  </entry>
  <entry>
    <title>两日之恋人</title>
    <url>/2021/12/19/%E4%B8%A4%E6%97%A5%E4%B9%8B%E6%81%8B%E4%BA%BA/</url>
    <content><![CDATA[<p>筠池点了投降。</p>
<p>并不是这局已经无力回天让人痛苦，而是筠池突然感到了厌烦。</p>
<p>这几天筠池时不时的就会感觉到莫名心累，前几天还在嘲笑俞佑，没想到报应来的这么快。</p>
<p>队友当然不会放过他，开始进行各种语言攻击。</p>
<p>筠池瞟了一眼消息栏，然后直接退出游戏，关掉了显示器。</p>
<p>在漆黑的屏幕里他看见了自己的脸，他惊讶于自己彷佛是在观察一个陌生人那样看着自己，里面的人自己好像并不熟悉。</p>
<p>他打开手机，有二十三条未读消息的提醒占据了屏幕，是来自女友的。</p>
<p>最新的一条是“你到底爱不爱我？”</p>
<p>筠池没动，关掉了手机，熄掉了最后一丝光亮，疲惫地瘫在了沙发上。</p>
<p>自己以前不是这样的。</p>
<p>筠池记得以前的事，那时候自己喜欢打游戏是真的，经常做梦是真的，和同伴说骚话是真的，甚至。</p>
<p>爱上葭凛也是真的。</p>
<p>但是筠池忘了葭凛是怎么成为自己女朋友的了，就好像小时候偷偷在楼下租的影碟，播放到令人激动的剧情时，总是用“一夜之后”这样的字来搪塞，令小时候的筠池痛苦不已。</p>
<p>现在也是这样，筠池已经忘记的影片的剧情了，但“一夜之后”却无奈印入了脑海。</p>
<p>也许是自己勇敢表白，葭凛羞涩地回应了他？或者是葭凛提前发现了自己的心意，她的大胆表露？再不然是两个人不约而同的默契眼神？</p>
<p>筠池没有察觉到自己轻轻地笑了笑。</p>
<p>初长成的爱情总是这样的，总有人会觉得令人回味。</p>
<p>后来呢，又发生了什么吗。</p>
<p>筠池拼命回忆，他只想知道，这一切是自己的错吗。</p>
<p>该轮到自己负责了吗。</p>
<p>这也许毫无疑问，但筠池依然想找到点什么。</p>
<p>忽然，他好像真的找到了什么。</p>
<p>那是关于一个名字的，葭凛。</p>
<p>葭凛是个不错的女孩，筠池和她是青梅竹马，两家人的关系一直不错。</p>
<p>筠池是在高中后和她联系又多了起来的。</p>
<p>一定有什么原因，一定发生了什么。</p>
<p>他觉得自己陷入了一个迷宫，这迷宫如此之熟悉，筠池对它了如指掌。</p>
<p>可是他迷路了，明记下个得转弯就是出口，可那里竟然凭空出现一堵墙，上面写着“一夜之后”立在中间，分割了他和出口。</p>
<p>也分割了他与葭凛。</p>
<p>他不想再想下去了，站到窗前拉开了窗帘，望着窗外伴随着蝉声的夜色，筠池平静了下来。</p>
<p>“我觉得你还是太幼稚了吧”</p>
<p>那是葭凛的声音，筠池非常肯定。</p>
<p>他不再犹豫，做回桌前再次打开了电脑。</p>
<p>并不是像甩掉包袱的感觉，更像是多添了一道代表历练的伤疤。</p>
<p>重新连接发现队友还在坚守高地。</p>
<p>并不是每个人都很成熟，但总有人正成长着。</p>
<p>他久违地打开输入框，认真地敲下每一个字。</p>
<p>并不是每次都可以轻松逃掉的，这次就不行。</p>
<p>“不好意思，稳住我来C。”</p>
<p>他想葭凛了。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>记录</category>
      </categories>
      <tags>
        <tag>时间的恋人</tag>
      </tags>
  </entry>
  <entry>
    <title>了解一定基础算法</title>
    <url>/2022/03/01/%E4%BA%86%E8%A7%A3%E4%B8%80%E5%AE%9A%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1>快速排序</h1>
<p>其本质在于分治思想，在确定一个模板数（在数列里任取）后，把小于它的所有数放在左边，大于它的所有数放在右边，然后再对两边进行递归处理。</p>
<p>模板代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> x=q[l],i=l<span class="number">-1</span>,j=r+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">    <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">    <span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">    <span class="keyword">if</span>(i&lt;j)<span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">quick_sort</span>(q,l,i<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">quick_sort</span>(q,i,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十日之恋人</title>
    <url>/2021/12/19/%E5%8D%81%E6%97%A5%E4%B9%8B%E6%81%8B%E4%BA%BA/</url>
    <content><![CDATA[<p>俞佑回来了。</p>
<p>“只要我去找他，无论什么时候，他还是会等我的。“</p>
<p>“没有我，他根本活不下去。”</p>
<p>婉夏真的这么有把握？</p>
<p>她的确有把握，因为她知道俞佑爱她爱得要命。</p>
<p>俞佑已经好几天没有回来了，现在终于有消息了。</p>
<p>“他果然还会回到西南石油，因为那是‘我们的家’， 那里还有俞佑辛辛苦苦抽出来的装备，攒的各种各样的玩意儿。”</p>
<p>”他一定还在等着我回去。&quot;</p>
<p>想到这里，婉夏心里忽然觉得舒服多了。</p>
<p>”这两天他一定什么事都不想做，一直忙着跟那些bug对线，甚至连作业和预习都没有弄完。&quot;</p>
<p>想到这里，婉夏又不禁皱了皱眉。</p>
<p>&quot;但是没关系，只要我一见他，无论什么事，他都会抢 着去做了，根本不用我动手。 <strong>”</strong></p>
<p>婉夏满足地叹了口气，一个人已到了她这种时候，想 到还有个地方可以回去，还有人在苦苦地等着她，这 种感觉实在令人愉快。</p>
<p>“以前我对他也许的确太狠了些，逼他逼得太紧，以后 我也要改变方针了。”</p>
<p>”男人就像是孩子，你要他听话，多少也得给他点甜头 吃吃。”</p>
<p>想到这里，她忽然觉得心里有点发热。</p>
<p>”无论如何，他虽然不是个很强的男人，但毕竟不是个 很令人讨厌的人。”</p>
<p>她忽然发觉自己还是有点爱他的。</p>
<p>她这一生中，假如还有个人能真的令她动一点感情， 那人就是俞佑了，想得越多，她就越觉得俞佑的好处 比别人多。</p>
<p>“我真该好好地对他才是，像他这样又氟金又暴肝的男 人，世上并不多，以后我也许再也找不到了。&quot; 越想她越觉得不能放弃他。</p>
<p>也许她一直都在爱着他，只不过因为他爱得太深了， 所以才令她觉得无所谓。</p>
<p>他舔她舔得若没有那么深，她说不定反而会更爱他。 这就是人性的弱点，人性的矛盾。</p>
<p>所以聪明的男人就算爱极了一个女人，也只是藏在心 里，绝不要将他的爱全部在她面前表现出来。</p>
<p>&quot;俞佑，你放心，以后我绝不会再令你伤心了，我一定 天天陪着你，以前的事全已过去，现在我们再重头做起。</p>
<p>&quot;只要你还像以前那样对我，我什么事都可以依着你。</p>
<p>但俞佑是不是还会像以前那样对她呢？</p>
<p>婉夏忽然觉得并不十分有把握，对自己的信心已动摇。</p>
<p>她以前从未有过这种感觉，那只因她以前从未觉得俞佑对她有如此重要，无论俞佑对她是好是坏，她都全不放在心上。</p>
<p>一个人只有在很想“得到”的时候，才会怕&quot;失去”</p>
<p>这种患得患失的感觉，也正是人类许多种弱点之一。</p>
<p>可悲的是，你想&quot;得到”的人越急切，&quot;失去”的可能就越 大。</p>
<p>婉夏抬起头，已看到西南石油。</p>
<p>西南石油的俞佑室里居然有灯。</p>
<p>她忽然停下来，换了身衣裳，洗了洗脸，擦了擦大腿 和手臂的痕迹，又喷了点香水来掩盖味道，又用手指做梳子，梳了梳头发。</p>
<p>她不愿让俞佑看到她这种狼狈的样子。</p>
<p>因为她绝不能再失去他。</p>
<p>屋子里的灯还在亮着。</p>
<p>西南石油里很安静，静的好像没有什么人。</p>
<p>俞佑正坐在电脑旁，不知道在做什么。</p>
<p>滴滴滴，鼠标点击的声音密密麻麻的。</p>
<p>他看着很淡然，似乎在坐着再平常不过的日常活动，夜已深。</p>
<p>一个人面对着电脑，慢慢地点击着。</p>
<p>没有看到过这种景象的人，绝不会想到这景象是多么寂寞，多么凄凉。</p>
<p>然后，门轻轻被推开了。</p>
<p>婉夏忽然出现在门口，瞧着他。</p>
<p>在看到俞佑的这一瞬间，她心里忽然觉得有一阵热血上涌，就好像流浪已久的游子骤然见到亲人一样。 就连她自己都不知道她怎会有这种感觉。</p>
<p>她的血本是冷的。</p>
<p>俞佑却似乎根本没有发觉有人进来，还是低着头，点击着鼠标。</p>
<p>但他脸上的肌肉却似在逐渐僵硬。</p>
<p>婉夏忍不住轻唤了一声：“俞佑……”</p>
<p>这呼唤的声音还是那么温柔，那么甜蜜。</p>
<p>俞佑终于慢慢地抬起头，面对着她。</p>
<p>他的眼睛还是很亮，是不是因为有泪呢？</p>
<p>婉夏的眼睛似也有些湿了，柔声道：&quot;俞佑，我回来了。”</p>
<p>俞佑没有动，也没有说话。</p>
<p>他似已僵硬得不能有任何动作了 。</p>
<p>婉夏已慢慢地向他走了过来，轻轻道：“我知道你会等我的，因为我到现在才知道这世上只有你一个人是真的对我好。”</p>
<p>这种话她说过多少次了？</p>
<p>但每一次都管用，所以这次也会有用，她始终坚信着这件事。</p>
<p>“别的人都只不过是利用我……我利用他们，他们利用我！这本没有什么吃亏的，只有你，无论我怎么样对你，你对我总是真心真意。”</p>
<p>她没有注意俞佑脸上表情的变化。</p>
<p>因为她距离俞佑已越来越近了，已近得看不清许多她应该看到的事。</p>
<p>“我决心以后绝不再去穿兔女郎衣服了，绝不会再让你伤心了，无论你要怎么样，我都可以依着你，都可以 答应你……</p>
<p>&quot;砰！”俞佑将鼠标击向木制的桌面，声音大的吓人。 婉夏拉起他的手，放在自己胸膛上。</p>
<p>自己的胸有多勾人她是最清楚不过的，俞佑，还有那些人，都拜倒在她的石榴裙下。</p>
<p>她的声音甜得像蜜。</p>
<p>“以前我若有对不起你的地方，以后我一定会加倍补偿你，我会要你觉得无论你对我多好，都是值得的。” 她的胸膛温暖而柔软。</p>
<p>无论任何人的手若放在她胸膛上，绝对再也舍不得移开。</p>
<p>俞佑的手忽然自她胸膛上移开了</p>
<p>婉夏瞟了一眼电脑，那是背包，里面空荡荡的，什么都不剩下了。</p>
<p>婉夏眼睛里忽然露出丝恐惧之色道：&quot;你……你难道……</p>
<p>难道不要我了？ ”</p>
<p>俞佑静静地瞧着她，就好像第一次看到她这个人似 的。</p>
<p>婉夏道：“我对你说的全都是真话，以前我虽然也和别 的男人有……有过，但我对他们那全都是假的……“她声音忽然停顿，因为她忽然看到了俞佑脸上的表情。</p>
<p>俞佑的表情就像是想呕吐。</p>
<p>婉夏不由自主后退了两步，道：“你……你难道不愿听真话？你难道喜欢我骗你？ ”</p>
<p>俞佑盯着她，良久良久，忽然道：“我只奇怪一件</p>
<p>事</p>
<p>婉夏道：“你奇怪什么？&quot;</p>
<p>俞佑慢慢地站了起来，一字字道：“我只奇怪，我以前怎么会爱上你这种女人的！”</p>
<p>婉夏忽然觉得全身都凉了。</p>
<p>俞佑没有再说别的。</p>
<p>他用不着再说别的，这一句话就已足够。</p>
<p>这一句话就已足够将婉夏推入万劫不复的深渊。</p>
<p>俞佑慢慢地走了出去。</p>
<p>一个人若已受过无数次打击和侮辱，绝不会不变的。</p>
<p>一个人可以忍受谎言，却绝不能忍受那种最不能忍受 的侮辱–女人如此，男人也一样。</p>
<p>做妻子的如此，做丈夫的也一样。</p>
<p>婉夏只觉自己的心在往下沉，往下沉……</p>
<p>俞佑已拉开了门。</p>
<p>婉夏忽然转身扑过去，扑倒在他脚下，拉住他的衣服，嘶声道：“你怎么能就这样离开我……我现在已只 有你……“</p>
<p>他只是慢慢地将衣服脱了下来。</p>
<p>他赤着上身走了出去，走入雨中。</p>
<p>他走了出去，走入雨中。</p>
<p>雨很冷。</p>
<p>可是雨很干净。</p>
<p>他终于甩脱了婉夏，甩脱了他心灵上的枷锁，就好像甩脱了那件早已陈旧破烂的衣服，婉夏却还在紧紧抓着那件白色衣服，因为她知道除了这件衣服外，就再也抓不住别的。</p>
<p>“到头来你总会发现你原来什么也没有得到，什么都是空的……”</p>
<p>婉夏泪已流下。</p>
<p>到这时她才发现她原来的确是一直爱着俞佑的。</p>
<p>她折磨他，也许就因为她爱他，也知道他爱她。</p>
<p>”女人为什么总喜欢折磨最爱她的男人呢？&quot;</p>
<p>到现在，她才知道俞佑对她是多么重要。</p>
<p>因为她已失去了他。</p>
<p>“女人为什么总是对得到的东西加以轻蔑，为什么总要等到失去时才知道珍惜。”</p>
<p>也许不只女人如此，男人也是一样的。</p>
<p>婉夏突然狂笑起来，狂笑着将俞佑的衣服一片片撕碎。</p>
<p>“我怕什么，我这么漂亮，又这么年轻-一只要我喜欢，要多少男人就有多少男人，我每天换十个都没有关系。</p>
<p>她在笑，可是这笑却比哭更悲惨。</p>
<p>因为她也知道男人虽容易得到，但&quot;真情&quot;却绝不是青春和美貌可以买得到的……</p>
<p>雨很冷。</p>
<p>冷雨洒在俞佑胸膛上，他觉得舒服得很，因为这雨令 他觉得自己并不是麻木的，十天来，这也许是他第一次有这种感觉。</p>
<p>而且他觉得很轻松，就像是刚卸下了一个沉重的包袱。</p>
<p>远处有人在呼唤：“你好……”</p>
<p>呼声很轻，若在几天前，他也许根本听不见。</p>
<p>但现在，他的眼睛已不再瞎，耳朵也不再聋了。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>记录</category>
      </categories>
      <tags>
        <tag>时间的恋人</tag>
      </tags>
  </entry>
  <entry>
    <title>用logisim实现八位可控加减法器</title>
    <url>/2021/12/03/%E7%AC%AC%E4%BA%8C/</url>
    <content><![CDATA[<h1>计算机组成原理实验</h1>
<p>你好，好久不见！吼吼吼吼吼吼吼吼吼吼吼吼吼吼吼，作为第二篇博客，我决定先从一些简单的实验分享开始啦！（实际因为本人是小菜鸡一只的原因。。）</p>
<h2 id="用logisim实现八位可控加减法器">用logisim实现八位可控加减法器</h2>
<h3 id="思路解析：">思路解析：</h3>
<p>要实现八位可控加减法器，采用并行思路，首先需要八个一位全加器，用分流器可以将八位二进制数分离，使得单独每一位用一位全加器来进行相关的运算，然后并行输出，最后用分流器进行还原。</p>
<h3 id="实验过程：">实验过程：</h3>
<p>1、首先进行一位全加器的设置，我们需要准备五个信号量，三个输入，两个输出，其中xi与yi为参加运算的对象，cin代表来自下一位的进位，si代表本位的输出结果，Cout代表向下一位的进位。</p>
<p><img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/%E5%9B%BE%E7%89%871.png" alt="11"></p>
<p>2、设计思路为：先用一个异或门判断xi与yi的和的情况，若异或门为1，则xi+yi==1，此时与cin进位再次进行异或门判断，若异或门为仍1，则说明不产生进位，则si可置1。若第一个异或门与cin的与门为1，则说明产生了进位并且si位为0.当xi与yi的与门为1时，cin也应该置1。经过调试判断，最终如图所示。</p>
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片2.png" style="zoom:50%;">
<p>3、用logisim进行测试，检验是否制作成果，经检验得制作成功。</p>
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片3.png" style="zoom:33%;">
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片4.png" style="zoom:50%;">
<p>4、制作分流器，准备分流器，数据位宽为8的输入，8个数据位宽为1的隧道，将隧道与分流器相连，分流器与8位位宽的输入相连。</p>
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片6.png" style="zoom:50%;">
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片7.png" style="zoom:50%;">
<p>5、同理，准备一个y输入与s输出。</p>
<p><img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/%E5%9B%BE%E7%89%878.png" alt></p>
<p><img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/%E5%9B%BE%E7%89%879.png" alt></p>
<p>6、准备8个一位全加器，一个用于表示加减的输入sub，一个用于检测溢出的of（overflow），一个cout表示最高位的进位。<br>
其基本思路是：利用sub与y输入形成异或门，用于执行加和减时y的不同形态，将异或门的结果与一起并入全加器的两个加位，输出位依次接上s的8个隧道。将8个全加器按照这样的方式链接，最后将一位全加器用进位位连接起来，sub链接至第一个全加器的进位位，这样做的目的是将原本的（x+y）变成（x+y的补码）即为（x+（1+y的反码））。结果连接如下。</p>
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片10.png" style="zoom:80%;">
]]></content>
      <categories>
        <category>学习</category>
        <category>硬件设计</category>
      </categories>
      <tags>
        <tag>logisim</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用类</title>
    <url>/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/</url>
    <content><![CDATA[<h1>object类</h1>
<p>java语言所有类的根类，object也就是所有类的父类（也就意味着所有类都可以使用object类的方法），位于lang包中，所以不需要导包便可使用。</p>
<h2 id="getclass">getclass</h2>
<p>getclass()方法是返回应引用中存储的实际对象类型（返回值为class类型）</p>
<p>多用于判断两个对象是否是同一个类。</p>
<h2 id="hashCode">hashCode</h2>
<p>hashCode()方法返回的是一个int类型，是根据对象的地址或字符串或数字使用hash算法计算出的数值。</p>
<h2 id="tostring">tostring</h2>
<p>String tostring()   返回该对象的字符串表示。</p>
<p>类如我们创建一个person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用text测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        person p1 = <span class="keyword">new</span> person(<span class="string">&quot;瑾介&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        String s=p1.toString();</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211124624726.png" alt="image-20211211124624726"></p>
<p>我们发现，直接打印对象的名字，其实就是调用了tostring方法。打印的都是堆内存中的十六进制地址值。</p>
<p>如果想直接打印对象的属性的话，我们可以重写tostring方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;person&#123;name=&quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;,age=&quot;</span>+<span class="keyword">this</span>.age+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在再来打印的话：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211125454617.png" alt="image-20211211125454617"></p>
<p>这样就实现了我们自定义的tostring输出了。</p>
<h2 id="equals">equals</h2>
<p>指示其他的某个对象是否与此对象”相等“。</p>
<p>如果没有重写equals方法，那么它将会直接比较两个对象的地址值，我们依然用之前的person对象来做测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        person p1 = <span class="keyword">new</span> person(<span class="string">&quot;瑾介&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        person p2 = <span class="keyword">new</span> person(<span class="string">&quot;瑾介&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(p1.equals(p2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211130438858.png" alt="image-20211211130438858"></p>
<p>比较两个两个对象的地址值几乎没有什么意义，那我们还是来重写一下equals海曙吧。</p>
<p><em><strong>不过这里需要注意的是，这里隐含了一个多态的问题，即我们引入的参数obj是object类的，他无法访问到我们person类的name、age等参数，所以我们需要进行一个向下转型，也就是强制转换：</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">   person person = (person)obj;<span class="comment">//进行强制转换成我们的person类。</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.age==person.age&amp;&amp;<span class="keyword">this</span>.name==person.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211143201551.png" alt="image-20211211143201551"></p>
<p>当然为了防止类型转换异常，我们一般得写一个if条件来判断我们的参数是否是person的父类，完整的重写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> person) &#123;</span><br><span class="line">        person person = (person) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age == person.age &amp;&amp; <span class="keyword">this</span>.name == person.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//不是person类型直接false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="finalize">finalize</h2>
<p>当对象被判定为垃圾对象是，由jvm自动调用此方法，用于标记垃圾对象，进入回收队列。因为Java由自动回收垃圾机制，故平时一般不太会使用。</p>
<h1>String类</h1>
<h2 id="字符串池">字符串池</h2>
<p>字符串是常量，创建后不可以改变，字符串字面值存储在字符串池中，可以共享。</p>
<p>字符串池是位于堆的一个区，为了便于共享而创建的，当创建字符串的时候会先到字符串池里寻找，比如说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name=<span class="string">&quot;jinjie&quot;</span>;<span class="comment">//&quot;jinjie&quot;常量存储在字符串池中</span></span><br><span class="line">        name=<span class="string">&quot;jingjie&quot;</span>;<span class="comment">//新的字符串“jingjie”被创建赋值给了name（“jinjie”就成了废弃物。）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在多加两行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name=<span class="string">&quot;jinjie&quot;</span>;<span class="comment">//&quot;jinjie&quot;常量存储在字符串池中</span></span><br><span class="line">        name=<span class="string">&quot;jingjie&quot;</span>;<span class="comment">//新的字符串“jingjie”被创建赋值给了name（“jinjie”就成了废弃物。）</span></span><br><span class="line">         String name2=<span class="string">&quot;jingjie&quot;</span>;</span><br><span class="line">        System.out.println(name2==name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据共享的原则，这时候创建的name2先到字符串池中寻找有没有“jingjie”，在发现有之后，就把字符串池中“jingjie”的地址也赋值给了name2，所以name2和name的地址是相等的，所以结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211214144031671.png" alt="image-20211214144031671"></p>
<p>另外，我们有两种方式来定义字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name=<span class="string">&quot;jinjie&quot;</span>;</span><br><span class="line">String name=<span class="keyword">new</span> String(<span class="string">&quot;jinjie&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上面一种是我们常用的方法，它只创建了一个对象，但是下面一种方法我们却创造了两个对象，在堆里有一个对象，在字符串池里也有一个对象，但是真正的运行的时候只有一个对象，即堆里的对象也指向字符串池里的对象（所以比较浪费空间。</p>
<p>所以字符串比较要用equals进行比较（String重写了equals方法）。</p>
<h2 id="String的常用方法">String的常用方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;<span class="comment">//返回字符串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//根据下标获取字符。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String str)</span></span>;<span class="comment">//判断当前字符串是否含有str。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray();<span class="comment">//将字符串转化成数组。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span>;<span class="comment">//返回str首次出现的下标，若不存在则返回-1.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> interestinglast <span class="title">IndexOf</span><span class="params">(String str)</span>:<span class="comment">//查找字符串在当前字符串中最后一次出现的下标。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span></span>;<span class="comment">//去掉字符串的前后空格。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">()</span></span>;<span class="comment">//将小写转换成大写。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endWith</span><span class="params">(String str)</span></span>;<span class="comment">//判断字符串是否即以str结尾。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldchar,<span class="keyword">char</span> newChar)</span></span>;<span class="comment">//替换字符。</span></span><br><span class="line"><span class="keyword">public</span> String[] split(String str);<span class="comment">//根据str做拆分。</span></span><br></pre></td></tr></table></figure>
<h2 id="可变字符串">可变字符串</h2>
<p>StringBuilder:可变长字符串，效率快，线程不安全。</p>
<p>StringBuffer:可变长字符串，效率慢，线程安全。</p>
<blockquote>
<p>现在一般使用StringBuilder.</p>
</blockquote>
<p>我们来看个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   StringBuffer n = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">   n.append(<span class="string">&quot;我叫京介！&quot;</span>);<span class="comment">//1.在最后面添加字符。</span></span><br><span class="line">   n.append(<span class="string">&quot;请多指教！&quot;</span>);</span><br><span class="line">   System.out.println(n.toString());</span><br><span class="line">   System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line">   n.insert(<span class="number">0</span>,<span class="string">&quot;你好！&quot;</span>);<span class="comment">//2.在指定位置添加内容。</span></span><br><span class="line">        System.out.println(n.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line">n.replace(<span class="number">0</span>,<span class="number">2</span>,<span class="string">&quot;欢迎！&quot;</span>);<span class="comment">//替换字符串。</span></span><br><span class="line">System.out.println(n.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211215192541609.png" alt="image-20211215192541609"></p>
<h1>BigDecimal类</h1>
<p>float与double类型储存的数据都是近似值（比如1.0就是0.999999……），原因是因为它们采取的是二进制存储。需要精度存储时要使用BigDecimal类来精确计算浮点数。</p>
<p>我们举例来说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> a1=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> a2=<span class="number">0.9</span>;</span><br><span class="line">        System.out.println(a1-a2);</span><br><span class="line">        <span class="comment">//储存近似值。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        BigDecimal b1=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">        BigDecimal b2=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">        BigDecimal r=b1.subtract(b2);<span class="comment">//减法</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        BigDecimal r1=b1.add(b2);<span class="comment">//加法</span></span><br><span class="line">        System.out.println(r1);</span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        BigDecimal r2=b1.multiply(b2);<span class="comment">//乘法</span></span><br><span class="line">        System.out.println(r2);</span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        BigDecimal r3=b1.divide(b2,<span class="number">2</span>,BigDecimal.ROUND_HALF_UP);<span class="comment">//除法</span></span><br><span class="line">        System.out.println(r3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用BigDecimal进行运算时是调用BigDecimal的方法，值得注意的是，在使用BigDecimal的除法方法的时候，如果出现除不尽的现象的话，程序将会报错，所以这时3要使用到divide除法方法的重载方法，在参数的后面添加保留的小数位数以及保留的方法</p>
<blockquote>
<p>保留方法的参数是Bigdecimal的几个常量，BigDecimal.ROUND_HALF_UP的意义即为四舍五入。</p>
</blockquote>
<p>结果是：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211215195425390.png" alt="image-20211215195425390"></p>
<h1>System类</h1>
<p>系统类是静态的，直接使用就可以，下面我列举几个方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static void arraycopy(……)</td>
<td>复制数组</td>
</tr>
<tr>
<td>static void currentTimeMillis();</td>
<td>获取系统当前时间（返回毫秒值）</td>
</tr>
<tr>
<td>static void gc();</td>
<td>建议JVM回收垃圾</td>
</tr>
<tr>
<td>static void exit(int status);</td>
<td>退出JVM</td>
</tr>
</tbody>
</table>
<h1>++包装类</h1>
<p>对于基本数据类型所拓展的包装类型，这样基本数据类型就可以实现更多的方法和功能。</p>
<blockquote>
<p>实际上，更深层的原因是Java不在支持指针操作，因此创造出了内部类的功能使得数据能在堆和栈之间进行转换。</p>
</blockquote>
<p>其包装类对应如下：</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody>
</table>
<p>每一种包装类型都由更多的方法与属性。</p>
<h2 id="装箱、拆箱">装箱、拆箱</h2>
<p>装箱：把栈里面的东西装到堆里面去（基本类型转换为引用类型）。</p>
<p><em>一般通过引用类型的构造方法实现，比如：</em><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212144744804.png" alt="image-20211212144744804"></p>
<p>拆箱：把堆里面的东西装到栈里面去（引用类型转换为基本类型）。</p>
<p><em>一般通过number类（包装类型的父类）的方法进行拆箱</em>*，比如：*</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212172036602.png" alt="image-20211212172036602"></p>
<blockquote>
<p>JDK1.5之后，java开始提供自动装箱和拆箱……意思是直接用赋值符号就行了。但其背后的实质是一样的，只是Java在背后帮我们自动操作了。</p>
</blockquote>
<h2 id="类型转换">类型转换</h2>
<h3 id="1、基本类型与字符串类型转换">1、基本类型与字符串类型转换</h3>
<h4 id="1-1使用-号">1.1使用+号</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ni=<span class="number">10</span>;</span><br><span class="line">String s1=n1+<span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="1-2使用tostring方法">1.2使用tostring方法</h4>
<p>使用Integer中的tostring()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s2=Integer.toString(ni);</span><br><span class="line">String s2=Integer.toString(ni，<span class="number">16</span>);<span class="comment">//此方法可以重载，按十六进制进行转换。 </span></span><br></pre></td></tr></table></figure>
<h3 id="2、字符串类型与基本类型转换">2、字符串类型与基本类型转换</h3>
<h4 id="2-1使用Integer的parse方法">2.1使用Integer的parse方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">&quot;150&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> n=Integer.parse(str);<span class="comment">//str里只能有数字。</span></span><br></pre></td></tr></table></figure>
<h3 id="3、Boolean字符串转换为基本类型">3、Boolean字符串转换为基本类型</h3>
<p>依旧使用parse进行格式化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str2=<span class="string">&quot;true&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> b1=Boolean.parseBoolean(str2);<span class="comment">//只用true能被格式化为true,其它字符均为false。</span></span><br></pre></td></tr></table></figure>
<h2 id="整数缓冲区">整数缓冲区</h2>
<p>Java预先创建了256的常用的整数包装对象，在实际的应用当中，对已经创建的对象进行复用。</p>
<p>我们来举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer integer1 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">        Integer integer2 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">        System.out.println(integer1==integer2);</span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        Integer integer3=<span class="number">100</span>;<span class="comment">//自动装箱</span></span><br><span class="line">        Integer integer4=<span class="number">100</span>;</span><br><span class="line">        System.out.println(integer4==integer3);</span><br><span class="line">      	Integer integer5=<span class="number">200</span>;</span><br><span class="line">        Integer integer6=<span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>猜猜看会输出什么？</p>
<p>表面上都是生成代表int值100的Integer类型，但结果是：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212180010477.png" alt="image-20211212180010477"></p>
<p>为什么会出现这种情况呢？这是因为integer1与integer2是new出来的，属于不同的地址，“==”比较的是地址值，第一个当然不同。</p>
<p>第二个为自动装箱，调用的都是Integer的valueof方法。那我们来看一下valueof方法：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212180440932.png" alt="image-20211212180440932"></p>
<p>是不是发现只要参数是在一定范围里的int，那么就返回了一个cache数组里的元素？</p>
<p>我们再来具体的看一看具体的数和cache数组：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212180855001.png" alt="静态中间那坨可以忽略"></p>
<p><em>静态中间那坨可以忽略，为的是最后的high=h</em></p>
<p>这，就是我们的整数缓冲区，一个名为cache的数组，最高high为127，low为-128，所以我们的integer3与integer4是同一个，已经被实例好的对象，所以就是相等的咯。</p>
<p>当然，相信大家都发现了，integer5与integer6的int数字是大于了127的，所以执行相应语句，也就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br></pre></td></tr></table></figure>
<p>那这自然就跟1、2的结果是一样的了。</p>
<h1>日期时间类</h1>
<h2 id="Date类">Date类</h2>
<p>类Date表示特定的瞬间，精确到毫秒。</p>
<blockquote>
<p>毫秒，即为千分之一秒。</p>
</blockquote>
<p>毫秒值一般用于计算日期的间隔，即将日期都转换成毫秒值进行加减，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.currentTimeMillis()<span class="comment">//可以输出当前系统时间距离时间原点1970年1月1日凌晨经历了多少毫秒</span></span><br></pre></td></tr></table></figure>
<h3 id="无参构造">无参构造</h3>
<p>直接实例化一个无参构造的Date类，打印出来将是我们系统的标准时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">date</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">			text();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">text</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211150504218.png" alt="image-20211211150504218"></p>
<p>这里的CST指的是中国标准时间。</p>
<h3 id="带参的构造方法">带参的构造方法</h3>
<p>Date类还可以使用带参的构造方法，此时参数为从时间原点开始的毫秒值，列如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date(<span class="number">0</span>);<span class="comment">//将上面的代码块的构造方法添加为0的参数。</span></span><br></pre></td></tr></table></figure>
<p>此时它就会打印：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211151139834.png" alt="image-20211211151139834"></p>
<p>即为打印时间原点。</p>
<h3 id="gettime-方法">gettime()方法</h3>
<p>将日期转换成毫秒值，返回的是一个long类型的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">      <span class="keyword">long</span> s=date.getTime();</span><br><span class="line">      System.out.println(s);</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211151520479.png" alt="image-20211211151520479"></p>
<h2 id="DateFormat类">DateFormat类</h2>
<p>是对时间与日期进行一个格式化的抽象类，属于Java.text包中，有两个作用：</p>
<p>格式化：从日期转到文本[String format(Date date)]</p>
<p>解析：从文本转到日期[Date parse(String source)]</p>
<p>由于DateFormat是一个抽象类，所以我们要用到他的子类SimpleDateFormat进行对日期格式的约束。</p>
<blockquote>
<p><code>SimpleDateFormat</code> 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt;  文本）、解析（文本 -&gt; 日期）和规范化。</p>
</blockquote>
<h3 id="格式化">格式化</h3>
<p>要相对时间进行一个格式化的输出，需要用到SimpleDateFormat里的format方法，那我们首先的得创建一个**”模式“**，通过这个模式来告诉我们的类应该怎样输出时间，在SimpleDateFormat类中，模式通过字母来代表创建，下面我们列举一些常用的代表：</p>
<table>
<thead>
<tr>
<th>字母代表</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody>
</table>
<p>所以我们可以写出类似于： <strong>”yyyy-MM-dd  HH:mm:ss“</strong>   这样的时间格式。</p>
<p>来创建一个SimpleDateFormat类试试吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">demo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SimpleDateFormat t1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日HH:mm:ss&quot;</span>);<span class="comment">//模式作为参数传入SimpleDateFormat类。</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();<span class="comment">//创建一个时期类</span></span><br><span class="line">        String time;</span><br><span class="line">        time=t1.format(date);<span class="comment">//用方法来格式化我们的日期类.</span></span><br><span class="line">        System.out.println(time);</span><br><span class="line">        System.out.println(date);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211155207944.png" alt="image-20211211155207944"></p>
<h3 id="解析">解析</h3>
<p>使用SimpleDateFormat里的parse方法，可以将一段字符串日期转换为Date类日期。</p>
<p>这里值得注意的是，如果字符串日期的模式与设定的模式不相符合的话，parse方法会抛出一个异常，这时我们要么使用throw继续向上抛出异常，要么使用try  catch自己进行处理。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">demo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SimpleDateFormat t1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日HH:mm:ss&quot;</span>);<span class="comment">//模式作为参数传入。</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        String time;</span><br><span class="line">        time=t1.format(date);</span><br><span class="line">        Date d1 = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//使用try catch来监控</span></span><br><span class="line">            d1=t1.parse(time);</span><br><span class="line">            System.out.println(d1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">           System.out.println(<span class="string">&quot;格式出错&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211163615731.png" alt="image-20211211163615731"></p>
<p>如果我们使用不一样的时间的话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat t2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年dd日MM月HH:mm:ss&quot;</span>);<span class="comment">//模式作为参数传入。</span></span><br><span class="line">d1=t2.parse(time);<span class="comment">//修改要捕获异常的语句</span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211164157365.png" alt="image-20211211164157365"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>零日之恋人</title>
    <url>/2021/12/19/%E9%9B%B6%E6%97%A5%E4%B9%8B%E6%81%8B%E4%BA%BA/</url>
    <content><![CDATA[<p>瑾介不知道葭玟是什么时候计划好的。</p>
<p>他依然活在过去，像个永远长不大的孩子，对爱恨没有那么深刻的认识。</p>
<p>“就算与亥氧分手分手以后……”</p>
<p>葭玟在网络上对着瑾介说。</p>
<p>瑾介不敢想象葭玟是怀着什么样的心情说下去的，他只知道自己的大脑一片空白，有许多的回忆喷涌而出，瑾介闭着眼拼命地想束缚住它们。</p>
<p>“我可能都……”</p>
<p>喷涌到达了极点，瑾介想起他在修脚店切除嵌甲时把甲根连根拔起的最后一刻，旁人都焦急地注视着状况，修脚师傅一头大汗，瑾介痛得呲牙咧嘴也感觉武士拔刀的最后时机已经到来。</p>
<p>“不会吃回头草。”</p>
<p>断了，不过，是嵌甲永远地断在里面了。准备折磨瑾介一辈子。</p>
<p>记忆安分了下来，静静地盘旋在他们主人的周围，希望能够给瑾介些许安慰。</p>
<p>瑾介开始想。</p>
<p>他拼命地想，他撕扯着周围的回忆，想要找到答案。</p>
<p>这些天是为了什么？</p>
<p>为了报复？为了利益？还是说，为了结束？</p>
<p>瑾介又开始怀疑起了自己，又是一次错过或是自作多情？自我意识过剩？还有值得分析下去的必要吗？</p>
<p>这些天的快乐是毋庸置疑的，即使是瑾介自己也无法否认，瑾介感觉自己获得了新生，更像高中那个时候的自己了。</p>
<p>但是瑾介看到的葭玟也是一样的，确实是高中时期的她。</p>
<p>是后来的所有还没发生的她。</p>
<p>瑾介又尝到的那种类似与考试快要结束试卷还没翻页的惊慌无措之感。</p>
<p>时间已经过去了五分钟，瑾介知道必须要说点什么。</p>
<p>他选择了半天，还是选择自己性格导致的必然结果。</p>
<p>“我还是会一直支持你的。”</p>
<p>瑾介本以为自己永远不会再说出这句话，瑾介这是第一次尝试对她给与自己最大的陪伴和交流，瑾介看着葭玟不断的笑容感到满意。</p>
<p>“快去睡觉吧，笨蛋”</p>
<p>瑾介毫无反应，甚至开始感受到丝丝尴尬。</p>
<p>他敢再想吗？他不能再想了，错的，全是错的，谁才是真正的小丑，瑾介想到了什么。总之，不能再想了。</p>
<p>他睁开了眼，看到了自己最不愿意看到的画面。</p>
<p>葭玟在漆黑的屋子里，躺在床上，抱着枕头上，无声地抽泣着。</p>
<p>瑾介看着这幅画面，身体一时动弹不得，他自己也不知道自己在等待着什么。</p>
<p>葭玟坐了起来，背对着瑾介，看起来是那样孤独弱小，然后她的手伸向了手机。</p>
<p>这时瑾介像是被诅咒一般发疯地把这副画面撕得粉碎，直到最后一片碎片落向地面消失不见。然后呆呆地坐在地上，掩面流泪。</p>
<p>旁边的手机显示送达了最新的消息。</p>
<p>“所以……”</p>
<p>“哥哥？”</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>记录</category>
      </categories>
      <tags>
        <tag>时间的恋人</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>用logisim实现4位先行进位</title>
    <url>/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/</url>
    <content><![CDATA[<h3 id="实验目的：">实验目的：</h3>
<p>掌握快速加法器中先行进位的原理，能利用相关知识设计4位先行进位电路，并利用设计的4位先行进位电路构造4位快速加法器，能分析对应电路的时间延迟。</p>
<h3 id="实验结果：">实验结果：</h3>
<img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/图片9.png" style="zoom:80%;">
<h3 id="实验过程及结果分析：">实验过程及结果分析：</h3>
<p>由于串行加法器在每一位的加法时需要等待下一位的进位后才能进行加减，这就导致了时间的大量浪费，如果我们能够提前知道进位（先行进位）的话，这样的话后位的加减不用等着前位的进位，时间将会大大缩短。</p>
<p>所以，有规定为：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/%E5%9B%BE%E7%89%876.png" alt></p>
<p>所以，一位加法的所有进位形态分为进位取消、进位传播、进位产生，在这里我们只关心进位传播与进位产生，列出全加器的运算公式：</p>
<p>$$<br>
Si=ai⊕bi⊕ci;<br>
Ci+1=ai*bi+（ai⊕bi）*ci<br>
$$</p>
<p>这是每一位的结果，根据我们刚才的分类pi（进位传播项）=ai⊕bi、gi（进位产生项）=ai*bi我们可以得到全加器的公式变形：</p>
<p>$$<br>
Si=pi⊕ci;<br>
Ci+1=gi+pi*ci<br>
$$</p>
<p>这就是我们每一位求出来的值，pi、gi都只与ai与bi有关，故我们只需要求出ci即可，但是ci又与上一位ci有关系，我们将所有ci的运算公式列出：</p>
<img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/图片7.png" style="zoom:80%;">
<p>而我们将ci依次带入后一位得：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/%E5%9B%BE%E7%89%878.png" alt></p>
<p>所以现在所有值都只与ai、bi、c0有关了，我们就可以通过ai、bi和c0直接算出每一位的值而不再需要等待进位了。</p>
<p>将p1，g1，c0表示出来:</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/%E5%9B%BE%E7%89%8710.png" alt></p>
<p>用电路表示超前进位即为：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/%E5%9B%BE%E7%89%879.png" alt></p>
<blockquote>
<p>有问题请通过旁边的对话窗口联系京介喔。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
        <category>硬件设计</category>
      </categories>
      <tags>
        <tag>logisim</tag>
      </tags>
  </entry>
  <entry>
    <title>4位快速加法器的设计</title>
    <url>/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="4位快速加法器的设计">4位快速加法器的设计</h2>
<h3 id="实验目的：">实验目的：</h3>
<p>掌握快速加法器中先行进位的原理，能利用相关知识设计4位先行进位电路，并利用设计的4位先行进位电路构造4位快速加法器，能分析对应电路的时间延迟。</p>
<h3 id="实验结果：">实验结果：</h3>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8711.png" alt></p>
<h3 id="实验结果分析：">实验结果分析：</h3>
<p>因为我们已经完成了的4位先行进位，（什么？你没什么印象？<a href="https://tosuke.gitee.io/2021/12/07/4%E4%BD%8D%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D74182/">点我马上传送</a>现在我们可以来来实现4位快速加法器，没错，其实4位快速加法器就是根据我们第三个实验的原理而来，实验三所写的4位先行进位现在在4位快速加法器里是重要的中心电路。</p>
<p>第一步先准备一下我们需要的输入输出：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8712.png" alt></p>
<p>然后对应好我们之前的4位先行进位的电路封装：</p>
<img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/图片13.png" style="zoom:80%;">
<img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/图片14.png" style="zoom:80%;">
<p>确认好我们的电路封装后，那我们先来输入我们的P1、P2等Pi输入，因为</p>
<pre><code>                          **Pi=ai⊕bi  Gi=ai*bi**
</code></pre>
<p>所以我们将xi、yi连上异或门连上电路封装的pi输入，将xi、yi连上与门连上电路封装的gi输入，最后不要忘了连上C0的输入：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8715.png" alt></p>
<p>那我们输入就算完成了，现在来看看电路封装的输出部分，我们电路的电路的输出分别是Ci和p*、g*成组先进函数，又因为我们推出的运算公式中：</p>
<p>​														Si=Pi⊕Ci</p>
<p>所以我们需要将封装电路输出的Ci与Pi连上异或门再输出给Si，由于在上一步已经制造了Pi，所以连接如图：</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8716.png" alt></p>
<p>最后连接上代表最高位进位的C4与p*、g*成组先进函数，电路图就链接好了。</p>
<p><img src="/2021/12/07/4%E4%BD%8D%E5%BF%AB%E9%80%9F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%89%8717.png" alt></p>
<blockquote>
<p>有问题请通过旁边的对话窗口联系京介喔。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
        <category>硬件设计</category>
      </categories>
      <tags>
        <tag>logisim</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE的部分要点</title>
    <url>/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/</url>
    <content><![CDATA[<h1>scanner</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">scanner.hasnextline()  <span class="comment">//判断是否还有输入</span></span><br></pre></td></tr></table></figure>
<p>next（）与nextLine（）的区别；</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208161159615.png" alt="image-20211208161159615"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sacanner.nextLine(); <span class="comment">//可以接受空白，以回车为结束。</span></span><br><span class="line">scanner.close();   <span class="comment">//关闭scanner</span></span><br></pre></td></tr></table></figure>
<h1>增强for循环</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x:数组名)&#123;</span><br><span class="line">  system.out.println(x);</span><br><span class="line">  <span class="comment">//遍历数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>给main函数传递参数</h1>
<p>找到包的路径下，在命令行中进行编译，运行。</p>
<h1>可变参数</h1>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208164227825.png" alt="image-20211208164227825"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>... i)</span></span>&#123;</span><br><span class="line"> system.out.println(i[]);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//此时i为可变参数，可输入多个值,i也就可能成为一个数组。</span></span><br></pre></td></tr></table></figure>
<h1>递归</h1>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208164910624.png" alt="image-20211208164910624"></p>
<h1>继承和多态</h1>
<p>静态方法是类的方法，非静态的方法是对象的方法。</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208211748858.png" alt="image-20211208211748858"></p>
<p>我们的person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我开动了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>student类继承person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">student</span> <span class="keyword">extends</span> <span class="title">person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生的事怎么能叫吃呢？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我要学习了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>text类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">texi1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        student  s1=<span class="keyword">new</span> student();</span><br><span class="line">        person s2=<span class="keyword">new</span> student();</span><br><span class="line">s1.eat();</span><br><span class="line">s2.eat();</span><br><span class="line">s1.learn();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208215628894.png" alt="image-20211208215628894"></p>
<h2 id="多态（只针对方法）：">多态（只针对方法）：</h2>
<p>同一方法可以根据发送对象的不同采取多种不同的行为方式，一个对象的实际类型是知道的，但指向对象的引用类型有很多，比如父类的引用指向了子类的对象。</p>
<p>执行方法先看类里面的静态方法（静态方法属于类的，不属于对象），再看对象实际类型对应的方法。</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211208214431807.png" alt="image-20211208214431807"></p>
<h1>instanceof与类型转换</h1>
<p>instanceof会判断两个类的继承关系，兄弟关系则会报错。</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209175621741.png" alt="image-20211209175621741"></p>
<p><em>底类转高类不需要强制转换。</em></p>
<p><em>高类转底类需要进行强制转换</em></p>
<p>子类转换为父类可能会丢失一些方法（子类te’you）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object s1 = <span class="keyword">new</span> student(); </span><br><span class="line"><span class="comment">//底类转高类不需要强制转换</span></span><br><span class="line">person s2 = (student) s1;          <span class="comment">//高类转底类需要进行强制转换</span></span><br><span class="line">s2.eat();</span><br><span class="line">student s3 = (student) s2;</span><br><span class="line">s3.eat();</span><br><span class="line">s3.learn();</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209182350137.png" alt="image-20211209182350137"></p>
<blockquote>
<p>这里插入一个我突然看到的，对于对象和实例区别的一个例子：</p>
<p>父母口中的女朋友（对象），怀里搂着的她（实例）。</p>
<p>（精辟无敌）</p>
</blockquote>
<h1>抽象类与接口</h1>
<h2 id="抽象类">抽象类</h2>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209182856546.png" alt="image-20211209182856546"></p>
<blockquote>
<p>抽象类：给予类约束，让其他人帮我们实现。继承了抽象类的类必须重写抽象类所有的抽象方法（除非自己也是抽象类）。我们一般把他们叫做资本家与被压榨的苦力。</p>
</blockquote>
<p>生成一个抽象类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 资本家 </span>&#123;</span><br><span class="line">    <span class="comment">//来帮我写个方法,我只给需求，我就不写了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">ganfan</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以及一个苦力：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 被压榨的苦力 <span class="keyword">extends</span> 资本家 </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ganfan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我为老板冲锋陷阵！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        被压榨的苦力 苦力<span class="number">1</span> = <span class="keyword">new</span> 被压榨的苦力();</span><br><span class="line">        苦力<span class="number">1.</span>ganfan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209184432977.png" alt="image-20211209184432977"></p>
<h2 id="接口">接口</h2>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209184503107.png" alt="image-20211209184503107"></p>
<p>接口全是抽象方法还有静态常量，只有由别人实现。即接口全是要求，资本家自愧不如。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">service</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有对象皆抽象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> speed)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">get</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> age=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个类实现两个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">serviceimpl</span> <span class="keyword">implements</span> <span class="title">service</span>,<span class="title">get</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lost</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用接口实现多继承,接口不能被实例化~接口中没有构造方法。</p>
<h1>内部类</h1>
<h2 id="成员内部类">成员内部类</h2>
<p>定义一个内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外面的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">in</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是里面的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个内部对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        text t1 = <span class="keyword">new</span> text();</span><br><span class="line">        text.in in1 = t1.<span class="function">new <span class="title">in</span><span class="params">()</span></span>;</span><br><span class="line">        t1.out();</span><br><span class="line">        in1.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209190853396.png" alt="image-20211209190853396"></p>
<p><strong>内部类可以操纵外部类的私有属性，这是它的特点（毕竟是亲生的）。</strong></p>
<h2 id="静态内部类">静态内部类</h2>
<p>也就是定义内部类时加上static，需要时注意的是，如果内部类被静态化，那么这个静态内部类也许就不能访问外部类的私有属性了（静态内部类相当于预加载），除非该私有属性也是静态的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外面的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">in</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是里面的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="局部内部类">局部内部类</h2>
<p>在方法里定义的类（类如局部变量）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">in</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是里面的&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外面的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类">匿名内部类</h2>
<p>new出来直接用，没有名字初始类，不用将实例保存到类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        id=<span class="keyword">new</span> Scanner().nextInt();</span><br><span class="line">        <span class="comment">//没有创建scanner类.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>异常机制</h1>
<h2 id="异常">异常</h2>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211209193513675.png" alt="image-20211209193513675"></p>
<p><strong>异常也是一种对象</strong></p>
<p>当遇到异常或者是错误时，Java会抛出异常对象，可以对其进行捕获处理（尤其是异常）。</p>
<h2 id="异常处理">异常处理</h2>
<h3 id="五个关键字">五个关键字</h3>
<p>try:尝试捕获异常的监控区。</p>
<p>catch：捕获异常（括号里为想要捕获的异常类型）。</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211210195637949.png" alt="image-20211210195637949"></p>
<p>finally：无论执不执行最后都要走的（一般用于善后工作）。</p>
<p>throw：主动抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException();</span><br></pre></td></tr></table></figure>
<p>throws：方法调用时抛出，</p>
<p>写个报错程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(b/a);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;有问题&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;<span class="comment">//善后处理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ctrl+alt+t可以快速构造代码块框架，包括try|catch语句。</p>
</blockquote>
<p>输出：</p>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211210201559270.png" alt="image-20211210201559270"></p>
<h2 id="自定义异常">自定义异常</h2>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211210202529797.png" alt="image-20211210202529797"></p>
<p>比如数字大于10，我们设计的异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myexception</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> detali;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Myexception</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.detali=a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Myexception&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;detali=&quot;</span> + detali +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="number">11</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Myexception e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> Myexception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Myexception(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;正常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/10/JavaSE%E7%9A%84%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9/image-20211210203653004.png" alt="image-20211210203653004"></p>
<h1>结束</h1>
<p>JavaSE大体部分就到此结束！</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2021/10/26/hello-world/</url>
    <content><![CDATA[<p>你好，我的同志，这是我的第一篇博客，显而易见的是我正在学习中，所以页面会非常粗糙，还请见谅！</p>
<h2 id="起源">起源</h2>
<h3 id="一开始">一开始</h3>
<p>建立博客的缘由是因为几位朋友都有了属于他们自己的博客，这让我很感兴趣。</p>
<p>第一步</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="后来嘛">后来嘛</h3>
<p>上网找教程，最后选择了hexo+gitee（码云）的方式部署博客，期间遇到了很多问题，后来大部分都慢慢解决了，但还是有一些现在还没<br>
解决的问题。<br>
比如说：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git@gitee.com: Permission denied (publickey)</span><br></pre></td></tr></table></figure>
<p>配置的ssh明明完美无缺，可通讯还是不行，我猜测是因为我windows用户名是中文的原因，还得再试试。</p>
<h3 id="而现在">而现在</h3>
<p>我之前有一个团队网站，为了测试我把它放在这里。</p>
<p>More info: <a href="http://tocode.e.cn.vc/2">Tocode团队</a></p>
<h3 id="在未来">在未来</h3>
<p>我会继续努力的，总之感谢大家了！</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>感想</category>
      </categories>
      <tags>
        <tag>关于</tag>
      </tags>
  </entry>
  <entry>
    <title>新泽没有夏天</title>
    <url>/2021/12/05/%E6%96%B0%E6%B3%BD%E6%B2%A1%E6%9C%89%E5%A4%8F%E5%A4%A9/</url>
    <content><![CDATA[<h1>新泽没有夏天</h1>
<h2 id="新泽没有夏天（一）">新泽没有夏天（一）</h2>
<p>暴雨如期而至。雨珠打翻了枯叶，搅混了池塘，空中弥漫着泥土的气息，池塘里的鱼群惊慌失措，仿佛因为看不清前途命运而焦躁不安。</p>
<p>叶瑾介当时也是在这种时候到达新泽的。</p>
<p>虽说新泽阴雨连绵，很少能够见到阳光，但对于参加过高考的叶瑾介来说，这注定会是他通往梦想的地方。</p>
<p>“新泽没有夏天”</p>
<p>叶瑾介曾发过誓，要与高中时的那个家伙分道扬镳。</p>
<p>叶瑾介口中的那个家伙，实际上是他的高中同桌，一个留着马尾的女生。</p>
<p>叶瑾介中考时翻了改变人生的车，那段时间，他在痛哭流涕中听说父母花了巨款强行将自己转到了本地的一所不太妙的高中，那是叶瑾介之前从未想象过的今后三年会去的地方，叶瑾介惊了，联想到自己的尊严，一抹眼泪，决定要发声抗议。</p>
<p>最近刚高考完的大学生叶瑾介不知为何经常想起自己中考后的日子，所以有时晚上经常睡不着，再说新泽的天气非常寒冷，能正常入睡和醒来实属罕见。</p>
<p>”目前是离夏天尚有一段时间的季节，所以有些冷也是正常的。”叶瑾介在早上被冻醒后已经开始条件反射的这样想。</p>
<p>叶瑾介早早地来到了图书馆自习，却发现熟悉的位置已经拥有主人，瑾介微微愣了一下，但很快便面色如常，随便找了个地方坐了下来。甩下书包，拉开拉链，拿出平板电脑，最后再接上电源，一套动作悉如平常，不过大脑不再像平常一样想着动态规划等种种，而是多了一道灰色的模糊身影，当然不会有其他答案，他想的是坐在他曾经位置上的少女。对于叶瑾介这种青春少年来说，这些看似平常的邂逅总能引发他的无限遐想，他回想起高中的时光，那时候，叶瑾介在班上还算是个帅哥，一些未曾知晓世界广阔的女生闲来无事时还曾经追求过他，这也是后来他进入大学后依然产生了“我也算是个抢手货”的错觉的原因。大学后的叶瑾介也确实基本放弃了在大学找个女朋友的想法，他目前的计划寄托在自己出国的这件事上。</p>
<p><img src="/2021/12/05/%E6%96%B0%E6%B3%BD%E6%B2%A1%E6%9C%89%E5%A4%8F%E5%A4%A9/IMG_38951562_1.jpg" alt></p>
<p>当然，到最后他与那位灰色的少女也没有发生任何的交集，因为当叶瑾介想起自己的充电器还长年的放在那里的并准备用这个理由去打个招呼时，那个少女早就消失不见了。叶瑾介懊悔地怪自己自己怎么偏偏就昨晚想起了给手机充电，导致了自己错失了因为手机没电了而导致的一系列事件。</p>
<p>“一开始就已经进入bad ending了啊……”叶瑾介心里默默地这样想，但他也并不感到难过，毕竟他知道自己犹豫不决的时间一定要比手机没电的时间长。说白了，叶瑾介，某些情况下，是个阿宅。</p>
<p>下午是一节高等数学，明明自己睡了午觉的，脸部肌肉却依然忍不住地抽搐，这是叶瑾介即将入眠的征兆。“要是这节课再睡着了，那我以后还是别来这节课了吧，自己自学好了。”</p>
<p>这明明是督促自己不要睡觉的想法，叶瑾介却发现自己有种做出承诺安下心来的快感，防线不攻自破，叶瑾介很快的睡了过去。</p>
<p>“你们没有权力替我做决定！”</p>
<p>想要冲向父母房间、还在为中考烂摊子苦恼的叶瑾介本来是想用这句绝妙的话来大声向父母反抗的，站在门口时却猛地想起自己的成绩应该就读蓝翔技校的，相较于蓝翔，这所差点的高中好像也还行，毕竟还是个公立学校，寝室听说也还不错……正当叶瑾介进行头脑风暴，拼命搜刮着自己所知的有关那个高中所有优点时，一声惬意的鼾声从房间传了出来，叶瑾介心中顿时涌起了一股暖流。</p>
<p>高中开学那天，叶瑾介抱着头脑风暴的成果去了学校，报道流程结束后，叶瑾介绕着学校转了一圈，没人知道叶瑾介这是在干什么，但有人看见了他最后坐在食堂门前的椅子上发出了一声悲鸣。叶瑾介自己知道，自己在这里和当年初中班上成绩榜郊区的同学打招呼时，是有些尴尬的，更何况自己是被一笔钱塞进来的，叶瑾介在那时就决定了，在高中，努力学习，一飞冲天。抱着做鸡头的想法，叶瑾介飘飘然地感到一阵眩晕。</p>
<h2 id="新泽没有夏天（二）">新泽没有夏天（二）</h2>
<p>再次醒来是因为下课准点时同学们不约而同的收拾离场声，此时高数老师还在讲台上高声呼喊着什么，叶瑾介虽然生理上起了反应，精神上还是一片混沌，他好像梦到了自己当年的高中生活，却又完全没记住任何细节。</p>
<p>“嗯……”一道低吟猝不及防地响起。</p>
<p>“哇！”叶瑾介本能地后仰，打翻了未曾翻开的高数上，回头发现了一个紫发少女正认真地看着自己的脸。</p>
<p>“呃……阔你几哇？”叶瑾介一紧张就容易说烂话。</p>
<p>紫发少女少女仍然默默坐在旁边，一言不发，只是神色越加疑惑。</p>
<p>本就社恐的叶瑾介更加局促不安，心中暗骂该死，自己说的什么烂话，搞的气氛更加尴尬了，还是应该正常一点，先从最基本的开始吧，叶瑾介清了一下嗓子，开口道：</p>
<p>“你叫……”</p>
<p>“蕾妤。”</p>
<p>还没等叶瑾介问完，少女就已经说出了答案，叶瑾介硬生生把后半句咽了回去，他发现喉咙好像有东西堵在那里了。</p>
<p>“你为……”</p>
<p>“因为我是数学课代表，整个教室都已经走光了，就你在这里发呆。”少女移开了目光，似乎感受到了叶瑾介的惊讶，轻松地对着叶瑾介笑了一下，顺手捡起了叶瑾介的高数书“只是一场考试的失利罢了，对你影响有这么大吗？另外，没有梦见我想要的东西喔。”</p>
<p>自称蕾妤的紫发少女再次看向叶瑾介，充满了戏谑的意味。</p>
<p>而叶瑾介没有反应过来，硬塞回了两句话，他再也忍不住了，对着少女，惬意地打了一个长长的嗝。</p>
<p>新泽没有夏天</p>
<p>“世界线？”叶瑾介好奇地问。</p>
<p>“嗯，这就是我的能力，可以和不同世界线的人沟通。”蕾妤耸了耸肩，侧过身去，紫色的短发随着身体弯曲成了优雅的弧线，轻贴在五官精致的小脸旁。叶瑾介想起了他高中的同桌，那时他偷瞄的，似乎也是这样的景象。</p>
<p>“啊不…我是觉得…呃…世界线是什么……”</p>
<p>叶瑾介在空无一人的教室，看着少女的侧脸，这样的氛围使得叶瑾介几乎无法呼吸，抱着“我这难道是要死了吗”的疑问，口齿不清地回答到。</p>
<p>“这样给你说吧，每个人的命运有无数多种，列如你，叶瑾介，有的你大富大贵，一生极尽奢侈。有的你却家道中落，一生苦难，最后病死在囚笼。有的你一生碌碌无为，最后的离去有如一片枯叶，无人在意。有的你却在万人之上，统治着半个世界。”</p>
<p>蕾妤神情恍惚，双手蜷缩在一起，把头埋进了臂弯。</p>
<p>“如今的你，便是以往所以世界线的随机排列组合。像是亿万不甘平静的灵魂，仍在创造追寻着不同的结局。而且，世界线拥有不同的载体，就像是一帧电影，一篇小说，一张照片，甚至是一句话。从不同的世界线来观测我们，我们的世界也许就是那样的。”</p>
<p>“呃，意思是，我们在其他世界的存在形式，也许只是一部小说？”</p>
<p>“嗯，对啊，也许还是质量很次的那种呢。”蕾妤抬头轻轻笑了一下。</p>
<p>“我们的世界…也许是一部小说？”叶瑾介又疑惑地重复了一遍，他望着周围空荡荡的教室，黑板上还有高数老师留下的满满的板书，一切都是那么的真实，叶瑾介很难想象这个世界在其他世界仅仅是用文字描绘的图像。叶瑾介感觉眩晕，不知在何处好像缺失了点什么。</p>
<p>“你也不用太紧张了，世界线的本质都是一样的，不同的载体只不过是观测其他世界的窗口而已。毕竟……”蕾妤突然转过头来，认真地盯着叶瑾介的眼睛，缓缓地说到</p>
<p>“世界线就是命运。”</p>
<p>“在我们的世界线周围，还环绕着另外一条世界线，那是我们的孪生世界。就像人类的双胞胎一样，不过概率低的可怕，人类DNA碱基的数量，比起世界线的数量来说，简直可以忽略不计。无论从什么角度上来说，这都是个奇迹。但是，奇迹，不总是带来好事。”</p>
<p>蕾妤离开了座位，站到窗边，眺望着楼下来来往往的人们，神色略显哀伤，叶瑾介。似乎听见她在轻轻叹息。</p>
<p>这位窥探命运的使者，难道是在为自己的命运所叹息吗？</p>
<p>叶瑾介的脑海不知为何突然出现这样的想法。</p>
<p>夕阳为蕾妤镀上了一层金边，这条金边一直延伸到了叶瑾介手边，叶瑾介很想抓住那道光。靠在窗边的瘦小身影像是在忍受着什么。叶瑾介抑制住想要上去抱住她的冲动，默默地坐在原地看着她。叶瑾介知道，他不可能成为那样的一个像是英雄的人。</p>
<p>“你就不会说句话吗，真是的。”蕾妤转头略微埋怨。</p>
<p>“呃…我不是很懂啊。”叶瑾介知道，自己又在说废话。</p>
<p>蕾妤看了看手上的表，眉头微微皱起。</p>
<p>“我只能简单的给你解释一下，我们两个孪生世界线非常相似，几乎可以说是一模一样，我们世界有的东西，那个世界也有。但我们发现这两条世界线越靠越近，可能在不久的将来会发生融合。”</p>
<p>“融合？”</p>
<p>“在我们的认知范围内，曾有幸了解到世界线的上一次融合。”</p>
<p>“那……会怎样？”</p>
<p>“世界上的所有东西，两个世界，只会留下其中的一份。”</p>
<p>“等等，也就是说那个世界还有一个我吗？！”叶瑾介突然想到。</p>
<p>“是的，在另一个世界，有一个和你差不多的家伙，也有和我对应相似的人，算是沟通我们两个世界的桥梁。”</p>
<p>蕾妤伸了个懒腰。</p>
<p>叶瑾介愣在座位上，一动不动。</p>
<p>“总之，今天和你说的太多了，不知道是好是坏，回去好好想想吧。”</p>
<p>蕾妤轻轻地从桌子上跃了下来，开始往教室门口的方向走去。</p>
<p>“等等，我还有一个问题！”叶瑾介突然惊醒。</p>
<p>“嗯，最后一个问题，说吧。”蕾妤了停下离开教室的脚步。</p>
<p>“为…为什么要告诉我这些？为什么是我？不可能是因为我高数课睡觉吧！一定是有什么原因的！”</p>
<p>叶瑾介试图掩饰自己的惊恐，听到问题的蕾妤轻轻地笑了一下，继续迈开脚步，离开了房间，叶瑾介急忙追到教室门外，却没能再看到她。</p>
<p>“想想吧，你梦里的故事。”</p>
<p>是蕾妤的声音，从走廊飘来。</p>
<p>“对了，作为课代表，你上课睡觉的事，已经被记录下来了喔。”</p>
<p>叶瑾介一直紧紧攥着的高数书，终于又掉在了地上。</p>
<hr>
<h1>穿越者的降临</h1>
<h2 id="穿越者的降临（一）">穿越者的降临（一）</h2>
<p>蕾妤是个孤儿。</p>
<p>据收留她孤儿院的院长老人回忆，那是一个冬天的早上，院长在门口扫雪时，听见敲门的声音，打开们发现了一个在雪地里小脸冻得通红的紫发女孩，院长赶紧将她领进了门，在她身上发现了一笔钱和一张纸，钱是拿给孤儿院的，纸是给蕾妤留下的。奇怪的是，纸上不仅写了蕾妤的名字和对小蕾妤最后的嘱托，还有对蕾妤的几条预言。</p>
<p>命运是可以改变的吗？蕾妤的出现就是对此最好的解释。</p>
<p>蕾妤第一次发现自己的这种能力是在孤儿院的一次糕点时间，蕾妤现在还记得清清楚楚，那时候幼育员问她“你要饼干还是面包？”</p>
<p>“你要饼干还是面包？”</p>
<p>这个普通人并不会记住太久的问题，却被蕾妤深深地记在了脑海，因为她当时纠结了很久，最后选择饼干，不过，在还没拿到饼干时她就后悔了——因为饼干虽然好吃但明显吃不饱。孤儿院的食物是分配制的，选定的食物一般不能更改。小蕾妤心里想着要是刚刚选面包就好了，那么今天至少不再那么饿了。</p>
<p>就在这时，幼育员居然将面包递给了小蕾妤，小蕾妤胆怯地问道为什么拿给自己面包？幼育员疑惑地回答说难道不是你自己选的吗？然后又开始教导小蕾妤要知足，要对自己的选择负责不能更改，后面又扯到节约粮食什么的，当时的蕾妤只能以为是幼育员阿姨记错了，后来才知道，她那时候，已经穿越世界线了。</p>
<p>这时，那张纸上的第一个预言实现了。</p>
<h2 id="穿越者的降临（二）">穿越者的降临（二）</h2>
<p>叶瑾介回到了寝室，室友们都不在，他觉得很奇怪，按道理现在应该是”峡谷四坑一”时间，四人间寝室的室友应该边扣着脚边冲着电脑屏幕大喊“索利亚噶同！”，但是现在，安静的就像刚才做的梦一般。</p>
<p>叶瑾介本来不是那种多疑的人，一般遇到这种情况除了窃喜然后赶紧打开隐藏文件夹里的某款青春游戏以外，也不会多虑，但也许是今天被灌输了一些不太妙的思想，一个人待着寝室让叶瑾介感到别扭。</p>
<p>叶瑾介摇了摇头，坐在桌子前想要好好休息一下，就在他准备把高数书塞回书架时，一不小心手一滑，书扑通一声掉在地上，滑出了一张卡片。叶瑾介疑惑地捡起卡片查看，背面一排烫金的字体写着“圣鹿蒂亚开发署”，叶瑾介正要翻到另一面时。</p>
<p>“别动。”</p>
<p>叶瑾介听见背后传来一声明显压着喉咙的男性嗓音。</p>
<p>“叶瑾介先生，别想着转过头来。”</p>
<p>声音顿了顿，然后贴在了叶瑾介耳边，悄悄地说。</p>
<p>“我他妈终于找到你了。”</p>
<p>叶瑾介打了个寒战。</p>
<p>叶瑾介连连后退，惊恐地一屁股坐在下铺的床上。</p>
<p>因为转过身来出现在叶瑾介面前的是一个怪人，一个造型奇特的“鸟人”，身高超过了叶瑾介，瘦长的脑袋上是一对深邃漆黑的眼睛，从脑袋的顶部延申到后脑勺耷拉着几根稀疏的白色羽毛，最奇怪的是它那鹰嘴似的鼻子突出在外，整个脸的皮肤像是老大爷手里经常玩弄的核桃那样蜡黄，看着光滑实则沟壑遍布，不知道是因为本来就是怪物还是说是带着面具的人，叶瑾介希望他属于后者。</p>
<p>“鸟人”眉头紧凑在一起，直直地盯着叶瑾介的脸看，像是想要从他脸上找到什么答案。</p>
<p>叶瑾介也毫不放松的盯着他，因为想起了他刚刚说的话，叶瑾介更倾向于他只是个戴着面具的人，叶瑾介想知道是谁在背后装神弄鬼。</p>
<p>“……”。</p>
<p>气氛变得异常安静。</p>
<p>“呃，那个，你好像是他，又好像不是。”</p>
<p>“鸟人”率先打破沉默，用的一串废话。叶瑾介更加证实了自己的观点，这背后不仅是个人，还可能脑袋不灵光。</p>
<p>“鸟人”伸出了手——一只正常人类的手将叶瑾介拉了起来，叶瑾介这时才发现他下半身是一套挺拔的西装，估计价格不菲。</p>
<p>“你找谁？”</p>
<p>叶瑾介本来想大骂他一顿，但是看见他昂贵的西装总感觉自己气势起不来，最后只得不情愿地突出这三个字。</p>
<p>“时间紧迫，来不及解释了。”</p>
<p>鸟人快速地整理了一下衣服，捡起了因为惊吓被叶瑾介摔在地上写有“圣鹿蒂亚开发署”的烫金卡片，随后径直走向叶瑾介寝室的生活阳台，在确认窗子可以无障碍的打开后，满意地回到叶瑾介面前。</p>
<p>“我们得出发了，蕾妤还在等我们。”鸟人抓起叶瑾介的手就往阳台走。</p>
<p>“诶？！等…等等，什么情况！”</p>
<p>叶瑾介思路一片混乱，而且叶瑾介发现这鸟人的力气非常大，自己这样一个虽然从不健身而且运动但是过的肥宅生活的人……仔细想想果然反抗没有任何办法。</p>
<p>叶瑾介很快放弃了抵抗，开始跟他讨价还价。</p>
<p>“这位哥！要不我们先加个微信再相互了解一下？至少先谈谈价格啊！”</p>
<p>叶瑾介知道自己一紧张就说烂话的问题还是改不了。</p>
<p>走到阳台，鸟人猛地停住了，他放开了叶瑾介的手，双手合十，口中念念有词。</p>
<p>正当叶瑾介见鸟人站着不动准备脚底抹油溜之大吉时，那鸟人的西装背部突然被撕开了一条裂缝，从里面迸发出了金色的光芒，叶瑾介努力地睁着眼睛想要看清里面的东西，然后下一秒，里面突然伸出来了一对看着像扳手的东西，和光芒融为一体，变成了一对金黄色的，叶瑾介所熟知的，翅膀。</p>
<p>从小接受唯物主义的叶瑾介，此刻的世界观，碎了。</p>
<h2 id="穿越者的降临（三）">穿越者的降临（三）</h2>
<p>与此同时的另一边，一名紫发少女穿过学校大门前的天桥，然后拐入右手边的小巷，没走多久后停在了一片空地前，这片空地显得非常诡异，诡异的原因在于这一条小巷属于很老的政府批建区，所有建筑都采用的一个建筑设计，因此整条小巷看起来十分整齐统一。虽然现在已经没什么人影，但以前曾是人们茶余饭后最喜欢来闲逛的地方。但现在在建筑群中凭空多出了一片空地，破坏了整条小巷的和谐统一，像是丢失了一片拼图一般。这片空地已经突兀到单让人站在它面前就能够想象到这里应该是个什么样的建筑。</p>
<p>少女挽起学校的制服裙，半蹲下来，仔细察看着这片空地，可是她发现，无论怎么看，空地的地面以及与两旁建筑的交界面始终看不清楚，像是被什么东西所包围了起来，少女站起来思索了片刻然后突然折返，回到了第一个路口，在这里，她抬起头注视着日夜交替不停的红绿灯，目光显得很淡然，似乎在等着什么。</p>
<p>在路口中央被高高悬挂起来的信号控制器没有什么心事可想，它只是忠诚地执行着自己的任务，一遍又一遍，一天又一天。现在，它一如既往收到一串信号，或者说一段电流，指示它应该在这最后五秒将型号切换。</p>
<p>五，四，三，二，一。</p>
<p>绿灯亮起，如同苏醒一般，等待的车辆开始缓慢移动，拥堵的人群开始向街对面扩散，对于大部分人来说，这是再平常不过的一件事了。但是那个少女不见了，迎接她的是一个新世界。</p>
<p><img src="/2021/12/05/%E6%96%B0%E6%B3%BD%E6%B2%A1%E6%9C%89%E5%A4%8F%E5%A4%A9/mmexport1630742263320.jpg" alt></p>
<p>蕾妤站在刚才同样的位置前，但那片空地已经消失不见，取而代之的是一家普通的小店，招牌上写有“万古秘事屋”几个大字，看招牌来说这家店已经有一些历史了。</p>
<p>万古秘事屋这五个字是这里的都市传说的高频词，据说只要运气好，就能碰上一家神秘的委托店，不管你之前遗失了什么东西，都能在这家店通过委托找回，有人找回了被前女友带走的戒指，有人找回了失踪三年的宠物狗，甚至有人找回了坐船时掉入大海的手机——还能开机。</p>
<p>蕾妤透过模糊的橱窗向里看，橱柜摆放着一些像是古董一样的装饰品，屋中隐约有古朴的吊灯向外散发出暖黄色的灯光，显得与旁边的店铺格格不入。</p>
<p>蕾妤稍微的犹豫了一下，推门走了进去。</p>
<p>门咿咿呀呀的在蕾妤的背后合上，最后轻轻嘭的一声卡住门闩。蕾妤走进来的第一感受就是温暖。</p>
<p>眼前是一个不到十平米的小屋，小屋的正中间摆放着一座很大的尖塔，挡住了蕾妤的视线，正对着的是一副欧式古典画，画中是一个男人骑着马高举西洋剑的情景。蕾妤走近那幅画，看见了被尖塔挡住的斜角柜台，柜台里站着一位少女，引人注目的就是她那如绢般的灰色长发以及白皙的面容，透露出一种灵动之美，看起来与蕾妤的年纪相仿，正仔细地擦拭着一个高脚杯，似乎并没有发现蕾妤的到来。</p>
<p>“你好。”蕾妤试着打招呼。</p>
<p>“咦？！”</p>
<p>尽管蕾妤已经尽量地压低声音，少女依然被吓了一跳，手也不自觉抖了一下，高脚杯脱落下来，眼看就要碰到地面却被蕾妤迅速接住了，她用纤细的手指轻轻地弹了一下杯沿，高脚杯随即发出了“叮~”的一声脆响，蕾妤笑了笑，把杯子放回到桌面上。</p>
<p>“谢…谢谢。”少女似乎还没有从惊吓的状态恢复过来。</p>
<p>“这家店装饰的很漂亮哦。”</p>
<p>蕾妤说完这句话后发现柜台旁边摆放着一台挂钟，看起来年代久远，但依然平稳地运作着，钟摆不停的发出“噔，噔，噔…”的声响。</p>
<p>“谢谢夸奖，都是家母设计装饰的这家小店，已经好久没来过客人了，所以刚才的反应真是抱歉。”</p>
<p>少女微笑着向蕾妤说抱歉，看来是已经恢复过来了，收好了高脚杯后注意到了蕾妤的视线，便向她解释到。</p>
<p>“这台挂钟已经坏掉了，家母喜欢听钟摆的声音，便把它留在了这里。”</p>
<p>蕾妤点了一下头表示了解，接着说出了自己的来意。</p>
<p>“初次见面，我的名字叫蕾妤，请问你们是可以帮助找人找物的店铺吗？”</p>
<p>“有幸相识，蕾妤小姐，叫我凛希就好。”</p>
<p>虽然只是站在柜台里，像是充当着服务员的角色，但这位名叫凛希的少女初次见面给蕾妤一种大家闺秀的感觉，有着良好的教养，应该是从小就接受着良好的教育。</p>
<p>“哦？是有委托吗？请移步到内厅详谈吧。”</p>
<p>凛希缓缓走出柜台，将蕾妤引向一个小房间内，凛希帮蕾妤拉开了客椅，自己随后坐在了主位上。</p>
<p>“好香的茶。”</p>
<p>蕾妤刚入座便闻到一股清茶的芳香。</p>
<p>“蕾妤小姐也喜欢喝茶吗？家母喜茶，常说经常喝茶能够改变一个人的气神面貌，我现在也有在试着喝茶了。”</p>
<p>凛希拿出一套紫砂壶，她把茶叶放到器具里，将沸水倒入壶中，让水和茶叶适当接触，然后又迅速倒出，目的应该是去掉茶表面的杂质。她随即把沸水再次倒入壶中，倒水的过程中壶嘴微微向蕾妤点了三下。最后盖上壶盖，用沸水遍浇壶身，称之为“封壶”。</p>
<p>乘着凛希泡茶的间隙，蕾妤粗略地打量了一下这个房间。</p>
<p>房间内陈列的物件并不多，一边是一张原木圆桌配上两把椅子加上一些蒲团，另一边放有一个装满各种书籍信件的书架，似乎是存放档案的地方，中间用屏风相隔离开，形成了两个区域。</p>
<p>“所以蕾妤小姐想要找谁呢？抱歉的是，店中人手不够，平时只有我和家母照料，而家母现在有要事在身，一段时间内回来不了，但是我能帮你写下委托，这样的话家母回来就能及时察看了。”</p>
<p>凛希一边俯身给蕾妤倒茶一边解释到。</p>
<p>“谢谢，不要紧的，凛希小姐，实际上我想拜托你帮我找一个人。”</p>
<p>蕾妤端起茶杯向茶面轻轻地呼气，轻啜了一口茶，感觉肠胃也开始跟着温暖了起来。</p>
<p>“抱歉，家母有令，我不能随便离店。”</p>
<p>凛希面露难色，将双手贴在腿上，对着蕾妤摇了摇头。</p>
<p>“这么多年了，一直是你与令堂两个人在经营这家店吗？”</p>
<p>蕾妤叹了一口气，转换了话题。</p>
<p>“是的，家父很久以前就失踪了，一直以来都是麻烦家母操劳着各种事情。家母一般不会让我插手店铺的事，我都没能帮上什么忙。直到这次家母出门，我才开始出来接待客人。”</p>
<p>提起母亲凛希总是会不自觉的露出微笑，像是十分自豪。</p>
<p>“我小时候身体瘦弱，很少与他人接触，所以即使是现在和陌生人说话都会感到紧张，这次家母突然要让我来招待客人了，我除了兴奋，更多的是犹豫。怕不能做到像家母那样，为此我还专门训练了一段时间，因为我喜欢看书，所以偶尔会独自到附近的大学的图书馆去看书，去尝试融入人群。话说回来，蕾妤小姐是我接待的第一个顾客呢。”</p>
<p>凛希不自觉地说了很多，蕾妤并没有打断她，而是安静地坐在旁边倾听着。</p>
<p>“啊！抱歉，好久没和其他人说过话了，总感觉蕾妤小姐会是个很温柔的人，所以一不小心说了太多了。”</p>
<p>凛希满脸歉意，害羞地对着蕾妤笑了笑。</p>
<p>望着凛希的笑容，蕾妤想到了更多的事。</p>
<p>凛希的母亲和父亲都是圣鹿蒂亚开发署的前成员，凛希的父亲在凛希很小的时候就在一次任务的执行过程中失踪了，从那以后凛希的母亲便带着她离开了开发署,开发署理解她们的决定，从此不再插手她们的生活。</p>
<p>凛希一家并不是普通人，他们本应该是生活在一个子世界的正常人，但不幸的是，这个子世界泡位于两条不断接近彼此的孪生世界线的中间，随着两条世界线的不断挤压，时间、空间发生了错乱，这个子世界泡就被两边强大的吸引力撕碎，这个子世界就这样灭亡了。不过，凛希一家因为却世界线的引力变异，拥有了穿越时间线的能力，他们穿越过了子世界泡灭亡的时间点，幸存了下来。</p>
<p>为了阻止世界线继续相接近，阻止像他们那样的子世界泡灭亡，凛希的父母加入了圣鹿蒂亚开发署。</p>
<p>“诶？蕾妤小姐，是在想什么事情吗？”</p>
<p>凛希的话打断了蕾妤回忆。</p>
<p>“啊…没什么，对了，凛希，你看看这个。”</p>
<p>蕾妤假装把手伸进包里寻找着什么，其实她的包里什么也没有，但神奇是，空间开始出现波纹，空气中凭空凝结出一样东西，显然它并不属于这个世界。</p>
<p>“嗯？！这是家母的戒指？”</p>
<p>看到蕾妤手中的东西，凛希发出一声惊呼，惊讶地想要站起来。</p>
<p>“对，其实我已经见过令堂了，她给我这个东西，告诉我只要给你这个东西，你就能够帮助我的。”</p>
<p>“家母曾说，若是有人带着她的戒指来到我们的店铺，那我就要乖乖地听她的话。”</p>
<p>凛希细细地思索着，像是在回忆着母亲的话。</p>
<p>“那好的，蕾妤小姐，既然家母已经说过，那么我会帮助你的。”</p>
<p>“嗯，那好，那我们就走吧。”</p>
<p>蕾妤站了起来，微笑着对凛希伸出了手。</p>
<p>“还有，不用叫我蕾妤小姐啦，叫我蕾妤就行了。”</p>
<p>“我知道了，蕾妤小…，蕾妤。”</p>
<p>凛希不明白为什么要握手，但望着蕾妤坚定的目光，她也握住了蕾妤的手。</p>
<p>“那么，我应该要去找谁呢？”</p>
<p>面对凛希疑惑的神情，再想到接下来要说出的名字，蕾妤忍不住想笑出来。</p>
<p>“叶瑾介，一个普通人。”</p>
<h2 id="穿越者的降临（四）">穿越者的降临（四）</h2>
<p>“所以……那个……”</p>
<p>心脏狂跳双眼紧闭的叶瑾介脑海里突然出现了鸟人的声音。</p>
<p>“啊？啊！什么？”</p>
<p>叶瑾介闭着眼拼了命地大喊。</p>
<p>“……我说，你不要乱动！再乱动我就只能把你直接甩下去了！”</p>
<p>叶瑾介突然反应过来，他现在被鸟人的双手架在身下，正在新泽市上空滑翔。如果其他人能够看见的话，现在的叶瑾介就像是一只被鸟妈妈叼回家的虫子一样，在注定被分食的路上拼命地扭动的身体。</p>
<p>“喂喂喂！你到底要干啊！”</p>
<p>叶瑾介愤怒地喊向鸟人，语调中包含着一丝恐惧。</p>
<p>“想知道的话，睁开眼睛看看吧。”</p>
<p>脑海再次清晰的传来鸟人的声音，不过这次有故作深沉的嫌疑。叶瑾介冷静了下来，开始照着他的话做，在反复吸气呼气后,他缓缓地睁开了眼睛。</p>
<p>“……？！”</p>
<p>“啊！！这不还是在天上吗？你玩儿我是吗？”</p>
<p>叶瑾介慌乱中摸到一撮毛，思来想去后还是没敢扯下来。</p>
<p>“诶，反应很差嘛，我本来以为你会吓得晕过去的。”</p>
<p>“让你失望了真不好意思，我不恐高的，反而是你，不怕被别人看见吗？”</p>
<p>事实上，叶瑾介不仅不恐高，反而很喜欢去玩一些刺激的游乐项目。他经常去离家不远的一座叫作天香国色的游乐场游玩，当然是一个人。</p>
<p>话说回来，叶瑾介发现鸟人是反着架住他，估计是为了让他更方便说话。不过现在在呼啸的风声中，连叶瑾介自己都听不见自己的声音，不知道鸟人是怎么听清的。</p>
<p>“没事儿，他们看不见我们的。”</p>
<p>“看不见？为什么？”</p>
<p>鸟人的声音听起来满不在乎，叶瑾介很好奇。</p>
<p>“因为我现在和他们不是一个世界线的。他们看不见我。”</p>
<p>“又来了，我搞不懂啊。” 叶瑾介想起了蕾妤 ，“等等，你的意思是他们能看见我咯？！”</p>
<p>安分的虫子突然又挣扎了起来。</p>
<p>也就在这时，一位新泽市的普通市民张先生，正好抬起头来望向天空，微微愣了一会儿，然后撇向别处，发出了一道寻常的叹息。</p>
<p>“唉，眼镜又花了。”</p>
<p>“欸？蕾妤还没给你讲明白吗？”</p>
<p>“我发誓你去听也听不懂的。”</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>随想</category>
      </categories>
      <tags>
        <tag>新泽没有夏天</tag>
      </tags>
  </entry>
  <entry>
    <title>常用类、集合与IO</title>
    <url>/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/</url>
    <content><![CDATA[<h1>object类</h1>
<p>java语言所有类的根类，object也就是所有类的父类（也就意味着所有类都可以使用object类的方法），位于lang包中，所以不需要导包便可使用。</p>
<h2 id="getclass">getclass</h2>
<p>getclass()方法是返回应引用中存储的实际对象类型（返回值为class类型）</p>
<p>多用于判断两个对象是否是同一个类。</p>
<h2 id="hashCode">hashCode</h2>
<p>hashCode()方法返回的是一个int类型，是根据对象的地址或字符串或数字使用hash算法计算出的数值。</p>
<h2 id="tostring">tostring</h2>
<p>String tostring()   返回该对象的字符串表示。</p>
<p>类如我们创建一个person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用text测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        person p1 = <span class="keyword">new</span> person(<span class="string">&quot;瑾介&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        String s=p1.toString();</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211124624726.png" alt="image-20211211124624726"></p>
<p>我们发现，直接打印对象的名字，其实就是调用了tostring方法。打印的都是堆内存中的十六进制地址值。</p>
<p>如果想直接打印对象的属性的话，我们可以重写tostring方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;person&#123;name=&quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;,age=&quot;</span>+<span class="keyword">this</span>.age+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在再来打印的话：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211125454617.png" alt="image-20211211125454617"></p>
<p>这样就实现了我们自定义的tostring输出了。</p>
<h2 id="equals">equals</h2>
<p>指示其他的某个对象是否与此对象”相等“。</p>
<p>如果没有重写equals方法，那么它将会直接比较两个对象的地址值，我们依然用之前的person对象来做测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        person p1 = <span class="keyword">new</span> person(<span class="string">&quot;瑾介&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        person p2 = <span class="keyword">new</span> person(<span class="string">&quot;瑾介&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(p1.equals(p2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211130438858.png" alt="image-20211211130438858"></p>
<p>比较两个两个对象的地址值几乎没有什么意义，那我们还是来重写一下equals海曙吧。</p>
<p><em><strong>不过这里需要注意的是，这里隐含了一个多态的问题，即我们引入的参数obj是object类的，他无法访问到我们person类的name、age等参数，所以我们需要进行一个向下转型，也就是强制转换：</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">   person person = (person)obj;<span class="comment">//进行强制转换成我们的person类。</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.age==person.age&amp;&amp;<span class="keyword">this</span>.name==person.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211143201551.png" alt="image-20211211143201551"></p>
<p>当然为了防止类型转换异常，我们一般得写一个if条件来判断我们的参数是否是person的父类，完整的重写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> person) &#123;</span><br><span class="line">        person person = (person) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age == person.age &amp;&amp; <span class="keyword">this</span>.name == person.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//不是person类型直接false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="finalize">finalize</h2>
<p>当对象被判定为垃圾对象是，由jvm自动调用此方法，用于标记垃圾对象，进入回收队列。因为Java由自动回收垃圾机制，故平时一般不太会使用。</p>
<h1>String类</h1>
<h2 id="字符串池">字符串池</h2>
<p>字符串是常量，创建后不可以改变，字符串字面值存储在字符串池中，可以共享。</p>
<p>字符串池是位于堆的一个区，为了便于共享而创建的，当创建字符串的时候会先到字符串池里寻找，比如说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name=<span class="string">&quot;jinjie&quot;</span>;<span class="comment">//&quot;jinjie&quot;常量存储在字符串池中</span></span><br><span class="line">        name=<span class="string">&quot;jingjie&quot;</span>;<span class="comment">//新的字符串“jingjie”被创建赋值给了name（“jinjie”就成了废弃物。）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在多加两行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name=<span class="string">&quot;jinjie&quot;</span>;<span class="comment">//&quot;jinjie&quot;常量存储在字符串池中</span></span><br><span class="line">        name=<span class="string">&quot;jingjie&quot;</span>;<span class="comment">//新的字符串“jingjie”被创建赋值给了name（“jinjie”就成了废弃物。）</span></span><br><span class="line">         String name2=<span class="string">&quot;jingjie&quot;</span>;</span><br><span class="line">        System.out.println(name2==name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据共享的原则，这时候创建的name2先到字符串池中寻找有没有“jingjie”，在发现有之后，就把字符串池中“jingjie”的地址也赋值给了name2，所以name2和name的地址是相等的，所以结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211214144031671.png" alt="image-20211214144031671"></p>
<p>另外，我们有两种方式来定义字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name=<span class="string">&quot;jinjie&quot;</span>;</span><br><span class="line">String name=<span class="keyword">new</span> String(<span class="string">&quot;jinjie&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上面一种是我们常用的方法，它只创建了一个对象，但是下面一种方法我们却创造了两个对象，在堆里有一个对象，在字符串池里也有一个对象，但是真正的运行的时候只有一个对象，即堆里的对象也指向字符串池里的对象（所以比较浪费空间。</p>
<p>所以字符串比较要用equals进行比较（String重写了equals方法）。</p>
<h2 id="String的常用方法">String的常用方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;<span class="comment">//返回字符串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//根据下标获取字符。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String str)</span></span>;<span class="comment">//判断当前字符串是否含有str。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray();<span class="comment">//将字符串转化成数组。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span>;<span class="comment">//返回str首次出现的下标，若不存在则返回-1.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> interestinglast <span class="title">IndexOf</span><span class="params">(String str)</span>:<span class="comment">//查找字符串在当前字符串中最后一次出现的下标。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span></span>;<span class="comment">//去掉字符串的前后空格。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">()</span></span>;<span class="comment">//将小写转换成大写。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endWith</span><span class="params">(String str)</span></span>;<span class="comment">//判断字符串是否即以str结尾。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldchar,<span class="keyword">char</span> newChar)</span></span>;<span class="comment">//替换字符。</span></span><br><span class="line"><span class="keyword">public</span> String[] split(String str);<span class="comment">//根据str做拆分。</span></span><br></pre></td></tr></table></figure>
<h2 id="可变字符串">可变字符串</h2>
<p>StringBuilder:可变长字符串，效率快，线程不安全。</p>
<p>StringBuffer:可变长字符串，效率慢，线程安全。</p>
<blockquote>
<p>现在一般使用StringBuilder.</p>
</blockquote>
<p>我们来看个例子：</p>
<h1>包装类</h1>
<p>对于基本数据类型所拓展的包装类型，这样基本数据类型就可以实现更多的方法和功能。</p>
<blockquote>
<p>实际上，更深层的原因是Java不在支持指针操作，因此创造出了内部类的功能使得数据能在堆和栈之间进行转换。</p>
</blockquote>
<p>其包装类对应如下：</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody>
</table>
<p>每一种包装类型都由更多的方法与属性。</p>
<h2 id="装箱、拆箱">装箱、拆箱</h2>
<p>装箱：把栈里面的东西装到堆里面去（基本类型转换为引用类型）。</p>
<p><em>一般通过引用类型的构造方法实现，比如：</em><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212144744804.png" alt="image-20211212144744804"></p>
<p>拆箱：把堆里面的东西装到栈里面去（引用类型转换为基本类型）。</p>
<p><em>一般通过number类（包装类型的父类）的方法进行拆箱</em>*，比如：*</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212172036602.png" alt="image-20211212172036602"></p>
<blockquote>
<p>JDK1.5之后，java开始提供自动装箱和拆箱……意思是直接用赋值符号就行了。但其背后的实质是一样的，只是Java在背后帮我们自动操作了。</p>
</blockquote>
<h2 id="类型转换">类型转换</h2>
<h3 id="1、基本类型与字符串类型转换">1、基本类型与字符串类型转换</h3>
<h4 id="1-1使用-号">1.1使用+号</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ni=<span class="number">10</span>;</span><br><span class="line">String s1=n1+<span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="1-2使用tostring方法">1.2使用tostring方法</h4>
<p>使用Integer中的tostring()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s2=Integer.toString(ni);</span><br><span class="line">String s2=Integer.toString(ni，<span class="number">16</span>);<span class="comment">//此方法可以重载，按十六进制进行转换。 </span></span><br></pre></td></tr></table></figure>
<h3 id="2、字符串类型与基本类型转换">2、字符串类型与基本类型转换</h3>
<h4 id="2-1使用Integer的parse方法">2.1使用Integer的parse方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">&quot;150&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> n=Integer.parse(str);<span class="comment">//str里只能有数字。</span></span><br></pre></td></tr></table></figure>
<h3 id="3、Boolean字符串转换为基本类型">3、Boolean字符串转换为基本类型</h3>
<p>依旧使用parse进行格式化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str2=<span class="string">&quot;true&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> b1=Boolean.parseBoolean(str2);<span class="comment">//只用true能被格式化为true,其它字符均为false。</span></span><br></pre></td></tr></table></figure>
<h2 id="整数缓冲区">整数缓冲区</h2>
<p>Java预先创建了256的常用的整数包装对象，在实际的应用当中，对已经创建的对象进行复用。</p>
<p>我们来举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer integer1 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">        Integer integer2 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">        System.out.println(integer1==integer2);</span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        Integer integer3=<span class="number">100</span>;<span class="comment">//自动装箱</span></span><br><span class="line">        Integer integer4=<span class="number">100</span>;</span><br><span class="line">        System.out.println(integer4==integer3);</span><br><span class="line">      	Integer integer5=<span class="number">200</span>;</span><br><span class="line">        Integer integer6=<span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>猜猜看会输出什么？</p>
<p>表面上都是生成代表int值100的Integer类型，但结果是：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212180010477.png" alt="image-20211212180010477"></p>
<p>为什么会出现这种情况呢？这是因为integer1与integer2是new出来的，属于不同的地址，“==”比较的是地址值，第一个当然不同。</p>
<p>第二个为自动装箱，调用的都是Integer的valueof方法。那我们来看一下valueof方法：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212180440932.png" alt="image-20211212180440932"></p>
<p>是不是发现只要参数是在一定范围里的int，那么就返回了一个cache数组里的元素？</p>
<p>我们再来具体的看一看具体的数和cache数组：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211212180855001.png" alt="静态中间那坨可以忽略"></p>
<p><em>静态中间那坨可以忽略，为的是最后的high=h</em></p>
<p>这，就是我们的整数缓冲区，一个名为cache的数组，最高high为127，low为-128，所以我们的integer3与integer4是同一个，已经被实例好的对象，所以就是相等的咯。</p>
<p>当然，相信大家都发现了，integer5与integer6的int数字是大于了127的，所以执行相应语句，也就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br></pre></td></tr></table></figure>
<p>那这自然就跟1、2的结果是一样的了。</p>
<h1>日期时间类</h1>
<h2 id="Date类">Date类</h2>
<p>类Date表示特定的瞬间，精确到毫秒。</p>
<blockquote>
<p>毫秒，即为千分之一秒。</p>
</blockquote>
<p>毫秒值一般用于计算日期的间隔，即将日期都转换成毫秒值进行加减，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.currentTimeMillis()<span class="comment">//可以输出当前系统时间距离时间原点1970年1月1日凌晨经历了多少毫秒</span></span><br></pre></td></tr></table></figure>
<h3 id="无参构造">无参构造</h3>
<p>直接实例化一个无参构造的Date类，打印出来将是我们系统的标准时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">date</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">			text();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">text</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211150504218.png" alt="image-20211211150504218"></p>
<p>这里的CST指的是中国标准时间。</p>
<h3 id="带参的构造方法">带参的构造方法</h3>
<p>Date类还可以使用带参的构造方法，此时参数为从时间原点开始的毫秒值，列如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date(<span class="number">0</span>);<span class="comment">//将上面的代码块的构造方法添加为0的参数。</span></span><br></pre></td></tr></table></figure>
<p>此时它就会打印：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211151139834.png" alt="image-20211211151139834"></p>
<p>即为打印时间原点。</p>
<h3 id="gettime-方法">gettime()方法</h3>
<p>将日期转换成毫秒值，返回的是一个long类型的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">      <span class="keyword">long</span> s=date.getTime();</span><br><span class="line">      System.out.println(s);</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211151520479.png" alt="image-20211211151520479"></p>
<h2 id="DateFormat类">DateFormat类</h2>
<p>是对时间与日期进行一个格式化的抽象类，属于Java.text包中，有两个作用：</p>
<p>格式化：从日期转到文本[String format(Date date)]</p>
<p>解析：从文本转到日期[Date parse(String source)]</p>
<p>由于DateFormat是一个抽象类，所以我们要用到他的子类SimpleDateFormat进行对日期格式的约束。</p>
<blockquote>
<p><code>SimpleDateFormat</code> 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt;  文本）、解析（文本 -&gt; 日期）和规范化。</p>
</blockquote>
<h3 id="格式化">格式化</h3>
<p>要相对时间进行一个格式化的输出，需要用到SimpleDateFormat里的format方法，那我们首先的得创建一个**”模式“**，通过这个模式来告诉我们的类应该怎样输出时间，在SimpleDateFormat类中，模式通过字母来代表创建，下面我们列举一些常用的代表：</p>
<table>
<thead>
<tr>
<th>字母代表</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody>
</table>
<p>所以我们可以写出类似于： <strong>”yyyy-MM-dd  HH:mm:ss“</strong>   这样的时间格式。</p>
<p>来创建一个SimpleDateFormat类试试吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">demo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SimpleDateFormat t1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日HH:mm:ss&quot;</span>);<span class="comment">//模式作为参数传入SimpleDateFormat类。</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();<span class="comment">//创建一个时期类</span></span><br><span class="line">        String time;</span><br><span class="line">        time=t1.format(date);<span class="comment">//用方法来格式化我们的日期类.</span></span><br><span class="line">        System.out.println(time);</span><br><span class="line">        System.out.println(date);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211155207944.png" alt="image-20211211155207944"></p>
<h3 id="解析">解析</h3>
<p>使用SimpleDateFormat里的parse方法，可以将一段字符串日期转换为Date类日期。</p>
<p>这里值得注意的是，如果字符串日期的模式与设定的模式不相符合的话，parse方法会抛出一个异常，这时我们要么使用throw继续向上抛出异常，要么使用try  catch自己进行处理。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">demo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SimpleDateFormat t1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日HH:mm:ss&quot;</span>);<span class="comment">//模式作为参数传入。</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        String time;</span><br><span class="line">        time=t1.format(date);</span><br><span class="line">        Date d1 = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//使用try catch来监控</span></span><br><span class="line">            d1=t1.parse(time);</span><br><span class="line">            System.out.println(d1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">           System.out.println(<span class="string">&quot;格式出错&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211163615731.png" alt="image-20211211163615731"></p>
<p>如果我们使用不一样的时间的话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat t2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年dd日MM月HH:mm:ss&quot;</span>);<span class="comment">//模式作为参数传入。</span></span><br><span class="line">d1=t2.parse(time);<span class="comment">//修改要捕获异常的语句</span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2021/12/10/%E5%B8%B8%E7%94%A8%E7%B1%BB%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8EIO/image-20211211164157365.png" alt="image-20211211164157365"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>用logisim实现八位可控加减法器</title>
    <url>/2021/12/03/%E7%AC%AC%E4%BA%8C/</url>
    <content><![CDATA[<h1>计算机组成原理实验</h1>
<p>你好，好久不见！吼吼吼吼吼吼吼吼吼吼吼吼吼吼吼，作为第二篇博客，我决定先从一些简单的实验分享开始啦！（实际因为本人是小菜鸡一只的原因。。）</p>
<h2 id="用logisim实现八位可控加减法器">用logisim实现八位可控加减法器</h2>
<h3 id="思路解析：">思路解析：</h3>
<p>要实现八位可控加减法器，采用并行思路，首先需要八个一位全加器，用分流器可以将八位二进制数分离，使得单独每一位用一位全加器来进行相关的运算，然后并行输出，最后用分流器进行还原。</p>
<h3 id="实验过程：">实验过程：</h3>
<p>1、首先进行一位全加器的设置，我们需要准备五个信号量，三个输入，两个输出，其中xi与yi为参加运算的对象，cin代表来自下一位的进位，si代表本位的输出结果，Cout代表向下一位的进位。</p>
<p><img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/%E5%9B%BE%E7%89%871.png" alt="11"></p>
<p>2、设计思路为：先用一个异或门判断xi与yi的和的情况，若异或门为1，则xi+yi==1，此时与cin进位再次进行异或门判断，若异或门为仍1，则说明不产生进位，则si可置1。若第一个异或门与cin的与门为1，则说明产生了进位并且si位为0.当xi与yi的与门为1时，cin也应该置1。经过调试判断，最终如图所示。</p>
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片2.png" style="zoom:50%;">
<p>3、用logisim进行测试，检验是否制作成果，经检验得制作成功。</p>
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片3.png" style="zoom:33%;">
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片4.png" style="zoom:50%;">
<p>4、制作分流器，准备分流器，数据位宽为8的输入，8个数据位宽为1的隧道，将隧道与分流器相连，分流器与8位位宽的输入相连。</p>
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片6.png" style="zoom:50%;">
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片7.png" style="zoom:50%;">
<p>5、同理，准备一个y输入与s输出。</p>
<p><img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/%E5%9B%BE%E7%89%878.png" alt></p>
<p><img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/%E5%9B%BE%E7%89%879.png" alt></p>
<p>6、准备8个一位全加器，一个用于表示加减的输入sub，一个用于检测溢出的of（overflow），一个cout表示最高位的进位。<br>
其基本思路是：利用sub与y输入形成异或门，用于执行加和减时y的不同形态，将异或门的结果与一起并入全加器的两个加位，输出位依次接上s的8个隧道。将8个全加器按照这样的方式链接，最后将一位全加器用进位位连接起来，sub链接至第一个全加器的进位位，这样做的目的是将原本的（x+y）变成（x+y的补码）即为（x+（1+y的反码））。结果连接如下。</p>
<img src="/2021/12/03/%E7%AC%AC%E4%BA%8C/图片10.png" style="zoom:80%;">
]]></content>
      <categories>
        <category>学习</category>
        <category>硬件设计</category>
      </categories>
      <tags>
        <tag>logisim</tag>
      </tags>
  </entry>
</search>
